
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Child
 * 
 */
export type Child = $Result.DefaultSelection<Prisma.$ChildPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageAcknowledgment
 * 
 */
export type MessageAcknowledgment = $Result.DefaultSelection<Prisma.$MessageAcknowledgmentPayload>
/**
 * Model Survey
 * 
 */
export type Survey = $Result.DefaultSelection<Prisma.$SurveyPayload>
/**
 * Model SurveyResponse
 * 
 */
export type SurveyResponse = $Result.DefaultSelection<Prisma.$SurveyResponsePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventRsvp
 * 
 */
export type EventRsvp = $Result.DefaultSelection<Prisma.$EventRsvpPayload>
/**
 * Model TermDate
 * 
 */
export type TermDate = $Result.DefaultSelection<Prisma.$TermDatePayload>
/**
 * Model ScheduleItem
 * 
 */
export type ScheduleItem = $Result.DefaultSelection<Prisma.$ScheduleItemPayload>
/**
 * Model WeeklyMessage
 * 
 */
export type WeeklyMessage = $Result.DefaultSelection<Prisma.$WeeklyMessagePayload>
/**
 * Model WeeklyMessageHeart
 * 
 */
export type WeeklyMessageHeart = $Result.DefaultSelection<Prisma.$WeeklyMessageHeartPayload>
/**
 * Model KnowledgeCategory
 * 
 */
export type KnowledgeCategory = $Result.DefaultSelection<Prisma.$KnowledgeCategoryPayload>
/**
 * Model KnowledgeArticle
 * 
 */
export type KnowledgeArticle = $Result.DefaultSelection<Prisma.$KnowledgeArticlePayload>
/**
 * Model PulseSurvey
 * 
 */
export type PulseSurvey = $Result.DefaultSelection<Prisma.$PulseSurveyPayload>
/**
 * Model PulseResponse
 * 
 */
export type PulseResponse = $Result.DefaultSelection<Prisma.$PulseResponsePayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model FileFolder
 * 
 */
export type FileFolder = $Result.DefaultSelection<Prisma.$FileFolderPayload>
/**
 * Model SchoolFile
 * 
 */
export type SchoolFile = $Result.DefaultSelection<Prisma.$SchoolFilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  PARENT: 'PARENT',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Schools
 * const schools = await prisma.school.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Schools
   * const schools = await prisma.school.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.child`: Exposes CRUD operations for the **Child** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Children
    * const children = await prisma.child.findMany()
    * ```
    */
  get child(): Prisma.ChildDelegate<ExtArgs>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.messageAcknowledgment`: Exposes CRUD operations for the **MessageAcknowledgment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAcknowledgments
    * const messageAcknowledgments = await prisma.messageAcknowledgment.findMany()
    * ```
    */
  get messageAcknowledgment(): Prisma.MessageAcknowledgmentDelegate<ExtArgs>;

  /**
   * `prisma.survey`: Exposes CRUD operations for the **Survey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveys
    * const surveys = await prisma.survey.findMany()
    * ```
    */
  get survey(): Prisma.SurveyDelegate<ExtArgs>;

  /**
   * `prisma.surveyResponse`: Exposes CRUD operations for the **SurveyResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyResponses
    * const surveyResponses = await prisma.surveyResponse.findMany()
    * ```
    */
  get surveyResponse(): Prisma.SurveyResponseDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.eventRsvp`: Exposes CRUD operations for the **EventRsvp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventRsvps
    * const eventRsvps = await prisma.eventRsvp.findMany()
    * ```
    */
  get eventRsvp(): Prisma.EventRsvpDelegate<ExtArgs>;

  /**
   * `prisma.termDate`: Exposes CRUD operations for the **TermDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TermDates
    * const termDates = await prisma.termDate.findMany()
    * ```
    */
  get termDate(): Prisma.TermDateDelegate<ExtArgs>;

  /**
   * `prisma.scheduleItem`: Exposes CRUD operations for the **ScheduleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleItems
    * const scheduleItems = await prisma.scheduleItem.findMany()
    * ```
    */
  get scheduleItem(): Prisma.ScheduleItemDelegate<ExtArgs>;

  /**
   * `prisma.weeklyMessage`: Exposes CRUD operations for the **WeeklyMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyMessages
    * const weeklyMessages = await prisma.weeklyMessage.findMany()
    * ```
    */
  get weeklyMessage(): Prisma.WeeklyMessageDelegate<ExtArgs>;

  /**
   * `prisma.weeklyMessageHeart`: Exposes CRUD operations for the **WeeklyMessageHeart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyMessageHearts
    * const weeklyMessageHearts = await prisma.weeklyMessageHeart.findMany()
    * ```
    */
  get weeklyMessageHeart(): Prisma.WeeklyMessageHeartDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeCategory`: Exposes CRUD operations for the **KnowledgeCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeCategories
    * const knowledgeCategories = await prisma.knowledgeCategory.findMany()
    * ```
    */
  get knowledgeCategory(): Prisma.KnowledgeCategoryDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeArticle`: Exposes CRUD operations for the **KnowledgeArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeArticles
    * const knowledgeArticles = await prisma.knowledgeArticle.findMany()
    * ```
    */
  get knowledgeArticle(): Prisma.KnowledgeArticleDelegate<ExtArgs>;

  /**
   * `prisma.pulseSurvey`: Exposes CRUD operations for the **PulseSurvey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PulseSurveys
    * const pulseSurveys = await prisma.pulseSurvey.findMany()
    * ```
    */
  get pulseSurvey(): Prisma.PulseSurveyDelegate<ExtArgs>;

  /**
   * `prisma.pulseResponse`: Exposes CRUD operations for the **PulseResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PulseResponses
    * const pulseResponses = await prisma.pulseResponse.findMany()
    * ```
    */
  get pulseResponse(): Prisma.PulseResponseDelegate<ExtArgs>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs>;

  /**
   * `prisma.fileFolder`: Exposes CRUD operations for the **FileFolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileFolders
    * const fileFolders = await prisma.fileFolder.findMany()
    * ```
    */
  get fileFolder(): Prisma.FileFolderDelegate<ExtArgs>;

  /**
   * `prisma.schoolFile`: Exposes CRUD operations for the **SchoolFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolFiles
    * const schoolFiles = await prisma.schoolFile.findMany()
    * ```
    */
  get schoolFile(): Prisma.SchoolFileDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    School: 'School',
    User: 'User',
    Child: 'Child',
    Class: 'Class',
    Message: 'Message',
    MessageAcknowledgment: 'MessageAcknowledgment',
    Survey: 'Survey',
    SurveyResponse: 'SurveyResponse',
    Event: 'Event',
    EventRsvp: 'EventRsvp',
    TermDate: 'TermDate',
    ScheduleItem: 'ScheduleItem',
    WeeklyMessage: 'WeeklyMessage',
    WeeklyMessageHeart: 'WeeklyMessageHeart',
    KnowledgeCategory: 'KnowledgeCategory',
    KnowledgeArticle: 'KnowledgeArticle',
    PulseSurvey: 'PulseSurvey',
    PulseResponse: 'PulseResponse',
    Policy: 'Policy',
    FileFolder: 'FileFolder',
    SchoolFile: 'SchoolFile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "school" | "user" | "child" | "class" | "message" | "messageAcknowledgment" | "survey" | "surveyResponse" | "event" | "eventRsvp" | "termDate" | "scheduleItem" | "weeklyMessage" | "weeklyMessageHeart" | "knowledgeCategory" | "knowledgeArticle" | "pulseSurvey" | "pulseResponse" | "policy" | "fileFolder" | "schoolFile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Child: {
        payload: Prisma.$ChildPayload<ExtArgs>
        fields: Prisma.ChildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findFirst: {
            args: Prisma.ChildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findMany: {
            args: Prisma.ChildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          create: {
            args: Prisma.ChildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          createMany: {
            args: Prisma.ChildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          delete: {
            args: Prisma.ChildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          update: {
            args: Prisma.ChildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          deleteMany: {
            args: Prisma.ChildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          aggregate: {
            args: Prisma.ChildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChild>
          }
          groupBy: {
            args: Prisma.ChildGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChildGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChildCountArgs<ExtArgs>
            result: $Utils.Optional<ChildCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageAcknowledgment: {
        payload: Prisma.$MessageAcknowledgmentPayload<ExtArgs>
        fields: Prisma.MessageAcknowledgmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAcknowledgmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAcknowledgmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAcknowledgmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAcknowledgmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          findMany: {
            args: Prisma.MessageAcknowledgmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>[]
          }
          create: {
            args: Prisma.MessageAcknowledgmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          createMany: {
            args: Prisma.MessageAcknowledgmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageAcknowledgmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>[]
          }
          delete: {
            args: Prisma.MessageAcknowledgmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          update: {
            args: Prisma.MessageAcknowledgmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAcknowledgmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAcknowledgmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageAcknowledgmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAcknowledgmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAcknowledgment>
          }
          groupBy: {
            args: Prisma.MessageAcknowledgmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAcknowledgmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAcknowledgmentCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAcknowledgmentCountAggregateOutputType> | number
          }
        }
      }
      Survey: {
        payload: Prisma.$SurveyPayload<ExtArgs>
        fields: Prisma.SurveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          findFirst: {
            args: Prisma.SurveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          findMany: {
            args: Prisma.SurveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>[]
          }
          create: {
            args: Prisma.SurveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          createMany: {
            args: Prisma.SurveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>[]
          }
          delete: {
            args: Prisma.SurveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          update: {
            args: Prisma.SurveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          deleteMany: {
            args: Prisma.SurveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          aggregate: {
            args: Prisma.SurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurvey>
          }
          groupBy: {
            args: Prisma.SurveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyCountAggregateOutputType> | number
          }
        }
      }
      SurveyResponse: {
        payload: Prisma.$SurveyResponsePayload<ExtArgs>
        fields: Prisma.SurveyResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          findFirst: {
            args: Prisma.SurveyResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          findMany: {
            args: Prisma.SurveyResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
          }
          create: {
            args: Prisma.SurveyResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          createMany: {
            args: Prisma.SurveyResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
          }
          delete: {
            args: Prisma.SurveyResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          update: {
            args: Prisma.SurveyResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          deleteMany: {
            args: Prisma.SurveyResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          aggregate: {
            args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyResponse>
          }
          groupBy: {
            args: Prisma.SurveyResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyResponseCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventRsvp: {
        payload: Prisma.$EventRsvpPayload<ExtArgs>
        fields: Prisma.EventRsvpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventRsvpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventRsvpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          findFirst: {
            args: Prisma.EventRsvpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventRsvpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          findMany: {
            args: Prisma.EventRsvpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>[]
          }
          create: {
            args: Prisma.EventRsvpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          createMany: {
            args: Prisma.EventRsvpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventRsvpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>[]
          }
          delete: {
            args: Prisma.EventRsvpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          update: {
            args: Prisma.EventRsvpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          deleteMany: {
            args: Prisma.EventRsvpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventRsvpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventRsvpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          aggregate: {
            args: Prisma.EventRsvpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventRsvp>
          }
          groupBy: {
            args: Prisma.EventRsvpGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventRsvpGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventRsvpCountArgs<ExtArgs>
            result: $Utils.Optional<EventRsvpCountAggregateOutputType> | number
          }
        }
      }
      TermDate: {
        payload: Prisma.$TermDatePayload<ExtArgs>
        fields: Prisma.TermDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          findFirst: {
            args: Prisma.TermDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          findMany: {
            args: Prisma.TermDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>[]
          }
          create: {
            args: Prisma.TermDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          createMany: {
            args: Prisma.TermDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TermDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>[]
          }
          delete: {
            args: Prisma.TermDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          update: {
            args: Prisma.TermDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          deleteMany: {
            args: Prisma.TermDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TermDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          aggregate: {
            args: Prisma.TermDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermDate>
          }
          groupBy: {
            args: Prisma.TermDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermDateCountArgs<ExtArgs>
            result: $Utils.Optional<TermDateCountAggregateOutputType> | number
          }
        }
      }
      ScheduleItem: {
        payload: Prisma.$ScheduleItemPayload<ExtArgs>
        fields: Prisma.ScheduleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          findFirst: {
            args: Prisma.ScheduleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          findMany: {
            args: Prisma.ScheduleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>[]
          }
          create: {
            args: Prisma.ScheduleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          createMany: {
            args: Prisma.ScheduleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>[]
          }
          delete: {
            args: Prisma.ScheduleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          update: {
            args: Prisma.ScheduleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          aggregate: {
            args: Prisma.ScheduleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleItem>
          }
          groupBy: {
            args: Prisma.ScheduleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleItemCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleItemCountAggregateOutputType> | number
          }
        }
      }
      WeeklyMessage: {
        payload: Prisma.$WeeklyMessagePayload<ExtArgs>
        fields: Prisma.WeeklyMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          findFirst: {
            args: Prisma.WeeklyMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          findMany: {
            args: Prisma.WeeklyMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>[]
          }
          create: {
            args: Prisma.WeeklyMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          createMany: {
            args: Prisma.WeeklyMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>[]
          }
          delete: {
            args: Prisma.WeeklyMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          update: {
            args: Prisma.WeeklyMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          deleteMany: {
            args: Prisma.WeeklyMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeeklyMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          aggregate: {
            args: Prisma.WeeklyMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyMessage>
          }
          groupBy: {
            args: Prisma.WeeklyMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyMessageCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageCountAggregateOutputType> | number
          }
        }
      }
      WeeklyMessageHeart: {
        payload: Prisma.$WeeklyMessageHeartPayload<ExtArgs>
        fields: Prisma.WeeklyMessageHeartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyMessageHeartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyMessageHeartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          findFirst: {
            args: Prisma.WeeklyMessageHeartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyMessageHeartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          findMany: {
            args: Prisma.WeeklyMessageHeartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>[]
          }
          create: {
            args: Prisma.WeeklyMessageHeartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          createMany: {
            args: Prisma.WeeklyMessageHeartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyMessageHeartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>[]
          }
          delete: {
            args: Prisma.WeeklyMessageHeartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          update: {
            args: Prisma.WeeklyMessageHeartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          deleteMany: {
            args: Prisma.WeeklyMessageHeartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyMessageHeartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeeklyMessageHeartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          aggregate: {
            args: Prisma.WeeklyMessageHeartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyMessageHeart>
          }
          groupBy: {
            args: Prisma.WeeklyMessageHeartGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageHeartGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyMessageHeartCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageHeartCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeCategory: {
        payload: Prisma.$KnowledgeCategoryPayload<ExtArgs>
        fields: Prisma.KnowledgeCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          findMany: {
            args: Prisma.KnowledgeCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>[]
          }
          create: {
            args: Prisma.KnowledgeCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          createMany: {
            args: Prisma.KnowledgeCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          update: {
            args: Prisma.KnowledgeCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeCategory>
          }
          groupBy: {
            args: Prisma.KnowledgeCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeCategoryCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeArticle: {
        payload: Prisma.$KnowledgeArticlePayload<ExtArgs>
        fields: Prisma.KnowledgeArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          findMany: {
            args: Prisma.KnowledgeArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
          }
          create: {
            args: Prisma.KnowledgeArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          createMany: {
            args: Prisma.KnowledgeArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          update: {
            args: Prisma.KnowledgeArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeArticle>
          }
          groupBy: {
            args: Prisma.KnowledgeArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeArticleCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeArticleCountAggregateOutputType> | number
          }
        }
      }
      PulseSurvey: {
        payload: Prisma.$PulseSurveyPayload<ExtArgs>
        fields: Prisma.PulseSurveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PulseSurveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PulseSurveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          findFirst: {
            args: Prisma.PulseSurveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PulseSurveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          findMany: {
            args: Prisma.PulseSurveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>[]
          }
          create: {
            args: Prisma.PulseSurveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          createMany: {
            args: Prisma.PulseSurveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PulseSurveyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>[]
          }
          delete: {
            args: Prisma.PulseSurveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          update: {
            args: Prisma.PulseSurveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          deleteMany: {
            args: Prisma.PulseSurveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PulseSurveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PulseSurveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          aggregate: {
            args: Prisma.PulseSurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePulseSurvey>
          }
          groupBy: {
            args: Prisma.PulseSurveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PulseSurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PulseSurveyCountArgs<ExtArgs>
            result: $Utils.Optional<PulseSurveyCountAggregateOutputType> | number
          }
        }
      }
      PulseResponse: {
        payload: Prisma.$PulseResponsePayload<ExtArgs>
        fields: Prisma.PulseResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PulseResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PulseResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          findFirst: {
            args: Prisma.PulseResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PulseResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          findMany: {
            args: Prisma.PulseResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>[]
          }
          create: {
            args: Prisma.PulseResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          createMany: {
            args: Prisma.PulseResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PulseResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>[]
          }
          delete: {
            args: Prisma.PulseResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          update: {
            args: Prisma.PulseResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          deleteMany: {
            args: Prisma.PulseResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PulseResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PulseResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          aggregate: {
            args: Prisma.PulseResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePulseResponse>
          }
          groupBy: {
            args: Prisma.PulseResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PulseResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PulseResponseCountArgs<ExtArgs>
            result: $Utils.Optional<PulseResponseCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      FileFolder: {
        payload: Prisma.$FileFolderPayload<ExtArgs>
        fields: Prisma.FileFolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          findFirst: {
            args: Prisma.FileFolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          findMany: {
            args: Prisma.FileFolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>[]
          }
          create: {
            args: Prisma.FileFolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          createMany: {
            args: Prisma.FileFolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileFolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>[]
          }
          delete: {
            args: Prisma.FileFolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          update: {
            args: Prisma.FileFolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          deleteMany: {
            args: Prisma.FileFolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileFolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileFolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          aggregate: {
            args: Prisma.FileFolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileFolder>
          }
          groupBy: {
            args: Prisma.FileFolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileFolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileFolderCountArgs<ExtArgs>
            result: $Utils.Optional<FileFolderCountAggregateOutputType> | number
          }
        }
      }
      SchoolFile: {
        payload: Prisma.$SchoolFilePayload<ExtArgs>
        fields: Prisma.SchoolFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          findFirst: {
            args: Prisma.SchoolFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          findMany: {
            args: Prisma.SchoolFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>[]
          }
          create: {
            args: Prisma.SchoolFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          createMany: {
            args: Prisma.SchoolFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>[]
          }
          delete: {
            args: Prisma.SchoolFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          update: {
            args: Prisma.SchoolFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          deleteMany: {
            args: Prisma.SchoolFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          aggregate: {
            args: Prisma.SchoolFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolFile>
          }
          groupBy: {
            args: Prisma.SchoolFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolFileCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolFileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
    classes: number
    messages: number
    surveys: number
    events: number
    termDates: number
    scheduleItems: number
    weeklyMessages: number
    knowledgeCategories: number
    pulseSurveys: number
    policies: number
    folders: number
    files: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    classes?: boolean | SchoolCountOutputTypeCountClassesArgs
    messages?: boolean | SchoolCountOutputTypeCountMessagesArgs
    surveys?: boolean | SchoolCountOutputTypeCountSurveysArgs
    events?: boolean | SchoolCountOutputTypeCountEventsArgs
    termDates?: boolean | SchoolCountOutputTypeCountTermDatesArgs
    scheduleItems?: boolean | SchoolCountOutputTypeCountScheduleItemsArgs
    weeklyMessages?: boolean | SchoolCountOutputTypeCountWeeklyMessagesArgs
    knowledgeCategories?: boolean | SchoolCountOutputTypeCountKnowledgeCategoriesArgs
    pulseSurveys?: boolean | SchoolCountOutputTypeCountPulseSurveysArgs
    policies?: boolean | SchoolCountOutputTypeCountPoliciesArgs
    folders?: boolean | SchoolCountOutputTypeCountFoldersArgs
    files?: boolean | SchoolCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTermDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermDateWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountScheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountWeeklyMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountKnowledgeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeCategoryWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountPulseSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseSurveyWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolFileWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    children: number
    messageAcks: number
    surveyResponses: number
    eventRsvps: number
    pulseResponses: number
    weeklyHearts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | UserCountOutputTypeCountChildrenArgs
    messageAcks?: boolean | UserCountOutputTypeCountMessageAcksArgs
    surveyResponses?: boolean | UserCountOutputTypeCountSurveyResponsesArgs
    eventRsvps?: boolean | UserCountOutputTypeCountEventRsvpsArgs
    pulseResponses?: boolean | UserCountOutputTypeCountPulseResponsesArgs
    weeklyHearts?: boolean | UserCountOutputTypeCountWeeklyHeartsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageAcksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAcknowledgmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSurveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRsvpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPulseResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWeeklyHeartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageHeartWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    children: number
    messages: number
    surveys: number
    events: number
    scheduleItems: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ClassCountOutputTypeCountChildrenArgs
    messages?: boolean | ClassCountOutputTypeCountMessagesArgs
    surveys?: boolean | ClassCountOutputTypeCountSurveysArgs
    events?: boolean | ClassCountOutputTypeCountEventsArgs
    scheduleItems?: boolean | ClassCountOutputTypeCountScheduleItemsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountScheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    acknowledgments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgments?: boolean | MessageCountOutputTypeCountAcknowledgmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAcknowledgmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAcknowledgmentWhereInput
  }


  /**
   * Count Type SurveyCountOutputType
   */

  export type SurveyCountOutputType = {
    responses: number
  }

  export type SurveyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | SurveyCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyCountOutputType
     */
    select?: SurveyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    rsvps: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rsvps?: boolean | EventCountOutputTypeCountRsvpsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRsvpWhereInput
  }


  /**
   * Count Type WeeklyMessageCountOutputType
   */

  export type WeeklyMessageCountOutputType = {
    hearts: number
  }

  export type WeeklyMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hearts?: boolean | WeeklyMessageCountOutputTypeCountHeartsArgs
  }

  // Custom InputTypes
  /**
   * WeeklyMessageCountOutputType without action
   */
  export type WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageCountOutputType
     */
    select?: WeeklyMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeeklyMessageCountOutputType without action
   */
  export type WeeklyMessageCountOutputTypeCountHeartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageHeartWhereInput
  }


  /**
   * Count Type KnowledgeCategoryCountOutputType
   */

  export type KnowledgeCategoryCountOutputType = {
    articles: number
  }

  export type KnowledgeCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | KnowledgeCategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeCategoryCountOutputType without action
   */
  export type KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategoryCountOutputType
     */
    select?: KnowledgeCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeCategoryCountOutputType without action
   */
  export type KnowledgeCategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeArticleWhereInput
  }


  /**
   * Count Type PulseSurveyCountOutputType
   */

  export type PulseSurveyCountOutputType = {
    responses: number
  }

  export type PulseSurveyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | PulseSurveyCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * PulseSurveyCountOutputType without action
   */
  export type PulseSurveyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurveyCountOutputType
     */
    select?: PulseSurveyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PulseSurveyCountOutputType without action
   */
  export type PulseSurveyCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseResponseWhereInput
  }


  /**
   * Count Type FileFolderCountOutputType
   */

  export type FileFolderCountOutputType = {
    children: number
    files: number
  }

  export type FileFolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FileFolderCountOutputTypeCountChildrenArgs
    files?: boolean | FileFolderCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolderCountOutputType
     */
    select?: FileFolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
  }

  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolFileWhereInput
  }


  /**
   * Models
   */

  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    city: string | null
    academicYear: string | null
    brandColor: string | null
    accentColor: string | null
    tagline: string | null
    logoUrl: string | null
    logoIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    city: string | null
    academicYear: string | null
    brandColor: string | null
    accentColor: string | null
    tagline: string | null
    logoUrl: string | null
    logoIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    city: number
    academicYear: number
    brandColor: number
    accentColor: number
    tagline: number
    logoUrl: number
    logoIconUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    city?: true
    academicYear?: true
    brandColor?: true
    accentColor?: true
    tagline?: true
    logoUrl?: true
    logoIconUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    city?: true
    academicYear?: true
    brandColor?: true
    accentColor?: true
    tagline?: true
    logoUrl?: true
    logoIconUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    city?: true
    academicYear?: true
    brandColor?: true
    accentColor?: true
    tagline?: true
    logoUrl?: true
    logoIconUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    shortName: string
    city: string
    academicYear: string
    brandColor: string
    accentColor: string
    tagline: string | null
    logoUrl: string | null
    logoIconUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    city?: boolean
    academicYear?: boolean
    brandColor?: boolean
    accentColor?: boolean
    tagline?: boolean
    logoUrl?: boolean
    logoIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | School$usersArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    messages?: boolean | School$messagesArgs<ExtArgs>
    surveys?: boolean | School$surveysArgs<ExtArgs>
    events?: boolean | School$eventsArgs<ExtArgs>
    termDates?: boolean | School$termDatesArgs<ExtArgs>
    scheduleItems?: boolean | School$scheduleItemsArgs<ExtArgs>
    weeklyMessages?: boolean | School$weeklyMessagesArgs<ExtArgs>
    knowledgeCategories?: boolean | School$knowledgeCategoriesArgs<ExtArgs>
    pulseSurveys?: boolean | School$pulseSurveysArgs<ExtArgs>
    policies?: boolean | School$policiesArgs<ExtArgs>
    folders?: boolean | School$foldersArgs<ExtArgs>
    files?: boolean | School$filesArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    city?: boolean
    academicYear?: boolean
    brandColor?: boolean
    accentColor?: boolean
    tagline?: boolean
    logoUrl?: boolean
    logoIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    city?: boolean
    academicYear?: boolean
    brandColor?: boolean
    accentColor?: boolean
    tagline?: boolean
    logoUrl?: boolean
    logoIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | School$usersArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    messages?: boolean | School$messagesArgs<ExtArgs>
    surveys?: boolean | School$surveysArgs<ExtArgs>
    events?: boolean | School$eventsArgs<ExtArgs>
    termDates?: boolean | School$termDatesArgs<ExtArgs>
    scheduleItems?: boolean | School$scheduleItemsArgs<ExtArgs>
    weeklyMessages?: boolean | School$weeklyMessagesArgs<ExtArgs>
    knowledgeCategories?: boolean | School$knowledgeCategoriesArgs<ExtArgs>
    pulseSurveys?: boolean | School$pulseSurveysArgs<ExtArgs>
    policies?: boolean | School$policiesArgs<ExtArgs>
    folders?: boolean | School$foldersArgs<ExtArgs>
    files?: boolean | School$filesArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      termDates: Prisma.$TermDatePayload<ExtArgs>[]
      scheduleItems: Prisma.$ScheduleItemPayload<ExtArgs>[]
      weeklyMessages: Prisma.$WeeklyMessagePayload<ExtArgs>[]
      knowledgeCategories: Prisma.$KnowledgeCategoryPayload<ExtArgs>[]
      pulseSurveys: Prisma.$PulseSurveyPayload<ExtArgs>[]
      policies: Prisma.$PolicyPayload<ExtArgs>[]
      folders: Prisma.$FileFolderPayload<ExtArgs>[]
      files: Prisma.$SchoolFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      shortName: string
      city: string
      academicYear: string
      brandColor: string
      accentColor: string
      tagline: string | null
      logoUrl: string | null
      logoIconUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends School$classesArgs<ExtArgs> = {}>(args?: Subset<T, School$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends School$messagesArgs<ExtArgs> = {}>(args?: Subset<T, School$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    surveys<T extends School$surveysArgs<ExtArgs> = {}>(args?: Subset<T, School$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends School$eventsArgs<ExtArgs> = {}>(args?: Subset<T, School$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    termDates<T extends School$termDatesArgs<ExtArgs> = {}>(args?: Subset<T, School$termDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findMany"> | Null>
    scheduleItems<T extends School$scheduleItemsArgs<ExtArgs> = {}>(args?: Subset<T, School$scheduleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany"> | Null>
    weeklyMessages<T extends School$weeklyMessagesArgs<ExtArgs> = {}>(args?: Subset<T, School$weeklyMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findMany"> | Null>
    knowledgeCategories<T extends School$knowledgeCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, School$knowledgeCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    pulseSurveys<T extends School$pulseSurveysArgs<ExtArgs> = {}>(args?: Subset<T, School$pulseSurveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findMany"> | Null>
    policies<T extends School$policiesArgs<ExtArgs> = {}>(args?: Subset<T, School$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany"> | Null>
    folders<T extends School$foldersArgs<ExtArgs> = {}>(args?: Subset<T, School$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends School$filesArgs<ExtArgs> = {}>(args?: Subset<T, School$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly shortName: FieldRef<"School", 'String'>
    readonly city: FieldRef<"School", 'String'>
    readonly academicYear: FieldRef<"School", 'String'>
    readonly brandColor: FieldRef<"School", 'String'>
    readonly accentColor: FieldRef<"School", 'String'>
    readonly tagline: FieldRef<"School", 'String'>
    readonly logoUrl: FieldRef<"School", 'String'>
    readonly logoIconUrl: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.classes
   */
  export type School$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * School.messages
   */
  export type School$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * School.surveys
   */
  export type School$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * School.events
   */
  export type School$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * School.termDates
   */
  export type School$termDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    where?: TermDateWhereInput
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    cursor?: TermDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * School.scheduleItems
   */
  export type School$scheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * School.weeklyMessages
   */
  export type School$weeklyMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    where?: WeeklyMessageWhereInput
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    cursor?: WeeklyMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * School.knowledgeCategories
   */
  export type School$knowledgeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    where?: KnowledgeCategoryWhereInput
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    cursor?: KnowledgeCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * School.pulseSurveys
   */
  export type School$pulseSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    where?: PulseSurveyWhereInput
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    cursor?: PulseSurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * School.policies
   */
  export type School$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * School.folders
   */
  export type School$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    cursor?: FileFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * School.files
   */
  export type School$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    where?: SchoolFileWhereInput
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    cursor?: SchoolFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    schoolId: string | null
    googleId: string | null
    microsoftId: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    schoolId: string | null
    googleId: string | null
    microsoftId: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    schoolId: number
    googleId: number
    microsoftId: number
    avatarUrl: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    schoolId?: true
    googleId?: true
    microsoftId?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    schoolId?: true
    googleId?: true
    microsoftId?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    schoolId?: true
    googleId?: true
    microsoftId?: true
    avatarUrl?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: $Enums.Role
    schoolId: string
    googleId: string | null
    microsoftId: string | null
    avatarUrl: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    schoolId?: boolean
    googleId?: boolean
    microsoftId?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    children?: boolean | User$childrenArgs<ExtArgs>
    messageAcks?: boolean | User$messageAcksArgs<ExtArgs>
    surveyResponses?: boolean | User$surveyResponsesArgs<ExtArgs>
    eventRsvps?: boolean | User$eventRsvpsArgs<ExtArgs>
    pulseResponses?: boolean | User$pulseResponsesArgs<ExtArgs>
    weeklyHearts?: boolean | User$weeklyHeartsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    schoolId?: boolean
    googleId?: boolean
    microsoftId?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    schoolId?: boolean
    googleId?: boolean
    microsoftId?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    children?: boolean | User$childrenArgs<ExtArgs>
    messageAcks?: boolean | User$messageAcksArgs<ExtArgs>
    surveyResponses?: boolean | User$surveyResponsesArgs<ExtArgs>
    eventRsvps?: boolean | User$eventRsvpsArgs<ExtArgs>
    pulseResponses?: boolean | User$pulseResponsesArgs<ExtArgs>
    weeklyHearts?: boolean | User$weeklyHeartsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      children: Prisma.$ChildPayload<ExtArgs>[]
      messageAcks: Prisma.$MessageAcknowledgmentPayload<ExtArgs>[]
      surveyResponses: Prisma.$SurveyResponsePayload<ExtArgs>[]
      eventRsvps: Prisma.$EventRsvpPayload<ExtArgs>[]
      pulseResponses: Prisma.$PulseResponsePayload<ExtArgs>[]
      weeklyHearts: Prisma.$WeeklyMessageHeartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: $Enums.Role
      schoolId: string
      googleId: string | null
      microsoftId: string | null
      avatarUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    children<T extends User$childrenArgs<ExtArgs> = {}>(args?: Subset<T, User$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany"> | Null>
    messageAcks<T extends User$messageAcksArgs<ExtArgs> = {}>(args?: Subset<T, User$messageAcksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findMany"> | Null>
    surveyResponses<T extends User$surveyResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$surveyResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany"> | Null>
    eventRsvps<T extends User$eventRsvpsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventRsvpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findMany"> | Null>
    pulseResponses<T extends User$pulseResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$pulseResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findMany"> | Null>
    weeklyHearts<T extends User$weeklyHeartsArgs<ExtArgs> = {}>(args?: Subset<T, User$weeklyHeartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly microsoftId: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.children
   */
  export type User$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    cursor?: ChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * User.messageAcks
   */
  export type User$messageAcksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    where?: MessageAcknowledgmentWhereInput
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    cursor?: MessageAcknowledgmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * User.surveyResponses
   */
  export type User$surveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    cursor?: SurveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * User.eventRsvps
   */
  export type User$eventRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    where?: EventRsvpWhereInput
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    cursor?: EventRsvpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * User.pulseResponses
   */
  export type User$pulseResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    where?: PulseResponseWhereInput
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    cursor?: PulseResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * User.weeklyHearts
   */
  export type User$weeklyHeartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    where?: WeeklyMessageHeartWhereInput
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    cursor?: WeeklyMessageHeartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Child
   */

  export type AggregateChild = {
    _count: ChildCountAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  export type ChildMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    classId: string | null
  }

  export type ChildMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    classId: string | null
  }

  export type ChildCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    classId: number
    _all: number
  }


  export type ChildMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    classId?: true
  }

  export type ChildMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    classId?: true
  }

  export type ChildCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    classId?: true
    _all?: true
  }

  export type ChildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Child to aggregate.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Children
    **/
    _count?: true | ChildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildMaxAggregateInputType
  }

  export type GetChildAggregateType<T extends ChildAggregateArgs> = {
        [P in keyof T & keyof AggregateChild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChild[P]>
      : GetScalarType<T[P], AggregateChild[P]>
  }




  export type ChildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithAggregationInput | ChildOrderByWithAggregationInput[]
    by: ChildScalarFieldEnum[] | ChildScalarFieldEnum
    having?: ChildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildCountAggregateInputType | true
    _min?: ChildMinAggregateInputType
    _max?: ChildMaxAggregateInputType
  }

  export type ChildGroupByOutputType = {
    id: string
    name: string
    parentId: string
    classId: string
    _count: ChildCountAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  type GetChildGroupByPayload<T extends ChildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildGroupByOutputType[P]>
            : GetScalarType<T[P], ChildGroupByOutputType[P]>
        }
      >
    >


  export type ChildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    classId?: boolean
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    classId?: boolean
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    classId?: boolean
  }

  export type ChildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ChildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ChildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Child"
    objects: {
      parent: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      parentId: string
      classId: string
    }, ExtArgs["result"]["child"]>
    composites: {}
  }

  type ChildGetPayload<S extends boolean | null | undefined | ChildDefaultArgs> = $Result.GetResult<Prisma.$ChildPayload, S>

  type ChildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChildFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChildCountAggregateInputType | true
    }

  export interface ChildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Child'], meta: { name: 'Child' } }
    /**
     * Find zero or one Child that matches the filter.
     * @param {ChildFindUniqueArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChildFindUniqueArgs>(args: SelectSubset<T, ChildFindUniqueArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Child that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChildFindUniqueOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChildFindUniqueOrThrowArgs>(args: SelectSubset<T, ChildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Child that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChildFindFirstArgs>(args?: SelectSubset<T, ChildFindFirstArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Child that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChildFindFirstOrThrowArgs>(args?: SelectSubset<T, ChildFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Children that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Children
     * const children = await prisma.child.findMany()
     * 
     * // Get first 10 Children
     * const children = await prisma.child.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childWithIdOnly = await prisma.child.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChildFindManyArgs>(args?: SelectSubset<T, ChildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Child.
     * @param {ChildCreateArgs} args - Arguments to create a Child.
     * @example
     * // Create one Child
     * const Child = await prisma.child.create({
     *   data: {
     *     // ... data to create a Child
     *   }
     * })
     * 
     */
    create<T extends ChildCreateArgs>(args: SelectSubset<T, ChildCreateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Children.
     * @param {ChildCreateManyArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChildCreateManyArgs>(args?: SelectSubset<T, ChildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Children and returns the data saved in the database.
     * @param {ChildCreateManyAndReturnArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Children and only return the `id`
     * const childWithIdOnly = await prisma.child.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChildCreateManyAndReturnArgs>(args?: SelectSubset<T, ChildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Child.
     * @param {ChildDeleteArgs} args - Arguments to delete one Child.
     * @example
     * // Delete one Child
     * const Child = await prisma.child.delete({
     *   where: {
     *     // ... filter to delete one Child
     *   }
     * })
     * 
     */
    delete<T extends ChildDeleteArgs>(args: SelectSubset<T, ChildDeleteArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Child.
     * @param {ChildUpdateArgs} args - Arguments to update one Child.
     * @example
     * // Update one Child
     * const child = await prisma.child.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChildUpdateArgs>(args: SelectSubset<T, ChildUpdateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Children.
     * @param {ChildDeleteManyArgs} args - Arguments to filter Children to delete.
     * @example
     * // Delete a few Children
     * const { count } = await prisma.child.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChildDeleteManyArgs>(args?: SelectSubset<T, ChildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Children
     * const child = await prisma.child.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChildUpdateManyArgs>(args: SelectSubset<T, ChildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Child.
     * @param {ChildUpsertArgs} args - Arguments to update or create a Child.
     * @example
     * // Update or create a Child
     * const child = await prisma.child.upsert({
     *   create: {
     *     // ... data to create a Child
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Child we want to update
     *   }
     * })
     */
    upsert<T extends ChildUpsertArgs>(args: SelectSubset<T, ChildUpsertArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildCountArgs} args - Arguments to filter Children to count.
     * @example
     * // Count the number of Children
     * const count = await prisma.child.count({
     *   where: {
     *     // ... the filter for the Children we want to count
     *   }
     * })
    **/
    count<T extends ChildCountArgs>(
      args?: Subset<T, ChildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildAggregateArgs>(args: Subset<T, ChildAggregateArgs>): Prisma.PrismaPromise<GetChildAggregateType<T>>

    /**
     * Group by Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildGroupByArgs['orderBy'] }
        : { orderBy?: ChildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Child model
   */
  readonly fields: ChildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Child.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Child model
   */ 
  interface ChildFieldRefs {
    readonly id: FieldRef<"Child", 'String'>
    readonly name: FieldRef<"Child", 'String'>
    readonly parentId: FieldRef<"Child", 'String'>
    readonly classId: FieldRef<"Child", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Child findUnique
   */
  export type ChildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findUniqueOrThrow
   */
  export type ChildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findFirst
   */
  export type ChildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findFirstOrThrow
   */
  export type ChildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findMany
   */
  export type ChildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Children to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child create
   */
  export type ChildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to create a Child.
     */
    data: XOR<ChildCreateInput, ChildUncheckedCreateInput>
  }

  /**
   * Child createMany
   */
  export type ChildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Child createManyAndReturn
   */
  export type ChildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Child update
   */
  export type ChildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to update a Child.
     */
    data: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
    /**
     * Choose, which Child to update.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child updateMany
   */
  export type ChildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Children.
     */
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyInput>
    /**
     * Filter which Children to update
     */
    where?: ChildWhereInput
  }

  /**
   * Child upsert
   */
  export type ChildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The filter to search for the Child to update in case it exists.
     */
    where: ChildWhereUniqueInput
    /**
     * In case the Child found by the `where` argument doesn't exist, create a new Child with this data.
     */
    create: XOR<ChildCreateInput, ChildUncheckedCreateInput>
    /**
     * In case the Child was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
  }

  /**
   * Child delete
   */
  export type ChildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter which Child to delete.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child deleteMany
   */
  export type ChildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Children to delete
     */
    where?: ChildWhereInput
  }

  /**
   * Child without action
   */
  export type ChildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    colorBg: string | null
    colorText: string | null
    schoolId: string | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    colorBg: string | null
    colorText: string | null
    schoolId: string | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    colorBg: number
    colorText: number
    schoolId: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    colorBg?: true
    colorText?: true
    schoolId?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    colorBg?: true
    colorText?: true
    schoolId?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    colorBg?: true
    colorText?: true
    schoolId?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    colorBg: string
    colorText: string
    schoolId: string
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    colorBg?: boolean
    colorText?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    children?: boolean | Class$childrenArgs<ExtArgs>
    messages?: boolean | Class$messagesArgs<ExtArgs>
    surveys?: boolean | Class$surveysArgs<ExtArgs>
    events?: boolean | Class$eventsArgs<ExtArgs>
    scheduleItems?: boolean | Class$scheduleItemsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    colorBg?: boolean
    colorText?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    colorBg?: boolean
    colorText?: boolean
    schoolId?: boolean
  }

  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    children?: boolean | Class$childrenArgs<ExtArgs>
    messages?: boolean | Class$messagesArgs<ExtArgs>
    surveys?: boolean | Class$surveysArgs<ExtArgs>
    events?: boolean | Class$eventsArgs<ExtArgs>
    scheduleItems?: boolean | Class$scheduleItemsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      children: Prisma.$ChildPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      scheduleItems: Prisma.$ScheduleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      colorBg: string
      colorText: string
      schoolId: string
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    children<T extends Class$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Class$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Class$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Class$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    surveys<T extends Class$surveysArgs<ExtArgs> = {}>(args?: Subset<T, Class$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Class$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Class$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    scheduleItems<T extends Class$scheduleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Class$scheduleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly colorBg: FieldRef<"Class", 'String'>
    readonly colorText: FieldRef<"Class", 'String'>
    readonly schoolId: FieldRef<"Class", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
  }

  /**
   * Class.children
   */
  export type Class$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    cursor?: ChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Class.messages
   */
  export type Class$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Class.surveys
   */
  export type Class$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Class.events
   */
  export type Class$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Class.scheduleItems
   */
  export type Class$scheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    senderId: string | null
    senderName: string | null
    actionType: string | null
    actionLabel: string | null
    actionDueDate: Date | null
    actionAmount: string | null
    isPinned: boolean | null
    isUrgent: boolean | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    senderId: string | null
    senderName: string | null
    actionType: string | null
    actionLabel: string | null
    actionDueDate: Date | null
    actionAmount: string | null
    isPinned: boolean | null
    isUrgent: boolean | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    title: number
    content: number
    targetClass: number
    classId: number
    schoolId: number
    senderId: number
    senderName: number
    actionType: number
    actionLabel: number
    actionDueDate: number
    actionAmount: number
    isPinned: number
    isUrgent: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    senderId?: true
    senderName?: true
    actionType?: true
    actionLabel?: true
    actionDueDate?: true
    actionAmount?: true
    isPinned?: true
    isUrgent?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    senderId?: true
    senderName?: true
    actionType?: true
    actionLabel?: true
    actionDueDate?: true
    actionAmount?: true
    isPinned?: true
    isUrgent?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    senderId?: true
    senderName?: true
    actionType?: true
    actionLabel?: true
    actionDueDate?: true
    actionAmount?: true
    isPinned?: true
    isUrgent?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    title: string
    content: string
    targetClass: string
    classId: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType: string | null
    actionLabel: string | null
    actionDueDate: Date | null
    actionAmount: string | null
    isPinned: boolean
    isUrgent: boolean
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    senderId?: boolean
    senderName?: boolean
    actionType?: boolean
    actionLabel?: boolean
    actionDueDate?: boolean
    actionAmount?: boolean
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: boolean
    class?: boolean | Message$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    acknowledgments?: boolean | Message$acknowledgmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    senderId?: boolean
    senderName?: boolean
    actionType?: boolean
    actionLabel?: boolean
    actionDueDate?: boolean
    actionAmount?: boolean
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: boolean
    class?: boolean | Message$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    senderId?: boolean
    senderName?: boolean
    actionType?: boolean
    actionLabel?: boolean
    actionDueDate?: boolean
    actionAmount?: boolean
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Message$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    acknowledgments?: boolean | Message$acknowledgmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Message$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      acknowledgments: Prisma.$MessageAcknowledgmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      targetClass: string
      classId: string | null
      schoolId: string
      senderId: string
      senderName: string
      actionType: string | null
      actionLabel: string | null
      actionDueDate: Date | null
      actionAmount: string | null
      isPinned: boolean
      isUrgent: boolean
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Message$classArgs<ExtArgs> = {}>(args?: Subset<T, Message$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    acknowledgments<T extends Message$acknowledgmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$acknowledgmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly title: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly targetClass: FieldRef<"Message", 'String'>
    readonly classId: FieldRef<"Message", 'String'>
    readonly schoolId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly senderName: FieldRef<"Message", 'String'>
    readonly actionType: FieldRef<"Message", 'String'>
    readonly actionLabel: FieldRef<"Message", 'String'>
    readonly actionDueDate: FieldRef<"Message", 'DateTime'>
    readonly actionAmount: FieldRef<"Message", 'String'>
    readonly isPinned: FieldRef<"Message", 'Boolean'>
    readonly isUrgent: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.class
   */
  export type Message$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Message.acknowledgments
   */
  export type Message$acknowledgmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    where?: MessageAcknowledgmentWhereInput
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    cursor?: MessageAcknowledgmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageAcknowledgment
   */

  export type AggregateMessageAcknowledgment = {
    _count: MessageAcknowledgmentCountAggregateOutputType | null
    _min: MessageAcknowledgmentMinAggregateOutputType | null
    _max: MessageAcknowledgmentMaxAggregateOutputType | null
  }

  export type MessageAcknowledgmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageAcknowledgmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageAcknowledgmentCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type MessageAcknowledgmentMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type MessageAcknowledgmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type MessageAcknowledgmentCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAcknowledgmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAcknowledgment to aggregate.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAcknowledgments
    **/
    _count?: true | MessageAcknowledgmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAcknowledgmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAcknowledgmentMaxAggregateInputType
  }

  export type GetMessageAcknowledgmentAggregateType<T extends MessageAcknowledgmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAcknowledgment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAcknowledgment[P]>
      : GetScalarType<T[P], AggregateMessageAcknowledgment[P]>
  }




  export type MessageAcknowledgmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAcknowledgmentWhereInput
    orderBy?: MessageAcknowledgmentOrderByWithAggregationInput | MessageAcknowledgmentOrderByWithAggregationInput[]
    by: MessageAcknowledgmentScalarFieldEnum[] | MessageAcknowledgmentScalarFieldEnum
    having?: MessageAcknowledgmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAcknowledgmentCountAggregateInputType | true
    _min?: MessageAcknowledgmentMinAggregateInputType
    _max?: MessageAcknowledgmentMaxAggregateInputType
  }

  export type MessageAcknowledgmentGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    createdAt: Date
    _count: MessageAcknowledgmentCountAggregateOutputType | null
    _min: MessageAcknowledgmentMinAggregateOutputType | null
    _max: MessageAcknowledgmentMaxAggregateOutputType | null
  }

  type GetMessageAcknowledgmentGroupByPayload<T extends MessageAcknowledgmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAcknowledgmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAcknowledgmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAcknowledgmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAcknowledgmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAcknowledgmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAcknowledgment"]>

  export type MessageAcknowledgmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAcknowledgment"]>

  export type MessageAcknowledgmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type MessageAcknowledgmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageAcknowledgmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageAcknowledgmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAcknowledgment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["messageAcknowledgment"]>
    composites: {}
  }

  type MessageAcknowledgmentGetPayload<S extends boolean | null | undefined | MessageAcknowledgmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAcknowledgmentPayload, S>

  type MessageAcknowledgmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageAcknowledgmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageAcknowledgmentCountAggregateInputType | true
    }

  export interface MessageAcknowledgmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAcknowledgment'], meta: { name: 'MessageAcknowledgment' } }
    /**
     * Find zero or one MessageAcknowledgment that matches the filter.
     * @param {MessageAcknowledgmentFindUniqueArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAcknowledgmentFindUniqueArgs>(args: SelectSubset<T, MessageAcknowledgmentFindUniqueArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageAcknowledgment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageAcknowledgmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAcknowledgmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAcknowledgmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageAcknowledgment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentFindFirstArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAcknowledgmentFindFirstArgs>(args?: SelectSubset<T, MessageAcknowledgmentFindFirstArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageAcknowledgment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentFindFirstOrThrowArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAcknowledgmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAcknowledgmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageAcknowledgments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAcknowledgments
     * const messageAcknowledgments = await prisma.messageAcknowledgment.findMany()
     * 
     * // Get first 10 MessageAcknowledgments
     * const messageAcknowledgments = await prisma.messageAcknowledgment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAcknowledgmentWithIdOnly = await prisma.messageAcknowledgment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAcknowledgmentFindManyArgs>(args?: SelectSubset<T, MessageAcknowledgmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageAcknowledgment.
     * @param {MessageAcknowledgmentCreateArgs} args - Arguments to create a MessageAcknowledgment.
     * @example
     * // Create one MessageAcknowledgment
     * const MessageAcknowledgment = await prisma.messageAcknowledgment.create({
     *   data: {
     *     // ... data to create a MessageAcknowledgment
     *   }
     * })
     * 
     */
    create<T extends MessageAcknowledgmentCreateArgs>(args: SelectSubset<T, MessageAcknowledgmentCreateArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageAcknowledgments.
     * @param {MessageAcknowledgmentCreateManyArgs} args - Arguments to create many MessageAcknowledgments.
     * @example
     * // Create many MessageAcknowledgments
     * const messageAcknowledgment = await prisma.messageAcknowledgment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAcknowledgmentCreateManyArgs>(args?: SelectSubset<T, MessageAcknowledgmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageAcknowledgments and returns the data saved in the database.
     * @param {MessageAcknowledgmentCreateManyAndReturnArgs} args - Arguments to create many MessageAcknowledgments.
     * @example
     * // Create many MessageAcknowledgments
     * const messageAcknowledgment = await prisma.messageAcknowledgment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageAcknowledgments and only return the `id`
     * const messageAcknowledgmentWithIdOnly = await prisma.messageAcknowledgment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageAcknowledgmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageAcknowledgmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageAcknowledgment.
     * @param {MessageAcknowledgmentDeleteArgs} args - Arguments to delete one MessageAcknowledgment.
     * @example
     * // Delete one MessageAcknowledgment
     * const MessageAcknowledgment = await prisma.messageAcknowledgment.delete({
     *   where: {
     *     // ... filter to delete one MessageAcknowledgment
     *   }
     * })
     * 
     */
    delete<T extends MessageAcknowledgmentDeleteArgs>(args: SelectSubset<T, MessageAcknowledgmentDeleteArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageAcknowledgment.
     * @param {MessageAcknowledgmentUpdateArgs} args - Arguments to update one MessageAcknowledgment.
     * @example
     * // Update one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAcknowledgmentUpdateArgs>(args: SelectSubset<T, MessageAcknowledgmentUpdateArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageAcknowledgments.
     * @param {MessageAcknowledgmentDeleteManyArgs} args - Arguments to filter MessageAcknowledgments to delete.
     * @example
     * // Delete a few MessageAcknowledgments
     * const { count } = await prisma.messageAcknowledgment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAcknowledgmentDeleteManyArgs>(args?: SelectSubset<T, MessageAcknowledgmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAcknowledgments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAcknowledgments
     * const messageAcknowledgment = await prisma.messageAcknowledgment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAcknowledgmentUpdateManyArgs>(args: SelectSubset<T, MessageAcknowledgmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageAcknowledgment.
     * @param {MessageAcknowledgmentUpsertArgs} args - Arguments to update or create a MessageAcknowledgment.
     * @example
     * // Update or create a MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.upsert({
     *   create: {
     *     // ... data to create a MessageAcknowledgment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAcknowledgment we want to update
     *   }
     * })
     */
    upsert<T extends MessageAcknowledgmentUpsertArgs>(args: SelectSubset<T, MessageAcknowledgmentUpsertArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageAcknowledgments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentCountArgs} args - Arguments to filter MessageAcknowledgments to count.
     * @example
     * // Count the number of MessageAcknowledgments
     * const count = await prisma.messageAcknowledgment.count({
     *   where: {
     *     // ... the filter for the MessageAcknowledgments we want to count
     *   }
     * })
    **/
    count<T extends MessageAcknowledgmentCountArgs>(
      args?: Subset<T, MessageAcknowledgmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAcknowledgmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAcknowledgment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAcknowledgmentAggregateArgs>(args: Subset<T, MessageAcknowledgmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAcknowledgmentAggregateType<T>>

    /**
     * Group by MessageAcknowledgment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAcknowledgmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAcknowledgmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAcknowledgmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAcknowledgmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAcknowledgmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAcknowledgment model
   */
  readonly fields: MessageAcknowledgmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAcknowledgment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAcknowledgmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAcknowledgment model
   */ 
  interface MessageAcknowledgmentFieldRefs {
    readonly id: FieldRef<"MessageAcknowledgment", 'String'>
    readonly messageId: FieldRef<"MessageAcknowledgment", 'String'>
    readonly userId: FieldRef<"MessageAcknowledgment", 'String'>
    readonly createdAt: FieldRef<"MessageAcknowledgment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageAcknowledgment findUnique
   */
  export type MessageAcknowledgmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment findUniqueOrThrow
   */
  export type MessageAcknowledgmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment findFirst
   */
  export type MessageAcknowledgmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAcknowledgments.
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAcknowledgments.
     */
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * MessageAcknowledgment findFirstOrThrow
   */
  export type MessageAcknowledgmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAcknowledgments.
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAcknowledgments.
     */
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * MessageAcknowledgment findMany
   */
  export type MessageAcknowledgmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgments to fetch.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAcknowledgments.
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * MessageAcknowledgment create
   */
  export type MessageAcknowledgmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAcknowledgment.
     */
    data: XOR<MessageAcknowledgmentCreateInput, MessageAcknowledgmentUncheckedCreateInput>
  }

  /**
   * MessageAcknowledgment createMany
   */
  export type MessageAcknowledgmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAcknowledgments.
     */
    data: MessageAcknowledgmentCreateManyInput | MessageAcknowledgmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAcknowledgment createManyAndReturn
   */
  export type MessageAcknowledgmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageAcknowledgments.
     */
    data: MessageAcknowledgmentCreateManyInput | MessageAcknowledgmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAcknowledgment update
   */
  export type MessageAcknowledgmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAcknowledgment.
     */
    data: XOR<MessageAcknowledgmentUpdateInput, MessageAcknowledgmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAcknowledgment to update.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment updateMany
   */
  export type MessageAcknowledgmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAcknowledgments.
     */
    data: XOR<MessageAcknowledgmentUpdateManyMutationInput, MessageAcknowledgmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAcknowledgments to update
     */
    where?: MessageAcknowledgmentWhereInput
  }

  /**
   * MessageAcknowledgment upsert
   */
  export type MessageAcknowledgmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAcknowledgment to update in case it exists.
     */
    where: MessageAcknowledgmentWhereUniqueInput
    /**
     * In case the MessageAcknowledgment found by the `where` argument doesn't exist, create a new MessageAcknowledgment with this data.
     */
    create: XOR<MessageAcknowledgmentCreateInput, MessageAcknowledgmentUncheckedCreateInput>
    /**
     * In case the MessageAcknowledgment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAcknowledgmentUpdateInput, MessageAcknowledgmentUncheckedUpdateInput>
  }

  /**
   * MessageAcknowledgment delete
   */
  export type MessageAcknowledgmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAcknowledgment to delete.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment deleteMany
   */
  export type MessageAcknowledgmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAcknowledgments to delete
     */
    where?: MessageAcknowledgmentWhereInput
  }

  /**
   * MessageAcknowledgment without action
   */
  export type MessageAcknowledgmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
  }


  /**
   * Model Survey
   */

  export type AggregateSurvey = {
    _count: SurveyCountAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  export type SurveyMinAggregateOutputType = {
    id: string | null
    question: string | null
    active: boolean | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type SurveyMaxAggregateOutputType = {
    id: string | null
    question: string | null
    active: boolean | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type SurveyCountAggregateOutputType = {
    id: number
    question: number
    options: number
    active: number
    targetClass: number
    classId: number
    schoolId: number
    createdAt: number
    _all: number
  }


  export type SurveyMinAggregateInputType = {
    id?: true
    question?: true
    active?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    createdAt?: true
  }

  export type SurveyMaxAggregateInputType = {
    id?: true
    question?: true
    active?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    createdAt?: true
  }

  export type SurveyCountAggregateInputType = {
    id?: true
    question?: true
    options?: true
    active?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    createdAt?: true
    _all?: true
  }

  export type SurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Survey to aggregate.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Surveys
    **/
    _count?: true | SurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyMaxAggregateInputType
  }

  export type GetSurveyAggregateType<T extends SurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurvey[P]>
      : GetScalarType<T[P], AggregateSurvey[P]>
  }




  export type SurveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithAggregationInput | SurveyOrderByWithAggregationInput[]
    by: SurveyScalarFieldEnum[] | SurveyScalarFieldEnum
    having?: SurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyCountAggregateInputType | true
    _min?: SurveyMinAggregateInputType
    _max?: SurveyMaxAggregateInputType
  }

  export type SurveyGroupByOutputType = {
    id: string
    question: string
    options: JsonValue
    active: boolean
    targetClass: string
    classId: string | null
    schoolId: string
    createdAt: Date
    _count: SurveyCountAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  type GetSurveyGroupByPayload<T extends SurveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyGroupByOutputType[P]>
        }
      >
    >


  export type SurveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    options?: boolean
    active?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    class?: boolean | Survey$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    responses?: boolean | Survey$responsesArgs<ExtArgs>
    _count?: boolean | SurveyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survey"]>

  export type SurveySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    options?: boolean
    active?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    class?: boolean | Survey$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survey"]>

  export type SurveySelectScalar = {
    id?: boolean
    question?: boolean
    options?: boolean
    active?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    createdAt?: boolean
  }

  export type SurveyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Survey$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    responses?: boolean | Survey$responsesArgs<ExtArgs>
    _count?: boolean | SurveyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Survey$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SurveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Survey"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      responses: Prisma.$SurveyResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      options: Prisma.JsonValue
      active: boolean
      targetClass: string
      classId: string | null
      schoolId: string
      createdAt: Date
    }, ExtArgs["result"]["survey"]>
    composites: {}
  }

  type SurveyGetPayload<S extends boolean | null | undefined | SurveyDefaultArgs> = $Result.GetResult<Prisma.$SurveyPayload, S>

  type SurveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyCountAggregateInputType | true
    }

  export interface SurveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Survey'], meta: { name: 'Survey' } }
    /**
     * Find zero or one Survey that matches the filter.
     * @param {SurveyFindUniqueArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyFindUniqueArgs>(args: SelectSubset<T, SurveyFindUniqueArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Survey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyFindUniqueOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Survey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindFirstArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyFindFirstArgs>(args?: SelectSubset<T, SurveyFindFirstArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Survey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindFirstOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveys
     * const surveys = await prisma.survey.findMany()
     * 
     * // Get first 10 Surveys
     * const surveys = await prisma.survey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyWithIdOnly = await prisma.survey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyFindManyArgs>(args?: SelectSubset<T, SurveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Survey.
     * @param {SurveyCreateArgs} args - Arguments to create a Survey.
     * @example
     * // Create one Survey
     * const Survey = await prisma.survey.create({
     *   data: {
     *     // ... data to create a Survey
     *   }
     * })
     * 
     */
    create<T extends SurveyCreateArgs>(args: SelectSubset<T, SurveyCreateArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Surveys.
     * @param {SurveyCreateManyArgs} args - Arguments to create many Surveys.
     * @example
     * // Create many Surveys
     * const survey = await prisma.survey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyCreateManyArgs>(args?: SelectSubset<T, SurveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Surveys and returns the data saved in the database.
     * @param {SurveyCreateManyAndReturnArgs} args - Arguments to create many Surveys.
     * @example
     * // Create many Surveys
     * const survey = await prisma.survey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Surveys and only return the `id`
     * const surveyWithIdOnly = await prisma.survey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Survey.
     * @param {SurveyDeleteArgs} args - Arguments to delete one Survey.
     * @example
     * // Delete one Survey
     * const Survey = await prisma.survey.delete({
     *   where: {
     *     // ... filter to delete one Survey
     *   }
     * })
     * 
     */
    delete<T extends SurveyDeleteArgs>(args: SelectSubset<T, SurveyDeleteArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Survey.
     * @param {SurveyUpdateArgs} args - Arguments to update one Survey.
     * @example
     * // Update one Survey
     * const survey = await prisma.survey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyUpdateArgs>(args: SelectSubset<T, SurveyUpdateArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Surveys.
     * @param {SurveyDeleteManyArgs} args - Arguments to filter Surveys to delete.
     * @example
     * // Delete a few Surveys
     * const { count } = await prisma.survey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyDeleteManyArgs>(args?: SelectSubset<T, SurveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveys
     * const survey = await prisma.survey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyUpdateManyArgs>(args: SelectSubset<T, SurveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Survey.
     * @param {SurveyUpsertArgs} args - Arguments to update or create a Survey.
     * @example
     * // Update or create a Survey
     * const survey = await prisma.survey.upsert({
     *   create: {
     *     // ... data to create a Survey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Survey we want to update
     *   }
     * })
     */
    upsert<T extends SurveyUpsertArgs>(args: SelectSubset<T, SurveyUpsertArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyCountArgs} args - Arguments to filter Surveys to count.
     * @example
     * // Count the number of Surveys
     * const count = await prisma.survey.count({
     *   where: {
     *     // ... the filter for the Surveys we want to count
     *   }
     * })
    **/
    count<T extends SurveyCountArgs>(
      args?: Subset<T, SurveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyAggregateArgs>(args: Subset<T, SurveyAggregateArgs>): Prisma.PrismaPromise<GetSurveyAggregateType<T>>

    /**
     * Group by Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyGroupByArgs['orderBy'] }
        : { orderBy?: SurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Survey model
   */
  readonly fields: SurveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Survey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Survey$classArgs<ExtArgs> = {}>(args?: Subset<T, Survey$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responses<T extends Survey$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Survey$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Survey model
   */ 
  interface SurveyFieldRefs {
    readonly id: FieldRef<"Survey", 'String'>
    readonly question: FieldRef<"Survey", 'String'>
    readonly options: FieldRef<"Survey", 'Json'>
    readonly active: FieldRef<"Survey", 'Boolean'>
    readonly targetClass: FieldRef<"Survey", 'String'>
    readonly classId: FieldRef<"Survey", 'String'>
    readonly schoolId: FieldRef<"Survey", 'String'>
    readonly createdAt: FieldRef<"Survey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Survey findUnique
   */
  export type SurveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey findUniqueOrThrow
   */
  export type SurveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey findFirst
   */
  export type SurveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey findFirstOrThrow
   */
  export type SurveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey findMany
   */
  export type SurveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Surveys to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey create
   */
  export type SurveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The data needed to create a Survey.
     */
    data: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
  }

  /**
   * Survey createMany
   */
  export type SurveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Surveys.
     */
    data: SurveyCreateManyInput | SurveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Survey createManyAndReturn
   */
  export type SurveyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Surveys.
     */
    data: SurveyCreateManyInput | SurveyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Survey update
   */
  export type SurveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The data needed to update a Survey.
     */
    data: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
    /**
     * Choose, which Survey to update.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey updateMany
   */
  export type SurveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Surveys.
     */
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyInput>
    /**
     * Filter which Surveys to update
     */
    where?: SurveyWhereInput
  }

  /**
   * Survey upsert
   */
  export type SurveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The filter to search for the Survey to update in case it exists.
     */
    where: SurveyWhereUniqueInput
    /**
     * In case the Survey found by the `where` argument doesn't exist, create a new Survey with this data.
     */
    create: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
    /**
     * In case the Survey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
  }

  /**
   * Survey delete
   */
  export type SurveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter which Survey to delete.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey deleteMany
   */
  export type SurveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surveys to delete
     */
    where?: SurveyWhereInput
  }

  /**
   * Survey.class
   */
  export type Survey$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Survey.responses
   */
  export type Survey$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    cursor?: SurveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * Survey without action
   */
  export type SurveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
  }


  /**
   * Model SurveyResponse
   */

  export type AggregateSurveyResponse = {
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  export type SurveyResponseMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    userId: string | null
    response: string | null
    createdAt: Date | null
  }

  export type SurveyResponseMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    userId: string | null
    response: string | null
    createdAt: Date | null
  }

  export type SurveyResponseCountAggregateOutputType = {
    id: number
    surveyId: number
    userId: number
    response: number
    createdAt: number
    _all: number
  }


  export type SurveyResponseMinAggregateInputType = {
    id?: true
    surveyId?: true
    userId?: true
    response?: true
    createdAt?: true
  }

  export type SurveyResponseMaxAggregateInputType = {
    id?: true
    surveyId?: true
    userId?: true
    response?: true
    createdAt?: true
  }

  export type SurveyResponseCountAggregateInputType = {
    id?: true
    surveyId?: true
    userId?: true
    response?: true
    createdAt?: true
    _all?: true
  }

  export type SurveyResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponse to aggregate.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyResponses
    **/
    _count?: true | SurveyResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type GetSurveyResponseAggregateType<T extends SurveyResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyResponse[P]>
      : GetScalarType<T[P], AggregateSurveyResponse[P]>
  }




  export type SurveyResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithAggregationInput | SurveyResponseOrderByWithAggregationInput[]
    by: SurveyResponseScalarFieldEnum[] | SurveyResponseScalarFieldEnum
    having?: SurveyResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyResponseCountAggregateInputType | true
    _min?: SurveyResponseMinAggregateInputType
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type SurveyResponseGroupByOutputType = {
    id: string
    surveyId: string
    userId: string
    response: string
    createdAt: Date
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  type GetSurveyResponseGroupByPayload<T extends SurveyResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
        }
      >
    >


  export type SurveyResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    userId?: boolean
    response?: boolean
    createdAt?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type SurveyResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    userId?: boolean
    response?: boolean
    createdAt?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type SurveyResponseSelectScalar = {
    id?: boolean
    surveyId?: boolean
    userId?: boolean
    response?: boolean
    createdAt?: boolean
  }

  export type SurveyResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SurveyResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SurveyResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyResponse"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      userId: string
      response: string
      createdAt: Date
    }, ExtArgs["result"]["surveyResponse"]>
    composites: {}
  }

  type SurveyResponseGetPayload<S extends boolean | null | undefined | SurveyResponseDefaultArgs> = $Result.GetResult<Prisma.$SurveyResponsePayload, S>

  type SurveyResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SurveyResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveyResponseCountAggregateInputType | true
    }

  export interface SurveyResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyResponse'], meta: { name: 'SurveyResponse' } }
    /**
     * Find zero or one SurveyResponse that matches the filter.
     * @param {SurveyResponseFindUniqueArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyResponseFindUniqueArgs>(args: SelectSubset<T, SurveyResponseFindUniqueArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SurveyResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SurveyResponseFindUniqueOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SurveyResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindFirstArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyResponseFindFirstArgs>(args?: SelectSubset<T, SurveyResponseFindFirstArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SurveyResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindFirstOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SurveyResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany()
     * 
     * // Get first 10 SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyResponseWithIdOnly = await prisma.surveyResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyResponseFindManyArgs>(args?: SelectSubset<T, SurveyResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SurveyResponse.
     * @param {SurveyResponseCreateArgs} args - Arguments to create a SurveyResponse.
     * @example
     * // Create one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.create({
     *   data: {
     *     // ... data to create a SurveyResponse
     *   }
     * })
     * 
     */
    create<T extends SurveyResponseCreateArgs>(args: SelectSubset<T, SurveyResponseCreateArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SurveyResponses.
     * @param {SurveyResponseCreateManyArgs} args - Arguments to create many SurveyResponses.
     * @example
     * // Create many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyResponseCreateManyArgs>(args?: SelectSubset<T, SurveyResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyResponses and returns the data saved in the database.
     * @param {SurveyResponseCreateManyAndReturnArgs} args - Arguments to create many SurveyResponses.
     * @example
     * // Create many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyResponses and only return the `id`
     * const surveyResponseWithIdOnly = await prisma.surveyResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SurveyResponse.
     * @param {SurveyResponseDeleteArgs} args - Arguments to delete one SurveyResponse.
     * @example
     * // Delete one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.delete({
     *   where: {
     *     // ... filter to delete one SurveyResponse
     *   }
     * })
     * 
     */
    delete<T extends SurveyResponseDeleteArgs>(args: SelectSubset<T, SurveyResponseDeleteArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SurveyResponse.
     * @param {SurveyResponseUpdateArgs} args - Arguments to update one SurveyResponse.
     * @example
     * // Update one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyResponseUpdateArgs>(args: SelectSubset<T, SurveyResponseUpdateArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SurveyResponses.
     * @param {SurveyResponseDeleteManyArgs} args - Arguments to filter SurveyResponses to delete.
     * @example
     * // Delete a few SurveyResponses
     * const { count } = await prisma.surveyResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyResponseDeleteManyArgs>(args?: SelectSubset<T, SurveyResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyResponseUpdateManyArgs>(args: SelectSubset<T, SurveyResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyResponse.
     * @param {SurveyResponseUpsertArgs} args - Arguments to update or create a SurveyResponse.
     * @example
     * // Update or create a SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.upsert({
     *   create: {
     *     // ... data to create a SurveyResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyResponse we want to update
     *   }
     * })
     */
    upsert<T extends SurveyResponseUpsertArgs>(args: SelectSubset<T, SurveyResponseUpsertArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseCountArgs} args - Arguments to filter SurveyResponses to count.
     * @example
     * // Count the number of SurveyResponses
     * const count = await prisma.surveyResponse.count({
     *   where: {
     *     // ... the filter for the SurveyResponses we want to count
     *   }
     * })
    **/
    count<T extends SurveyResponseCountArgs>(
      args?: Subset<T, SurveyResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyResponseAggregateArgs>(args: Subset<T, SurveyResponseAggregateArgs>): Prisma.PrismaPromise<GetSurveyResponseAggregateType<T>>

    /**
     * Group by SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyResponseGroupByArgs['orderBy'] }
        : { orderBy?: SurveyResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyResponse model
   */
  readonly fields: SurveyResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyResponse model
   */ 
  interface SurveyResponseFieldRefs {
    readonly id: FieldRef<"SurveyResponse", 'String'>
    readonly surveyId: FieldRef<"SurveyResponse", 'String'>
    readonly userId: FieldRef<"SurveyResponse", 'String'>
    readonly response: FieldRef<"SurveyResponse", 'String'>
    readonly createdAt: FieldRef<"SurveyResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyResponse findUnique
   */
  export type SurveyResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse findUniqueOrThrow
   */
  export type SurveyResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse findFirst
   */
  export type SurveyResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse findFirstOrThrow
   */
  export type SurveyResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse findMany
   */
  export type SurveyResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponses to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse create
   */
  export type SurveyResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyResponse.
     */
    data: XOR<SurveyResponseCreateInput, SurveyResponseUncheckedCreateInput>
  }

  /**
   * SurveyResponse createMany
   */
  export type SurveyResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyResponses.
     */
    data: SurveyResponseCreateManyInput | SurveyResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyResponse createManyAndReturn
   */
  export type SurveyResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SurveyResponses.
     */
    data: SurveyResponseCreateManyInput | SurveyResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyResponse update
   */
  export type SurveyResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyResponse.
     */
    data: XOR<SurveyResponseUpdateInput, SurveyResponseUncheckedUpdateInput>
    /**
     * Choose, which SurveyResponse to update.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse updateMany
   */
  export type SurveyResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyResponses.
     */
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponses to update
     */
    where?: SurveyResponseWhereInput
  }

  /**
   * SurveyResponse upsert
   */
  export type SurveyResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyResponse to update in case it exists.
     */
    where: SurveyResponseWhereUniqueInput
    /**
     * In case the SurveyResponse found by the `where` argument doesn't exist, create a new SurveyResponse with this data.
     */
    create: XOR<SurveyResponseCreateInput, SurveyResponseUncheckedCreateInput>
    /**
     * In case the SurveyResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyResponseUpdateInput, SurveyResponseUncheckedUpdateInput>
  }

  /**
   * SurveyResponse delete
   */
  export type SurveyResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter which SurveyResponse to delete.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse deleteMany
   */
  export type SurveyResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponses to delete
     */
    where?: SurveyResponseWhereInput
  }

  /**
   * SurveyResponse without action
   */
  export type SurveyResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    requiresRsvp: boolean | null
    createdAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    requiresRsvp: boolean | null
    createdAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    time: number
    location: number
    targetClass: number
    classId: number
    schoolId: number
    requiresRsvp: number
    createdAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    requiresRsvp?: true
    createdAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    requiresRsvp?: true
    createdAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    requiresRsvp?: true
    createdAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    date: Date
    time: string | null
    location: string | null
    targetClass: string
    classId: string | null
    schoolId: string
    requiresRsvp: boolean
    createdAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    requiresRsvp?: boolean
    createdAt?: boolean
    class?: boolean | Event$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    rsvps?: boolean | Event$rsvpsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    requiresRsvp?: boolean
    createdAt?: boolean
    class?: boolean | Event$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    requiresRsvp?: boolean
    createdAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Event$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    rsvps?: boolean | Event$rsvpsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Event$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      rsvps: Prisma.$EventRsvpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      date: Date
      time: string | null
      location: string | null
      targetClass: string
      classId: string | null
      schoolId: string
      requiresRsvp: boolean
      createdAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Event$classArgs<ExtArgs> = {}>(args?: Subset<T, Event$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rsvps<T extends Event$rsvpsArgs<ExtArgs> = {}>(args?: Subset<T, Event$rsvpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly date: FieldRef<"Event", 'DateTime'>
    readonly time: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly targetClass: FieldRef<"Event", 'String'>
    readonly classId: FieldRef<"Event", 'String'>
    readonly schoolId: FieldRef<"Event", 'String'>
    readonly requiresRsvp: FieldRef<"Event", 'Boolean'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.class
   */
  export type Event$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Event.rsvps
   */
  export type Event$rsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    where?: EventRsvpWhereInput
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    cursor?: EventRsvpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventRsvp
   */

  export type AggregateEventRsvp = {
    _count: EventRsvpCountAggregateOutputType | null
    _min: EventRsvpMinAggregateOutputType | null
    _max: EventRsvpMaxAggregateOutputType | null
  }

  export type EventRsvpMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type EventRsvpMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type EventRsvpCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    status: number
    createdAt: number
    _all: number
  }


  export type EventRsvpMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type EventRsvpMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type EventRsvpCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type EventRsvpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRsvp to aggregate.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventRsvps
    **/
    _count?: true | EventRsvpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventRsvpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventRsvpMaxAggregateInputType
  }

  export type GetEventRsvpAggregateType<T extends EventRsvpAggregateArgs> = {
        [P in keyof T & keyof AggregateEventRsvp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRsvp[P]>
      : GetScalarType<T[P], AggregateEventRsvp[P]>
  }




  export type EventRsvpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRsvpWhereInput
    orderBy?: EventRsvpOrderByWithAggregationInput | EventRsvpOrderByWithAggregationInput[]
    by: EventRsvpScalarFieldEnum[] | EventRsvpScalarFieldEnum
    having?: EventRsvpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventRsvpCountAggregateInputType | true
    _min?: EventRsvpMinAggregateInputType
    _max?: EventRsvpMaxAggregateInputType
  }

  export type EventRsvpGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    status: string
    createdAt: Date
    _count: EventRsvpCountAggregateOutputType | null
    _min: EventRsvpMinAggregateOutputType | null
    _max: EventRsvpMaxAggregateOutputType | null
  }

  type GetEventRsvpGroupByPayload<T extends EventRsvpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventRsvpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventRsvpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventRsvpGroupByOutputType[P]>
            : GetScalarType<T[P], EventRsvpGroupByOutputType[P]>
        }
      >
    >


  export type EventRsvpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRsvp"]>

  export type EventRsvpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRsvp"]>

  export type EventRsvpSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type EventRsvpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventRsvpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventRsvpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventRsvp"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["eventRsvp"]>
    composites: {}
  }

  type EventRsvpGetPayload<S extends boolean | null | undefined | EventRsvpDefaultArgs> = $Result.GetResult<Prisma.$EventRsvpPayload, S>

  type EventRsvpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventRsvpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventRsvpCountAggregateInputType | true
    }

  export interface EventRsvpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRsvp'], meta: { name: 'EventRsvp' } }
    /**
     * Find zero or one EventRsvp that matches the filter.
     * @param {EventRsvpFindUniqueArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventRsvpFindUniqueArgs>(args: SelectSubset<T, EventRsvpFindUniqueArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventRsvp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventRsvpFindUniqueOrThrowArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventRsvpFindUniqueOrThrowArgs>(args: SelectSubset<T, EventRsvpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventRsvp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpFindFirstArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventRsvpFindFirstArgs>(args?: SelectSubset<T, EventRsvpFindFirstArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventRsvp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpFindFirstOrThrowArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventRsvpFindFirstOrThrowArgs>(args?: SelectSubset<T, EventRsvpFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventRsvps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRsvps
     * const eventRsvps = await prisma.eventRsvp.findMany()
     * 
     * // Get first 10 EventRsvps
     * const eventRsvps = await prisma.eventRsvp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventRsvpWithIdOnly = await prisma.eventRsvp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventRsvpFindManyArgs>(args?: SelectSubset<T, EventRsvpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventRsvp.
     * @param {EventRsvpCreateArgs} args - Arguments to create a EventRsvp.
     * @example
     * // Create one EventRsvp
     * const EventRsvp = await prisma.eventRsvp.create({
     *   data: {
     *     // ... data to create a EventRsvp
     *   }
     * })
     * 
     */
    create<T extends EventRsvpCreateArgs>(args: SelectSubset<T, EventRsvpCreateArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventRsvps.
     * @param {EventRsvpCreateManyArgs} args - Arguments to create many EventRsvps.
     * @example
     * // Create many EventRsvps
     * const eventRsvp = await prisma.eventRsvp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventRsvpCreateManyArgs>(args?: SelectSubset<T, EventRsvpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventRsvps and returns the data saved in the database.
     * @param {EventRsvpCreateManyAndReturnArgs} args - Arguments to create many EventRsvps.
     * @example
     * // Create many EventRsvps
     * const eventRsvp = await prisma.eventRsvp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventRsvps and only return the `id`
     * const eventRsvpWithIdOnly = await prisma.eventRsvp.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventRsvpCreateManyAndReturnArgs>(args?: SelectSubset<T, EventRsvpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventRsvp.
     * @param {EventRsvpDeleteArgs} args - Arguments to delete one EventRsvp.
     * @example
     * // Delete one EventRsvp
     * const EventRsvp = await prisma.eventRsvp.delete({
     *   where: {
     *     // ... filter to delete one EventRsvp
     *   }
     * })
     * 
     */
    delete<T extends EventRsvpDeleteArgs>(args: SelectSubset<T, EventRsvpDeleteArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventRsvp.
     * @param {EventRsvpUpdateArgs} args - Arguments to update one EventRsvp.
     * @example
     * // Update one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventRsvpUpdateArgs>(args: SelectSubset<T, EventRsvpUpdateArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventRsvps.
     * @param {EventRsvpDeleteManyArgs} args - Arguments to filter EventRsvps to delete.
     * @example
     * // Delete a few EventRsvps
     * const { count } = await prisma.eventRsvp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventRsvpDeleteManyArgs>(args?: SelectSubset<T, EventRsvpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRsvps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRsvps
     * const eventRsvp = await prisma.eventRsvp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventRsvpUpdateManyArgs>(args: SelectSubset<T, EventRsvpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventRsvp.
     * @param {EventRsvpUpsertArgs} args - Arguments to update or create a EventRsvp.
     * @example
     * // Update or create a EventRsvp
     * const eventRsvp = await prisma.eventRsvp.upsert({
     *   create: {
     *     // ... data to create a EventRsvp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRsvp we want to update
     *   }
     * })
     */
    upsert<T extends EventRsvpUpsertArgs>(args: SelectSubset<T, EventRsvpUpsertArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventRsvps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpCountArgs} args - Arguments to filter EventRsvps to count.
     * @example
     * // Count the number of EventRsvps
     * const count = await prisma.eventRsvp.count({
     *   where: {
     *     // ... the filter for the EventRsvps we want to count
     *   }
     * })
    **/
    count<T extends EventRsvpCountArgs>(
      args?: Subset<T, EventRsvpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventRsvpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventRsvp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventRsvpAggregateArgs>(args: Subset<T, EventRsvpAggregateArgs>): Prisma.PrismaPromise<GetEventRsvpAggregateType<T>>

    /**
     * Group by EventRsvp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventRsvpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRsvpGroupByArgs['orderBy'] }
        : { orderBy?: EventRsvpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventRsvpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRsvpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventRsvp model
   */
  readonly fields: EventRsvpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRsvp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventRsvpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventRsvp model
   */ 
  interface EventRsvpFieldRefs {
    readonly id: FieldRef<"EventRsvp", 'String'>
    readonly eventId: FieldRef<"EventRsvp", 'String'>
    readonly userId: FieldRef<"EventRsvp", 'String'>
    readonly status: FieldRef<"EventRsvp", 'String'>
    readonly createdAt: FieldRef<"EventRsvp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventRsvp findUnique
   */
  export type EventRsvpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp findUniqueOrThrow
   */
  export type EventRsvpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp findFirst
   */
  export type EventRsvpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRsvps.
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRsvps.
     */
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * EventRsvp findFirstOrThrow
   */
  export type EventRsvpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRsvps.
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRsvps.
     */
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * EventRsvp findMany
   */
  export type EventRsvpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvps to fetch.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventRsvps.
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * EventRsvp create
   */
  export type EventRsvpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * The data needed to create a EventRsvp.
     */
    data: XOR<EventRsvpCreateInput, EventRsvpUncheckedCreateInput>
  }

  /**
   * EventRsvp createMany
   */
  export type EventRsvpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventRsvps.
     */
    data: EventRsvpCreateManyInput | EventRsvpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventRsvp createManyAndReturn
   */
  export type EventRsvpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventRsvps.
     */
    data: EventRsvpCreateManyInput | EventRsvpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventRsvp update
   */
  export type EventRsvpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * The data needed to update a EventRsvp.
     */
    data: XOR<EventRsvpUpdateInput, EventRsvpUncheckedUpdateInput>
    /**
     * Choose, which EventRsvp to update.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp updateMany
   */
  export type EventRsvpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventRsvps.
     */
    data: XOR<EventRsvpUpdateManyMutationInput, EventRsvpUncheckedUpdateManyInput>
    /**
     * Filter which EventRsvps to update
     */
    where?: EventRsvpWhereInput
  }

  /**
   * EventRsvp upsert
   */
  export type EventRsvpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * The filter to search for the EventRsvp to update in case it exists.
     */
    where: EventRsvpWhereUniqueInput
    /**
     * In case the EventRsvp found by the `where` argument doesn't exist, create a new EventRsvp with this data.
     */
    create: XOR<EventRsvpCreateInput, EventRsvpUncheckedCreateInput>
    /**
     * In case the EventRsvp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventRsvpUpdateInput, EventRsvpUncheckedUpdateInput>
  }

  /**
   * EventRsvp delete
   */
  export type EventRsvpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter which EventRsvp to delete.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp deleteMany
   */
  export type EventRsvpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRsvps to delete
     */
    where?: EventRsvpWhereInput
  }

  /**
   * EventRsvp without action
   */
  export type EventRsvpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
  }


  /**
   * Model TermDate
   */

  export type AggregateTermDate = {
    _count: TermDateCountAggregateOutputType | null
    _avg: TermDateAvgAggregateOutputType | null
    _sum: TermDateSumAggregateOutputType | null
    _min: TermDateMinAggregateOutputType | null
    _max: TermDateMaxAggregateOutputType | null
  }

  export type TermDateAvgAggregateOutputType = {
    term: number | null
  }

  export type TermDateSumAggregateOutputType = {
    term: number | null
  }

  export type TermDateMinAggregateOutputType = {
    id: string | null
    term: number | null
    termName: string | null
    label: string | null
    sublabel: string | null
    date: Date | null
    endDate: Date | null
    type: string | null
    color: string | null
    schoolId: string | null
  }

  export type TermDateMaxAggregateOutputType = {
    id: string | null
    term: number | null
    termName: string | null
    label: string | null
    sublabel: string | null
    date: Date | null
    endDate: Date | null
    type: string | null
    color: string | null
    schoolId: string | null
  }

  export type TermDateCountAggregateOutputType = {
    id: number
    term: number
    termName: number
    label: number
    sublabel: number
    date: number
    endDate: number
    type: number
    color: number
    schoolId: number
    _all: number
  }


  export type TermDateAvgAggregateInputType = {
    term?: true
  }

  export type TermDateSumAggregateInputType = {
    term?: true
  }

  export type TermDateMinAggregateInputType = {
    id?: true
    term?: true
    termName?: true
    label?: true
    sublabel?: true
    date?: true
    endDate?: true
    type?: true
    color?: true
    schoolId?: true
  }

  export type TermDateMaxAggregateInputType = {
    id?: true
    term?: true
    termName?: true
    label?: true
    sublabel?: true
    date?: true
    endDate?: true
    type?: true
    color?: true
    schoolId?: true
  }

  export type TermDateCountAggregateInputType = {
    id?: true
    term?: true
    termName?: true
    label?: true
    sublabel?: true
    date?: true
    endDate?: true
    type?: true
    color?: true
    schoolId?: true
    _all?: true
  }

  export type TermDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermDate to aggregate.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TermDates
    **/
    _count?: true | TermDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TermDateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TermDateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermDateMaxAggregateInputType
  }

  export type GetTermDateAggregateType<T extends TermDateAggregateArgs> = {
        [P in keyof T & keyof AggregateTermDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermDate[P]>
      : GetScalarType<T[P], AggregateTermDate[P]>
  }




  export type TermDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermDateWhereInput
    orderBy?: TermDateOrderByWithAggregationInput | TermDateOrderByWithAggregationInput[]
    by: TermDateScalarFieldEnum[] | TermDateScalarFieldEnum
    having?: TermDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermDateCountAggregateInputType | true
    _avg?: TermDateAvgAggregateInputType
    _sum?: TermDateSumAggregateInputType
    _min?: TermDateMinAggregateInputType
    _max?: TermDateMaxAggregateInputType
  }

  export type TermDateGroupByOutputType = {
    id: string
    term: number
    termName: string
    label: string
    sublabel: string | null
    date: Date
    endDate: Date | null
    type: string
    color: string
    schoolId: string
    _count: TermDateCountAggregateOutputType | null
    _avg: TermDateAvgAggregateOutputType | null
    _sum: TermDateSumAggregateOutputType | null
    _min: TermDateMinAggregateOutputType | null
    _max: TermDateMaxAggregateOutputType | null
  }

  type GetTermDateGroupByPayload<T extends TermDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermDateGroupByOutputType[P]>
            : GetScalarType<T[P], TermDateGroupByOutputType[P]>
        }
      >
    >


  export type TermDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    termName?: boolean
    label?: boolean
    sublabel?: boolean
    date?: boolean
    endDate?: boolean
    type?: boolean
    color?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["termDate"]>

  export type TermDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    termName?: boolean
    label?: boolean
    sublabel?: boolean
    date?: boolean
    endDate?: boolean
    type?: boolean
    color?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["termDate"]>

  export type TermDateSelectScalar = {
    id?: boolean
    term?: boolean
    termName?: boolean
    label?: boolean
    sublabel?: boolean
    date?: boolean
    endDate?: boolean
    type?: boolean
    color?: boolean
    schoolId?: boolean
  }

  export type TermDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type TermDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $TermDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TermDate"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      term: number
      termName: string
      label: string
      sublabel: string | null
      date: Date
      endDate: Date | null
      type: string
      color: string
      schoolId: string
    }, ExtArgs["result"]["termDate"]>
    composites: {}
  }

  type TermDateGetPayload<S extends boolean | null | undefined | TermDateDefaultArgs> = $Result.GetResult<Prisma.$TermDatePayload, S>

  type TermDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TermDateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TermDateCountAggregateInputType | true
    }

  export interface TermDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TermDate'], meta: { name: 'TermDate' } }
    /**
     * Find zero or one TermDate that matches the filter.
     * @param {TermDateFindUniqueArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermDateFindUniqueArgs>(args: SelectSubset<T, TermDateFindUniqueArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TermDate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TermDateFindUniqueOrThrowArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermDateFindUniqueOrThrowArgs>(args: SelectSubset<T, TermDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TermDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateFindFirstArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermDateFindFirstArgs>(args?: SelectSubset<T, TermDateFindFirstArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TermDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateFindFirstOrThrowArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermDateFindFirstOrThrowArgs>(args?: SelectSubset<T, TermDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TermDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermDates
     * const termDates = await prisma.termDate.findMany()
     * 
     * // Get first 10 TermDates
     * const termDates = await prisma.termDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termDateWithIdOnly = await prisma.termDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermDateFindManyArgs>(args?: SelectSubset<T, TermDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TermDate.
     * @param {TermDateCreateArgs} args - Arguments to create a TermDate.
     * @example
     * // Create one TermDate
     * const TermDate = await prisma.termDate.create({
     *   data: {
     *     // ... data to create a TermDate
     *   }
     * })
     * 
     */
    create<T extends TermDateCreateArgs>(args: SelectSubset<T, TermDateCreateArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TermDates.
     * @param {TermDateCreateManyArgs} args - Arguments to create many TermDates.
     * @example
     * // Create many TermDates
     * const termDate = await prisma.termDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermDateCreateManyArgs>(args?: SelectSubset<T, TermDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TermDates and returns the data saved in the database.
     * @param {TermDateCreateManyAndReturnArgs} args - Arguments to create many TermDates.
     * @example
     * // Create many TermDates
     * const termDate = await prisma.termDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TermDates and only return the `id`
     * const termDateWithIdOnly = await prisma.termDate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TermDateCreateManyAndReturnArgs>(args?: SelectSubset<T, TermDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TermDate.
     * @param {TermDateDeleteArgs} args - Arguments to delete one TermDate.
     * @example
     * // Delete one TermDate
     * const TermDate = await prisma.termDate.delete({
     *   where: {
     *     // ... filter to delete one TermDate
     *   }
     * })
     * 
     */
    delete<T extends TermDateDeleteArgs>(args: SelectSubset<T, TermDateDeleteArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TermDate.
     * @param {TermDateUpdateArgs} args - Arguments to update one TermDate.
     * @example
     * // Update one TermDate
     * const termDate = await prisma.termDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermDateUpdateArgs>(args: SelectSubset<T, TermDateUpdateArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TermDates.
     * @param {TermDateDeleteManyArgs} args - Arguments to filter TermDates to delete.
     * @example
     * // Delete a few TermDates
     * const { count } = await prisma.termDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermDateDeleteManyArgs>(args?: SelectSubset<T, TermDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermDates
     * const termDate = await prisma.termDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermDateUpdateManyArgs>(args: SelectSubset<T, TermDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TermDate.
     * @param {TermDateUpsertArgs} args - Arguments to update or create a TermDate.
     * @example
     * // Update or create a TermDate
     * const termDate = await prisma.termDate.upsert({
     *   create: {
     *     // ... data to create a TermDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermDate we want to update
     *   }
     * })
     */
    upsert<T extends TermDateUpsertArgs>(args: SelectSubset<T, TermDateUpsertArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TermDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateCountArgs} args - Arguments to filter TermDates to count.
     * @example
     * // Count the number of TermDates
     * const count = await prisma.termDate.count({
     *   where: {
     *     // ... the filter for the TermDates we want to count
     *   }
     * })
    **/
    count<T extends TermDateCountArgs>(
      args?: Subset<T, TermDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermDateAggregateArgs>(args: Subset<T, TermDateAggregateArgs>): Prisma.PrismaPromise<GetTermDateAggregateType<T>>

    /**
     * Group by TermDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermDateGroupByArgs['orderBy'] }
        : { orderBy?: TermDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TermDate model
   */
  readonly fields: TermDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TermDate model
   */ 
  interface TermDateFieldRefs {
    readonly id: FieldRef<"TermDate", 'String'>
    readonly term: FieldRef<"TermDate", 'Int'>
    readonly termName: FieldRef<"TermDate", 'String'>
    readonly label: FieldRef<"TermDate", 'String'>
    readonly sublabel: FieldRef<"TermDate", 'String'>
    readonly date: FieldRef<"TermDate", 'DateTime'>
    readonly endDate: FieldRef<"TermDate", 'DateTime'>
    readonly type: FieldRef<"TermDate", 'String'>
    readonly color: FieldRef<"TermDate", 'String'>
    readonly schoolId: FieldRef<"TermDate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TermDate findUnique
   */
  export type TermDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate findUniqueOrThrow
   */
  export type TermDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate findFirst
   */
  export type TermDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermDates.
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermDates.
     */
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * TermDate findFirstOrThrow
   */
  export type TermDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermDates.
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermDates.
     */
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * TermDate findMany
   */
  export type TermDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDates to fetch.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TermDates.
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * TermDate create
   */
  export type TermDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * The data needed to create a TermDate.
     */
    data: XOR<TermDateCreateInput, TermDateUncheckedCreateInput>
  }

  /**
   * TermDate createMany
   */
  export type TermDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TermDates.
     */
    data: TermDateCreateManyInput | TermDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermDate createManyAndReturn
   */
  export type TermDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TermDates.
     */
    data: TermDateCreateManyInput | TermDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TermDate update
   */
  export type TermDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * The data needed to update a TermDate.
     */
    data: XOR<TermDateUpdateInput, TermDateUncheckedUpdateInput>
    /**
     * Choose, which TermDate to update.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate updateMany
   */
  export type TermDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TermDates.
     */
    data: XOR<TermDateUpdateManyMutationInput, TermDateUncheckedUpdateManyInput>
    /**
     * Filter which TermDates to update
     */
    where?: TermDateWhereInput
  }

  /**
   * TermDate upsert
   */
  export type TermDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * The filter to search for the TermDate to update in case it exists.
     */
    where: TermDateWhereUniqueInput
    /**
     * In case the TermDate found by the `where` argument doesn't exist, create a new TermDate with this data.
     */
    create: XOR<TermDateCreateInput, TermDateUncheckedCreateInput>
    /**
     * In case the TermDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermDateUpdateInput, TermDateUncheckedUpdateInput>
  }

  /**
   * TermDate delete
   */
  export type TermDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter which TermDate to delete.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate deleteMany
   */
  export type TermDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermDates to delete
     */
    where?: TermDateWhereInput
  }

  /**
   * TermDate without action
   */
  export type TermDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleItem
   */

  export type AggregateScheduleItem = {
    _count: ScheduleItemCountAggregateOutputType | null
    _avg: ScheduleItemAvgAggregateOutputType | null
    _sum: ScheduleItemSumAggregateOutputType | null
    _min: ScheduleItemMinAggregateOutputType | null
    _max: ScheduleItemMaxAggregateOutputType | null
  }

  export type ScheduleItemAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ScheduleItemSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ScheduleItemMinAggregateOutputType = {
    id: string | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    isRecurring: boolean | null
    dayOfWeek: number | null
    active: boolean | null
    date: Date | null
    type: string | null
    label: string | null
    description: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type ScheduleItemMaxAggregateOutputType = {
    id: string | null
    targetClass: string | null
    classId: string | null
    schoolId: string | null
    isRecurring: boolean | null
    dayOfWeek: number | null
    active: boolean | null
    date: Date | null
    type: string | null
    label: string | null
    description: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type ScheduleItemCountAggregateOutputType = {
    id: number
    targetClass: number
    classId: number
    schoolId: number
    isRecurring: number
    dayOfWeek: number
    active: number
    date: number
    type: number
    label: number
    description: number
    icon: number
    createdAt: number
    _all: number
  }


  export type ScheduleItemAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type ScheduleItemSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type ScheduleItemMinAggregateInputType = {
    id?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    isRecurring?: true
    dayOfWeek?: true
    active?: true
    date?: true
    type?: true
    label?: true
    description?: true
    icon?: true
    createdAt?: true
  }

  export type ScheduleItemMaxAggregateInputType = {
    id?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    isRecurring?: true
    dayOfWeek?: true
    active?: true
    date?: true
    type?: true
    label?: true
    description?: true
    icon?: true
    createdAt?: true
  }

  export type ScheduleItemCountAggregateInputType = {
    id?: true
    targetClass?: true
    classId?: true
    schoolId?: true
    isRecurring?: true
    dayOfWeek?: true
    active?: true
    date?: true
    type?: true
    label?: true
    description?: true
    icon?: true
    createdAt?: true
    _all?: true
  }

  export type ScheduleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleItem to aggregate.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleItems
    **/
    _count?: true | ScheduleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleItemMaxAggregateInputType
  }

  export type GetScheduleItemAggregateType<T extends ScheduleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleItem[P]>
      : GetScalarType<T[P], AggregateScheduleItem[P]>
  }




  export type ScheduleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithAggregationInput | ScheduleItemOrderByWithAggregationInput[]
    by: ScheduleItemScalarFieldEnum[] | ScheduleItemScalarFieldEnum
    having?: ScheduleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleItemCountAggregateInputType | true
    _avg?: ScheduleItemAvgAggregateInputType
    _sum?: ScheduleItemSumAggregateInputType
    _min?: ScheduleItemMinAggregateInputType
    _max?: ScheduleItemMaxAggregateInputType
  }

  export type ScheduleItemGroupByOutputType = {
    id: string
    targetClass: string
    classId: string | null
    schoolId: string
    isRecurring: boolean
    dayOfWeek: number | null
    active: boolean
    date: Date | null
    type: string
    label: string
    description: string | null
    icon: string | null
    createdAt: Date
    _count: ScheduleItemCountAggregateOutputType | null
    _avg: ScheduleItemAvgAggregateOutputType | null
    _sum: ScheduleItemSumAggregateOutputType | null
    _min: ScheduleItemMinAggregateOutputType | null
    _max: ScheduleItemMaxAggregateOutputType | null
  }

  type GetScheduleItemGroupByPayload<T extends ScheduleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleItemGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleItemGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    isRecurring?: boolean
    dayOfWeek?: boolean
    active?: boolean
    date?: boolean
    type?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleItem"]>

  export type ScheduleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    isRecurring?: boolean
    dayOfWeek?: boolean
    active?: boolean
    date?: boolean
    type?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleItem"]>

  export type ScheduleItemSelectScalar = {
    id?: boolean
    targetClass?: boolean
    classId?: boolean
    schoolId?: boolean
    isRecurring?: boolean
    dayOfWeek?: boolean
    active?: boolean
    date?: boolean
    type?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
  }

  export type ScheduleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type ScheduleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ScheduleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleItem"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetClass: string
      classId: string | null
      schoolId: string
      isRecurring: boolean
      dayOfWeek: number | null
      active: boolean
      date: Date | null
      type: string
      label: string
      description: string | null
      icon: string | null
      createdAt: Date
    }, ExtArgs["result"]["scheduleItem"]>
    composites: {}
  }

  type ScheduleItemGetPayload<S extends boolean | null | undefined | ScheduleItemDefaultArgs> = $Result.GetResult<Prisma.$ScheduleItemPayload, S>

  type ScheduleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduleItemCountAggregateInputType | true
    }

  export interface ScheduleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleItem'], meta: { name: 'ScheduleItem' } }
    /**
     * Find zero or one ScheduleItem that matches the filter.
     * @param {ScheduleItemFindUniqueArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleItemFindUniqueArgs>(args: SelectSubset<T, ScheduleItemFindUniqueArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduleItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduleItemFindUniqueOrThrowArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindFirstArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleItemFindFirstArgs>(args?: SelectSubset<T, ScheduleItemFindFirstArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindFirstOrThrowArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleItems
     * const scheduleItems = await prisma.scheduleItem.findMany()
     * 
     * // Get first 10 ScheduleItems
     * const scheduleItems = await prisma.scheduleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleItemWithIdOnly = await prisma.scheduleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleItemFindManyArgs>(args?: SelectSubset<T, ScheduleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduleItem.
     * @param {ScheduleItemCreateArgs} args - Arguments to create a ScheduleItem.
     * @example
     * // Create one ScheduleItem
     * const ScheduleItem = await prisma.scheduleItem.create({
     *   data: {
     *     // ... data to create a ScheduleItem
     *   }
     * })
     * 
     */
    create<T extends ScheduleItemCreateArgs>(args: SelectSubset<T, ScheduleItemCreateArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduleItems.
     * @param {ScheduleItemCreateManyArgs} args - Arguments to create many ScheduleItems.
     * @example
     * // Create many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleItemCreateManyArgs>(args?: SelectSubset<T, ScheduleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleItems and returns the data saved in the database.
     * @param {ScheduleItemCreateManyAndReturnArgs} args - Arguments to create many ScheduleItems.
     * @example
     * // Create many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleItems and only return the `id`
     * const scheduleItemWithIdOnly = await prisma.scheduleItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduleItem.
     * @param {ScheduleItemDeleteArgs} args - Arguments to delete one ScheduleItem.
     * @example
     * // Delete one ScheduleItem
     * const ScheduleItem = await prisma.scheduleItem.delete({
     *   where: {
     *     // ... filter to delete one ScheduleItem
     *   }
     * })
     * 
     */
    delete<T extends ScheduleItemDeleteArgs>(args: SelectSubset<T, ScheduleItemDeleteArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduleItem.
     * @param {ScheduleItemUpdateArgs} args - Arguments to update one ScheduleItem.
     * @example
     * // Update one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleItemUpdateArgs>(args: SelectSubset<T, ScheduleItemUpdateArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduleItems.
     * @param {ScheduleItemDeleteManyArgs} args - Arguments to filter ScheduleItems to delete.
     * @example
     * // Delete a few ScheduleItems
     * const { count } = await prisma.scheduleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleItemDeleteManyArgs>(args?: SelectSubset<T, ScheduleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleItemUpdateManyArgs>(args: SelectSubset<T, ScheduleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduleItem.
     * @param {ScheduleItemUpsertArgs} args - Arguments to update or create a ScheduleItem.
     * @example
     * // Update or create a ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.upsert({
     *   create: {
     *     // ... data to create a ScheduleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleItem we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleItemUpsertArgs>(args: SelectSubset<T, ScheduleItemUpsertArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemCountArgs} args - Arguments to filter ScheduleItems to count.
     * @example
     * // Count the number of ScheduleItems
     * const count = await prisma.scheduleItem.count({
     *   where: {
     *     // ... the filter for the ScheduleItems we want to count
     *   }
     * })
    **/
    count<T extends ScheduleItemCountArgs>(
      args?: Subset<T, ScheduleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleItemAggregateArgs>(args: Subset<T, ScheduleItemAggregateArgs>): Prisma.PrismaPromise<GetScheduleItemAggregateType<T>>

    /**
     * Group by ScheduleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleItemGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleItem model
   */
  readonly fields: ScheduleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ScheduleItem$classArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleItem$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleItem model
   */ 
  interface ScheduleItemFieldRefs {
    readonly id: FieldRef<"ScheduleItem", 'String'>
    readonly targetClass: FieldRef<"ScheduleItem", 'String'>
    readonly classId: FieldRef<"ScheduleItem", 'String'>
    readonly schoolId: FieldRef<"ScheduleItem", 'String'>
    readonly isRecurring: FieldRef<"ScheduleItem", 'Boolean'>
    readonly dayOfWeek: FieldRef<"ScheduleItem", 'Int'>
    readonly active: FieldRef<"ScheduleItem", 'Boolean'>
    readonly date: FieldRef<"ScheduleItem", 'DateTime'>
    readonly type: FieldRef<"ScheduleItem", 'String'>
    readonly label: FieldRef<"ScheduleItem", 'String'>
    readonly description: FieldRef<"ScheduleItem", 'String'>
    readonly icon: FieldRef<"ScheduleItem", 'String'>
    readonly createdAt: FieldRef<"ScheduleItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleItem findUnique
   */
  export type ScheduleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem findUniqueOrThrow
   */
  export type ScheduleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem findFirst
   */
  export type ScheduleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleItems.
     */
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem findFirstOrThrow
   */
  export type ScheduleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleItems.
     */
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem findMany
   */
  export type ScheduleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItems to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem create
   */
  export type ScheduleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleItem.
     */
    data: XOR<ScheduleItemCreateInput, ScheduleItemUncheckedCreateInput>
  }

  /**
   * ScheduleItem createMany
   */
  export type ScheduleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleItems.
     */
    data: ScheduleItemCreateManyInput | ScheduleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleItem createManyAndReturn
   */
  export type ScheduleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduleItems.
     */
    data: ScheduleItemCreateManyInput | ScheduleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleItem update
   */
  export type ScheduleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleItem.
     */
    data: XOR<ScheduleItemUpdateInput, ScheduleItemUncheckedUpdateInput>
    /**
     * Choose, which ScheduleItem to update.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem updateMany
   */
  export type ScheduleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleItems.
     */
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleItems to update
     */
    where?: ScheduleItemWhereInput
  }

  /**
   * ScheduleItem upsert
   */
  export type ScheduleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleItem to update in case it exists.
     */
    where: ScheduleItemWhereUniqueInput
    /**
     * In case the ScheduleItem found by the `where` argument doesn't exist, create a new ScheduleItem with this data.
     */
    create: XOR<ScheduleItemCreateInput, ScheduleItemUncheckedCreateInput>
    /**
     * In case the ScheduleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleItemUpdateInput, ScheduleItemUncheckedUpdateInput>
  }

  /**
   * ScheduleItem delete
   */
  export type ScheduleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter which ScheduleItem to delete.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem deleteMany
   */
  export type ScheduleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleItems to delete
     */
    where?: ScheduleItemWhereInput
  }

  /**
   * ScheduleItem.class
   */
  export type ScheduleItem$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * ScheduleItem without action
   */
  export type ScheduleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyMessage
   */

  export type AggregateWeeklyMessage = {
    _count: WeeklyMessageCountAggregateOutputType | null
    _min: WeeklyMessageMinAggregateOutputType | null
    _max: WeeklyMessageMaxAggregateOutputType | null
  }

  export type WeeklyMessageMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    weekOf: Date | null
    isCurrent: boolean | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    weekOf: Date | null
    isCurrent: boolean | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageCountAggregateOutputType = {
    id: number
    title: number
    content: number
    weekOf: number
    isCurrent: number
    schoolId: number
    createdAt: number
    _all: number
  }


  export type WeeklyMessageMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    weekOf?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
  }

  export type WeeklyMessageMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    weekOf?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
  }

  export type WeeklyMessageCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    weekOf?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
    _all?: true
  }

  export type WeeklyMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessage to aggregate.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyMessages
    **/
    _count?: true | WeeklyMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyMessageMaxAggregateInputType
  }

  export type GetWeeklyMessageAggregateType<T extends WeeklyMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyMessage[P]>
      : GetScalarType<T[P], AggregateWeeklyMessage[P]>
  }




  export type WeeklyMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageWhereInput
    orderBy?: WeeklyMessageOrderByWithAggregationInput | WeeklyMessageOrderByWithAggregationInput[]
    by: WeeklyMessageScalarFieldEnum[] | WeeklyMessageScalarFieldEnum
    having?: WeeklyMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyMessageCountAggregateInputType | true
    _min?: WeeklyMessageMinAggregateInputType
    _max?: WeeklyMessageMaxAggregateInputType
  }

  export type WeeklyMessageGroupByOutputType = {
    id: string
    title: string
    content: string
    weekOf: Date
    isCurrent: boolean
    schoolId: string
    createdAt: Date
    _count: WeeklyMessageCountAggregateOutputType | null
    _min: WeeklyMessageMinAggregateOutputType | null
    _max: WeeklyMessageMaxAggregateOutputType | null
  }

  type GetWeeklyMessageGroupByPayload<T extends WeeklyMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyMessageGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyMessageGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    weekOf?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    hearts?: boolean | WeeklyMessage$heartsArgs<ExtArgs>
    _count?: boolean | WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessage"]>

  export type WeeklyMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    weekOf?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessage"]>

  export type WeeklyMessageSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    weekOf?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
  }

  export type WeeklyMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    hearts?: boolean | WeeklyMessage$heartsArgs<ExtArgs>
    _count?: boolean | WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeeklyMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $WeeklyMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyMessage"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      hearts: Prisma.$WeeklyMessageHeartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      weekOf: Date
      isCurrent: boolean
      schoolId: string
      createdAt: Date
    }, ExtArgs["result"]["weeklyMessage"]>
    composites: {}
  }

  type WeeklyMessageGetPayload<S extends boolean | null | undefined | WeeklyMessageDefaultArgs> = $Result.GetResult<Prisma.$WeeklyMessagePayload, S>

  type WeeklyMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeeklyMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeeklyMessageCountAggregateInputType | true
    }

  export interface WeeklyMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyMessage'], meta: { name: 'WeeklyMessage' } }
    /**
     * Find zero or one WeeklyMessage that matches the filter.
     * @param {WeeklyMessageFindUniqueArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyMessageFindUniqueArgs>(args: SelectSubset<T, WeeklyMessageFindUniqueArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeeklyMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeeklyMessageFindUniqueOrThrowArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeeklyMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageFindFirstArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyMessageFindFirstArgs>(args?: SelectSubset<T, WeeklyMessageFindFirstArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeeklyMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageFindFirstOrThrowArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeeklyMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyMessages
     * const weeklyMessages = await prisma.weeklyMessage.findMany()
     * 
     * // Get first 10 WeeklyMessages
     * const weeklyMessages = await prisma.weeklyMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyMessageWithIdOnly = await prisma.weeklyMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyMessageFindManyArgs>(args?: SelectSubset<T, WeeklyMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeeklyMessage.
     * @param {WeeklyMessageCreateArgs} args - Arguments to create a WeeklyMessage.
     * @example
     * // Create one WeeklyMessage
     * const WeeklyMessage = await prisma.weeklyMessage.create({
     *   data: {
     *     // ... data to create a WeeklyMessage
     *   }
     * })
     * 
     */
    create<T extends WeeklyMessageCreateArgs>(args: SelectSubset<T, WeeklyMessageCreateArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeeklyMessages.
     * @param {WeeklyMessageCreateManyArgs} args - Arguments to create many WeeklyMessages.
     * @example
     * // Create many WeeklyMessages
     * const weeklyMessage = await prisma.weeklyMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyMessageCreateManyArgs>(args?: SelectSubset<T, WeeklyMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklyMessages and returns the data saved in the database.
     * @param {WeeklyMessageCreateManyAndReturnArgs} args - Arguments to create many WeeklyMessages.
     * @example
     * // Create many WeeklyMessages
     * const weeklyMessage = await prisma.weeklyMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklyMessages and only return the `id`
     * const weeklyMessageWithIdOnly = await prisma.weeklyMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeeklyMessage.
     * @param {WeeklyMessageDeleteArgs} args - Arguments to delete one WeeklyMessage.
     * @example
     * // Delete one WeeklyMessage
     * const WeeklyMessage = await prisma.weeklyMessage.delete({
     *   where: {
     *     // ... filter to delete one WeeklyMessage
     *   }
     * })
     * 
     */
    delete<T extends WeeklyMessageDeleteArgs>(args: SelectSubset<T, WeeklyMessageDeleteArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeeklyMessage.
     * @param {WeeklyMessageUpdateArgs} args - Arguments to update one WeeklyMessage.
     * @example
     * // Update one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyMessageUpdateArgs>(args: SelectSubset<T, WeeklyMessageUpdateArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeeklyMessages.
     * @param {WeeklyMessageDeleteManyArgs} args - Arguments to filter WeeklyMessages to delete.
     * @example
     * // Delete a few WeeklyMessages
     * const { count } = await prisma.weeklyMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyMessageDeleteManyArgs>(args?: SelectSubset<T, WeeklyMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyMessages
     * const weeklyMessage = await prisma.weeklyMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyMessageUpdateManyArgs>(args: SelectSubset<T, WeeklyMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeeklyMessage.
     * @param {WeeklyMessageUpsertArgs} args - Arguments to update or create a WeeklyMessage.
     * @example
     * // Update or create a WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.upsert({
     *   create: {
     *     // ... data to create a WeeklyMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyMessage we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyMessageUpsertArgs>(args: SelectSubset<T, WeeklyMessageUpsertArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeeklyMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageCountArgs} args - Arguments to filter WeeklyMessages to count.
     * @example
     * // Count the number of WeeklyMessages
     * const count = await prisma.weeklyMessage.count({
     *   where: {
     *     // ... the filter for the WeeklyMessages we want to count
     *   }
     * })
    **/
    count<T extends WeeklyMessageCountArgs>(
      args?: Subset<T, WeeklyMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyMessageAggregateArgs>(args: Subset<T, WeeklyMessageAggregateArgs>): Prisma.PrismaPromise<GetWeeklyMessageAggregateType<T>>

    /**
     * Group by WeeklyMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyMessageGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyMessage model
   */
  readonly fields: WeeklyMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hearts<T extends WeeklyMessage$heartsArgs<ExtArgs> = {}>(args?: Subset<T, WeeklyMessage$heartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyMessage model
   */ 
  interface WeeklyMessageFieldRefs {
    readonly id: FieldRef<"WeeklyMessage", 'String'>
    readonly title: FieldRef<"WeeklyMessage", 'String'>
    readonly content: FieldRef<"WeeklyMessage", 'String'>
    readonly weekOf: FieldRef<"WeeklyMessage", 'DateTime'>
    readonly isCurrent: FieldRef<"WeeklyMessage", 'Boolean'>
    readonly schoolId: FieldRef<"WeeklyMessage", 'String'>
    readonly createdAt: FieldRef<"WeeklyMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyMessage findUnique
   */
  export type WeeklyMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage findUniqueOrThrow
   */
  export type WeeklyMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage findFirst
   */
  export type WeeklyMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessages.
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessages.
     */
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * WeeklyMessage findFirstOrThrow
   */
  export type WeeklyMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessages.
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessages.
     */
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * WeeklyMessage findMany
   */
  export type WeeklyMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessages to fetch.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyMessages.
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * WeeklyMessage create
   */
  export type WeeklyMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyMessage.
     */
    data: XOR<WeeklyMessageCreateInput, WeeklyMessageUncheckedCreateInput>
  }

  /**
   * WeeklyMessage createMany
   */
  export type WeeklyMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyMessages.
     */
    data: WeeklyMessageCreateManyInput | WeeklyMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyMessage createManyAndReturn
   */
  export type WeeklyMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeeklyMessages.
     */
    data: WeeklyMessageCreateManyInput | WeeklyMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyMessage update
   */
  export type WeeklyMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyMessage.
     */
    data: XOR<WeeklyMessageUpdateInput, WeeklyMessageUncheckedUpdateInput>
    /**
     * Choose, which WeeklyMessage to update.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage updateMany
   */
  export type WeeklyMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyMessages.
     */
    data: XOR<WeeklyMessageUpdateManyMutationInput, WeeklyMessageUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyMessages to update
     */
    where?: WeeklyMessageWhereInput
  }

  /**
   * WeeklyMessage upsert
   */
  export type WeeklyMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyMessage to update in case it exists.
     */
    where: WeeklyMessageWhereUniqueInput
    /**
     * In case the WeeklyMessage found by the `where` argument doesn't exist, create a new WeeklyMessage with this data.
     */
    create: XOR<WeeklyMessageCreateInput, WeeklyMessageUncheckedCreateInput>
    /**
     * In case the WeeklyMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyMessageUpdateInput, WeeklyMessageUncheckedUpdateInput>
  }

  /**
   * WeeklyMessage delete
   */
  export type WeeklyMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter which WeeklyMessage to delete.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage deleteMany
   */
  export type WeeklyMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessages to delete
     */
    where?: WeeklyMessageWhereInput
  }

  /**
   * WeeklyMessage.hearts
   */
  export type WeeklyMessage$heartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    where?: WeeklyMessageHeartWhereInput
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    cursor?: WeeklyMessageHeartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessage without action
   */
  export type WeeklyMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyMessageHeart
   */

  export type AggregateWeeklyMessageHeart = {
    _count: WeeklyMessageHeartCountAggregateOutputType | null
    _min: WeeklyMessageHeartMinAggregateOutputType | null
    _max: WeeklyMessageHeartMaxAggregateOutputType | null
  }

  export type WeeklyMessageHeartMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageHeartMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageHeartCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type WeeklyMessageHeartMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type WeeklyMessageHeartMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type WeeklyMessageHeartCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type WeeklyMessageHeartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessageHeart to aggregate.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyMessageHearts
    **/
    _count?: true | WeeklyMessageHeartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyMessageHeartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyMessageHeartMaxAggregateInputType
  }

  export type GetWeeklyMessageHeartAggregateType<T extends WeeklyMessageHeartAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyMessageHeart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyMessageHeart[P]>
      : GetScalarType<T[P], AggregateWeeklyMessageHeart[P]>
  }




  export type WeeklyMessageHeartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageHeartWhereInput
    orderBy?: WeeklyMessageHeartOrderByWithAggregationInput | WeeklyMessageHeartOrderByWithAggregationInput[]
    by: WeeklyMessageHeartScalarFieldEnum[] | WeeklyMessageHeartScalarFieldEnum
    having?: WeeklyMessageHeartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyMessageHeartCountAggregateInputType | true
    _min?: WeeklyMessageHeartMinAggregateInputType
    _max?: WeeklyMessageHeartMaxAggregateInputType
  }

  export type WeeklyMessageHeartGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    createdAt: Date
    _count: WeeklyMessageHeartCountAggregateOutputType | null
    _min: WeeklyMessageHeartMinAggregateOutputType | null
    _max: WeeklyMessageHeartMaxAggregateOutputType | null
  }

  type GetWeeklyMessageHeartGroupByPayload<T extends WeeklyMessageHeartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyMessageHeartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyMessageHeartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyMessageHeartGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyMessageHeartGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyMessageHeartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessageHeart"]>

  export type WeeklyMessageHeartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessageHeart"]>

  export type WeeklyMessageHeartSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type WeeklyMessageHeartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WeeklyMessageHeartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WeeklyMessageHeartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyMessageHeart"
    objects: {
      message: Prisma.$WeeklyMessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["weeklyMessageHeart"]>
    composites: {}
  }

  type WeeklyMessageHeartGetPayload<S extends boolean | null | undefined | WeeklyMessageHeartDefaultArgs> = $Result.GetResult<Prisma.$WeeklyMessageHeartPayload, S>

  type WeeklyMessageHeartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeeklyMessageHeartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeeklyMessageHeartCountAggregateInputType | true
    }

  export interface WeeklyMessageHeartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyMessageHeart'], meta: { name: 'WeeklyMessageHeart' } }
    /**
     * Find zero or one WeeklyMessageHeart that matches the filter.
     * @param {WeeklyMessageHeartFindUniqueArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyMessageHeartFindUniqueArgs>(args: SelectSubset<T, WeeklyMessageHeartFindUniqueArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeeklyMessageHeart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeeklyMessageHeartFindUniqueOrThrowArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyMessageHeartFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyMessageHeartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeeklyMessageHeart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartFindFirstArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyMessageHeartFindFirstArgs>(args?: SelectSubset<T, WeeklyMessageHeartFindFirstArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeeklyMessageHeart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartFindFirstOrThrowArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyMessageHeartFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyMessageHeartFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeeklyMessageHearts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyMessageHearts
     * const weeklyMessageHearts = await prisma.weeklyMessageHeart.findMany()
     * 
     * // Get first 10 WeeklyMessageHearts
     * const weeklyMessageHearts = await prisma.weeklyMessageHeart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyMessageHeartWithIdOnly = await prisma.weeklyMessageHeart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyMessageHeartFindManyArgs>(args?: SelectSubset<T, WeeklyMessageHeartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeeklyMessageHeart.
     * @param {WeeklyMessageHeartCreateArgs} args - Arguments to create a WeeklyMessageHeart.
     * @example
     * // Create one WeeklyMessageHeart
     * const WeeklyMessageHeart = await prisma.weeklyMessageHeart.create({
     *   data: {
     *     // ... data to create a WeeklyMessageHeart
     *   }
     * })
     * 
     */
    create<T extends WeeklyMessageHeartCreateArgs>(args: SelectSubset<T, WeeklyMessageHeartCreateArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeeklyMessageHearts.
     * @param {WeeklyMessageHeartCreateManyArgs} args - Arguments to create many WeeklyMessageHearts.
     * @example
     * // Create many WeeklyMessageHearts
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyMessageHeartCreateManyArgs>(args?: SelectSubset<T, WeeklyMessageHeartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklyMessageHearts and returns the data saved in the database.
     * @param {WeeklyMessageHeartCreateManyAndReturnArgs} args - Arguments to create many WeeklyMessageHearts.
     * @example
     * // Create many WeeklyMessageHearts
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklyMessageHearts and only return the `id`
     * const weeklyMessageHeartWithIdOnly = await prisma.weeklyMessageHeart.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyMessageHeartCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyMessageHeartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeeklyMessageHeart.
     * @param {WeeklyMessageHeartDeleteArgs} args - Arguments to delete one WeeklyMessageHeart.
     * @example
     * // Delete one WeeklyMessageHeart
     * const WeeklyMessageHeart = await prisma.weeklyMessageHeart.delete({
     *   where: {
     *     // ... filter to delete one WeeklyMessageHeart
     *   }
     * })
     * 
     */
    delete<T extends WeeklyMessageHeartDeleteArgs>(args: SelectSubset<T, WeeklyMessageHeartDeleteArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeeklyMessageHeart.
     * @param {WeeklyMessageHeartUpdateArgs} args - Arguments to update one WeeklyMessageHeart.
     * @example
     * // Update one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyMessageHeartUpdateArgs>(args: SelectSubset<T, WeeklyMessageHeartUpdateArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeeklyMessageHearts.
     * @param {WeeklyMessageHeartDeleteManyArgs} args - Arguments to filter WeeklyMessageHearts to delete.
     * @example
     * // Delete a few WeeklyMessageHearts
     * const { count } = await prisma.weeklyMessageHeart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyMessageHeartDeleteManyArgs>(args?: SelectSubset<T, WeeklyMessageHeartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyMessageHearts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyMessageHearts
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyMessageHeartUpdateManyArgs>(args: SelectSubset<T, WeeklyMessageHeartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeeklyMessageHeart.
     * @param {WeeklyMessageHeartUpsertArgs} args - Arguments to update or create a WeeklyMessageHeart.
     * @example
     * // Update or create a WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.upsert({
     *   create: {
     *     // ... data to create a WeeklyMessageHeart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyMessageHeart we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyMessageHeartUpsertArgs>(args: SelectSubset<T, WeeklyMessageHeartUpsertArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeeklyMessageHearts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartCountArgs} args - Arguments to filter WeeklyMessageHearts to count.
     * @example
     * // Count the number of WeeklyMessageHearts
     * const count = await prisma.weeklyMessageHeart.count({
     *   where: {
     *     // ... the filter for the WeeklyMessageHearts we want to count
     *   }
     * })
    **/
    count<T extends WeeklyMessageHeartCountArgs>(
      args?: Subset<T, WeeklyMessageHeartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyMessageHeartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyMessageHeart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyMessageHeartAggregateArgs>(args: Subset<T, WeeklyMessageHeartAggregateArgs>): Prisma.PrismaPromise<GetWeeklyMessageHeartAggregateType<T>>

    /**
     * Group by WeeklyMessageHeart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyMessageHeartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyMessageHeartGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyMessageHeartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyMessageHeartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyMessageHeartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyMessageHeart model
   */
  readonly fields: WeeklyMessageHeartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyMessageHeart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyMessageHeartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends WeeklyMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeeklyMessageDefaultArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyMessageHeart model
   */ 
  interface WeeklyMessageHeartFieldRefs {
    readonly id: FieldRef<"WeeklyMessageHeart", 'String'>
    readonly messageId: FieldRef<"WeeklyMessageHeart", 'String'>
    readonly userId: FieldRef<"WeeklyMessageHeart", 'String'>
    readonly createdAt: FieldRef<"WeeklyMessageHeart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyMessageHeart findUnique
   */
  export type WeeklyMessageHeartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart findUniqueOrThrow
   */
  export type WeeklyMessageHeartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart findFirst
   */
  export type WeeklyMessageHeartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessageHearts.
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessageHearts.
     */
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessageHeart findFirstOrThrow
   */
  export type WeeklyMessageHeartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessageHearts.
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessageHearts.
     */
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessageHeart findMany
   */
  export type WeeklyMessageHeartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHearts to fetch.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyMessageHearts.
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessageHeart create
   */
  export type WeeklyMessageHeartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyMessageHeart.
     */
    data: XOR<WeeklyMessageHeartCreateInput, WeeklyMessageHeartUncheckedCreateInput>
  }

  /**
   * WeeklyMessageHeart createMany
   */
  export type WeeklyMessageHeartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyMessageHearts.
     */
    data: WeeklyMessageHeartCreateManyInput | WeeklyMessageHeartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyMessageHeart createManyAndReturn
   */
  export type WeeklyMessageHeartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeeklyMessageHearts.
     */
    data: WeeklyMessageHeartCreateManyInput | WeeklyMessageHeartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyMessageHeart update
   */
  export type WeeklyMessageHeartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyMessageHeart.
     */
    data: XOR<WeeklyMessageHeartUpdateInput, WeeklyMessageHeartUncheckedUpdateInput>
    /**
     * Choose, which WeeklyMessageHeart to update.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart updateMany
   */
  export type WeeklyMessageHeartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyMessageHearts.
     */
    data: XOR<WeeklyMessageHeartUpdateManyMutationInput, WeeklyMessageHeartUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyMessageHearts to update
     */
    where?: WeeklyMessageHeartWhereInput
  }

  /**
   * WeeklyMessageHeart upsert
   */
  export type WeeklyMessageHeartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyMessageHeart to update in case it exists.
     */
    where: WeeklyMessageHeartWhereUniqueInput
    /**
     * In case the WeeklyMessageHeart found by the `where` argument doesn't exist, create a new WeeklyMessageHeart with this data.
     */
    create: XOR<WeeklyMessageHeartCreateInput, WeeklyMessageHeartUncheckedCreateInput>
    /**
     * In case the WeeklyMessageHeart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyMessageHeartUpdateInput, WeeklyMessageHeartUncheckedUpdateInput>
  }

  /**
   * WeeklyMessageHeart delete
   */
  export type WeeklyMessageHeartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter which WeeklyMessageHeart to delete.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart deleteMany
   */
  export type WeeklyMessageHeartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessageHearts to delete
     */
    where?: WeeklyMessageHeartWhereInput
  }

  /**
   * WeeklyMessageHeart without action
   */
  export type WeeklyMessageHeartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeCategory
   */

  export type AggregateKnowledgeCategory = {
    _count: KnowledgeCategoryCountAggregateOutputType | null
    _avg: KnowledgeCategoryAvgAggregateOutputType | null
    _sum: KnowledgeCategorySumAggregateOutputType | null
    _min: KnowledgeCategoryMinAggregateOutputType | null
    _max: KnowledgeCategoryMaxAggregateOutputType | null
  }

  export type KnowledgeCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type KnowledgeCategorySumAggregateOutputType = {
    order: number | null
  }

  export type KnowledgeCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    order: number | null
    schoolId: string | null
  }

  export type KnowledgeCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    order: number | null
    schoolId: string | null
  }

  export type KnowledgeCategoryCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    color: number
    order: number
    schoolId: number
    _all: number
  }


  export type KnowledgeCategoryAvgAggregateInputType = {
    order?: true
  }

  export type KnowledgeCategorySumAggregateInputType = {
    order?: true
  }

  export type KnowledgeCategoryMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    order?: true
    schoolId?: true
  }

  export type KnowledgeCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    order?: true
    schoolId?: true
  }

  export type KnowledgeCategoryCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    order?: true
    schoolId?: true
    _all?: true
  }

  export type KnowledgeCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeCategory to aggregate.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeCategories
    **/
    _count?: true | KnowledgeCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeCategoryMaxAggregateInputType
  }

  export type GetKnowledgeCategoryAggregateType<T extends KnowledgeCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeCategory[P]>
      : GetScalarType<T[P], AggregateKnowledgeCategory[P]>
  }




  export type KnowledgeCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeCategoryWhereInput
    orderBy?: KnowledgeCategoryOrderByWithAggregationInput | KnowledgeCategoryOrderByWithAggregationInput[]
    by: KnowledgeCategoryScalarFieldEnum[] | KnowledgeCategoryScalarFieldEnum
    having?: KnowledgeCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeCategoryCountAggregateInputType | true
    _avg?: KnowledgeCategoryAvgAggregateInputType
    _sum?: KnowledgeCategorySumAggregateInputType
    _min?: KnowledgeCategoryMinAggregateInputType
    _max?: KnowledgeCategoryMaxAggregateInputType
  }

  export type KnowledgeCategoryGroupByOutputType = {
    id: string
    name: string
    icon: string
    color: string
    order: number
    schoolId: string
    _count: KnowledgeCategoryCountAggregateOutputType | null
    _avg: KnowledgeCategoryAvgAggregateOutputType | null
    _sum: KnowledgeCategorySumAggregateOutputType | null
    _min: KnowledgeCategoryMinAggregateOutputType | null
    _max: KnowledgeCategoryMaxAggregateOutputType | null
  }

  type GetKnowledgeCategoryGroupByPayload<T extends KnowledgeCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeCategoryGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    articles?: boolean | KnowledgeCategory$articlesArgs<ExtArgs>
    _count?: boolean | KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeCategory"]>

  export type KnowledgeCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeCategory"]>

  export type KnowledgeCategorySelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    schoolId?: boolean
  }

  export type KnowledgeCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    articles?: boolean | KnowledgeCategory$articlesArgs<ExtArgs>
    _count?: boolean | KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $KnowledgeCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeCategory"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      articles: Prisma.$KnowledgeArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      color: string
      order: number
      schoolId: string
    }, ExtArgs["result"]["knowledgeCategory"]>
    composites: {}
  }

  type KnowledgeCategoryGetPayload<S extends boolean | null | undefined | KnowledgeCategoryDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeCategoryPayload, S>

  type KnowledgeCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeCategoryCountAggregateInputType | true
    }

  export interface KnowledgeCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeCategory'], meta: { name: 'KnowledgeCategory' } }
    /**
     * Find zero or one KnowledgeCategory that matches the filter.
     * @param {KnowledgeCategoryFindUniqueArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeCategoryFindUniqueArgs>(args: SelectSubset<T, KnowledgeCategoryFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeCategoryFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryFindFirstArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeCategoryFindFirstArgs>(args?: SelectSubset<T, KnowledgeCategoryFindFirstArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryFindFirstOrThrowArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeCategories
     * const knowledgeCategories = await prisma.knowledgeCategory.findMany()
     * 
     * // Get first 10 KnowledgeCategories
     * const knowledgeCategories = await prisma.knowledgeCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeCategoryWithIdOnly = await prisma.knowledgeCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeCategoryFindManyArgs>(args?: SelectSubset<T, KnowledgeCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeCategory.
     * @param {KnowledgeCategoryCreateArgs} args - Arguments to create a KnowledgeCategory.
     * @example
     * // Create one KnowledgeCategory
     * const KnowledgeCategory = await prisma.knowledgeCategory.create({
     *   data: {
     *     // ... data to create a KnowledgeCategory
     *   }
     * })
     * 
     */
    create<T extends KnowledgeCategoryCreateArgs>(args: SelectSubset<T, KnowledgeCategoryCreateArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeCategories.
     * @param {KnowledgeCategoryCreateManyArgs} args - Arguments to create many KnowledgeCategories.
     * @example
     * // Create many KnowledgeCategories
     * const knowledgeCategory = await prisma.knowledgeCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeCategoryCreateManyArgs>(args?: SelectSubset<T, KnowledgeCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeCategories and returns the data saved in the database.
     * @param {KnowledgeCategoryCreateManyAndReturnArgs} args - Arguments to create many KnowledgeCategories.
     * @example
     * // Create many KnowledgeCategories
     * const knowledgeCategory = await prisma.knowledgeCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeCategories and only return the `id`
     * const knowledgeCategoryWithIdOnly = await prisma.knowledgeCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KnowledgeCategory.
     * @param {KnowledgeCategoryDeleteArgs} args - Arguments to delete one KnowledgeCategory.
     * @example
     * // Delete one KnowledgeCategory
     * const KnowledgeCategory = await prisma.knowledgeCategory.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeCategory
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeCategoryDeleteArgs>(args: SelectSubset<T, KnowledgeCategoryDeleteArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeCategory.
     * @param {KnowledgeCategoryUpdateArgs} args - Arguments to update one KnowledgeCategory.
     * @example
     * // Update one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeCategoryUpdateArgs>(args: SelectSubset<T, KnowledgeCategoryUpdateArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeCategories.
     * @param {KnowledgeCategoryDeleteManyArgs} args - Arguments to filter KnowledgeCategories to delete.
     * @example
     * // Delete a few KnowledgeCategories
     * const { count } = await prisma.knowledgeCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeCategoryDeleteManyArgs>(args?: SelectSubset<T, KnowledgeCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeCategories
     * const knowledgeCategory = await prisma.knowledgeCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeCategoryUpdateManyArgs>(args: SelectSubset<T, KnowledgeCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeCategory.
     * @param {KnowledgeCategoryUpsertArgs} args - Arguments to update or create a KnowledgeCategory.
     * @example
     * // Update or create a KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.upsert({
     *   create: {
     *     // ... data to create a KnowledgeCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeCategory we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeCategoryUpsertArgs>(args: SelectSubset<T, KnowledgeCategoryUpsertArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryCountArgs} args - Arguments to filter KnowledgeCategories to count.
     * @example
     * // Count the number of KnowledgeCategories
     * const count = await prisma.knowledgeCategory.count({
     *   where: {
     *     // ... the filter for the KnowledgeCategories we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeCategoryCountArgs>(
      args?: Subset<T, KnowledgeCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeCategoryAggregateArgs>(args: Subset<T, KnowledgeCategoryAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeCategoryAggregateType<T>>

    /**
     * Group by KnowledgeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeCategoryGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeCategory model
   */
  readonly fields: KnowledgeCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    articles<T extends KnowledgeCategory$articlesArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeCategory$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeCategory model
   */ 
  interface KnowledgeCategoryFieldRefs {
    readonly id: FieldRef<"KnowledgeCategory", 'String'>
    readonly name: FieldRef<"KnowledgeCategory", 'String'>
    readonly icon: FieldRef<"KnowledgeCategory", 'String'>
    readonly color: FieldRef<"KnowledgeCategory", 'String'>
    readonly order: FieldRef<"KnowledgeCategory", 'Int'>
    readonly schoolId: FieldRef<"KnowledgeCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeCategory findUnique
   */
  export type KnowledgeCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory findUniqueOrThrow
   */
  export type KnowledgeCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory findFirst
   */
  export type KnowledgeCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeCategories.
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeCategories.
     */
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory findFirstOrThrow
   */
  export type KnowledgeCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeCategories.
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeCategories.
     */
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory findMany
   */
  export type KnowledgeCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategories to fetch.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeCategories.
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory create
   */
  export type KnowledgeCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeCategory.
     */
    data: XOR<KnowledgeCategoryCreateInput, KnowledgeCategoryUncheckedCreateInput>
  }

  /**
   * KnowledgeCategory createMany
   */
  export type KnowledgeCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeCategories.
     */
    data: KnowledgeCategoryCreateManyInput | KnowledgeCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeCategory createManyAndReturn
   */
  export type KnowledgeCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KnowledgeCategories.
     */
    data: KnowledgeCategoryCreateManyInput | KnowledgeCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeCategory update
   */
  export type KnowledgeCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeCategory.
     */
    data: XOR<KnowledgeCategoryUpdateInput, KnowledgeCategoryUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeCategory to update.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory updateMany
   */
  export type KnowledgeCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeCategories.
     */
    data: XOR<KnowledgeCategoryUpdateManyMutationInput, KnowledgeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeCategories to update
     */
    where?: KnowledgeCategoryWhereInput
  }

  /**
   * KnowledgeCategory upsert
   */
  export type KnowledgeCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeCategory to update in case it exists.
     */
    where: KnowledgeCategoryWhereUniqueInput
    /**
     * In case the KnowledgeCategory found by the `where` argument doesn't exist, create a new KnowledgeCategory with this data.
     */
    create: XOR<KnowledgeCategoryCreateInput, KnowledgeCategoryUncheckedCreateInput>
    /**
     * In case the KnowledgeCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeCategoryUpdateInput, KnowledgeCategoryUncheckedUpdateInput>
  }

  /**
   * KnowledgeCategory delete
   */
  export type KnowledgeCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeCategory to delete.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory deleteMany
   */
  export type KnowledgeCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeCategories to delete
     */
    where?: KnowledgeCategoryWhereInput
  }

  /**
   * KnowledgeCategory.articles
   */
  export type KnowledgeCategory$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    where?: KnowledgeArticleWhereInput
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    cursor?: KnowledgeArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory without action
   */
  export type KnowledgeCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeArticle
   */

  export type AggregateKnowledgeArticle = {
    _count: KnowledgeArticleCountAggregateOutputType | null
    _min: KnowledgeArticleMinAggregateOutputType | null
    _max: KnowledgeArticleMaxAggregateOutputType | null
  }

  export type KnowledgeArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type KnowledgeArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type KnowledgeArticleCountAggregateOutputType = {
    id: number
    title: number
    content: number
    categoryId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type KnowledgeArticleMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type KnowledgeArticleMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type KnowledgeArticleCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type KnowledgeArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeArticle to aggregate.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeArticles
    **/
    _count?: true | KnowledgeArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeArticleMaxAggregateInputType
  }

  export type GetKnowledgeArticleAggregateType<T extends KnowledgeArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeArticle[P]>
      : GetScalarType<T[P], AggregateKnowledgeArticle[P]>
  }




  export type KnowledgeArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeArticleWhereInput
    orderBy?: KnowledgeArticleOrderByWithAggregationInput | KnowledgeArticleOrderByWithAggregationInput[]
    by: KnowledgeArticleScalarFieldEnum[] | KnowledgeArticleScalarFieldEnum
    having?: KnowledgeArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeArticleCountAggregateInputType | true
    _min?: KnowledgeArticleMinAggregateInputType
    _max?: KnowledgeArticleMaxAggregateInputType
  }

  export type KnowledgeArticleGroupByOutputType = {
    id: string
    title: string
    content: string
    categoryId: string
    updatedAt: Date
    createdAt: Date
    _count: KnowledgeArticleCountAggregateOutputType | null
    _min: KnowledgeArticleMinAggregateOutputType | null
    _max: KnowledgeArticleMaxAggregateOutputType | null
  }

  type GetKnowledgeArticleGroupByPayload<T extends KnowledgeArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeArticleGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeArticleGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeArticle"]>

  export type KnowledgeArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeArticle"]>

  export type KnowledgeArticleSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type KnowledgeArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }
  export type KnowledgeArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }

  export type $KnowledgeArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeArticle"
    objects: {
      category: Prisma.$KnowledgeCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      categoryId: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["knowledgeArticle"]>
    composites: {}
  }

  type KnowledgeArticleGetPayload<S extends boolean | null | undefined | KnowledgeArticleDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeArticlePayload, S>

  type KnowledgeArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeArticleCountAggregateInputType | true
    }

  export interface KnowledgeArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeArticle'], meta: { name: 'KnowledgeArticle' } }
    /**
     * Find zero or one KnowledgeArticle that matches the filter.
     * @param {KnowledgeArticleFindUniqueArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeArticleFindUniqueArgs>(args: SelectSubset<T, KnowledgeArticleFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeArticleFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindFirstArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeArticleFindFirstArgs>(args?: SelectSubset<T, KnowledgeArticleFindFirstArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindFirstOrThrowArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeArticles
     * const knowledgeArticles = await prisma.knowledgeArticle.findMany()
     * 
     * // Get first 10 KnowledgeArticles
     * const knowledgeArticles = await prisma.knowledgeArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeArticleWithIdOnly = await prisma.knowledgeArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeArticleFindManyArgs>(args?: SelectSubset<T, KnowledgeArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeArticle.
     * @param {KnowledgeArticleCreateArgs} args - Arguments to create a KnowledgeArticle.
     * @example
     * // Create one KnowledgeArticle
     * const KnowledgeArticle = await prisma.knowledgeArticle.create({
     *   data: {
     *     // ... data to create a KnowledgeArticle
     *   }
     * })
     * 
     */
    create<T extends KnowledgeArticleCreateArgs>(args: SelectSubset<T, KnowledgeArticleCreateArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeArticles.
     * @param {KnowledgeArticleCreateManyArgs} args - Arguments to create many KnowledgeArticles.
     * @example
     * // Create many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeArticleCreateManyArgs>(args?: SelectSubset<T, KnowledgeArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeArticles and returns the data saved in the database.
     * @param {KnowledgeArticleCreateManyAndReturnArgs} args - Arguments to create many KnowledgeArticles.
     * @example
     * // Create many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeArticles and only return the `id`
     * const knowledgeArticleWithIdOnly = await prisma.knowledgeArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KnowledgeArticle.
     * @param {KnowledgeArticleDeleteArgs} args - Arguments to delete one KnowledgeArticle.
     * @example
     * // Delete one KnowledgeArticle
     * const KnowledgeArticle = await prisma.knowledgeArticle.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeArticle
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeArticleDeleteArgs>(args: SelectSubset<T, KnowledgeArticleDeleteArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeArticle.
     * @param {KnowledgeArticleUpdateArgs} args - Arguments to update one KnowledgeArticle.
     * @example
     * // Update one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeArticleUpdateArgs>(args: SelectSubset<T, KnowledgeArticleUpdateArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeArticles.
     * @param {KnowledgeArticleDeleteManyArgs} args - Arguments to filter KnowledgeArticles to delete.
     * @example
     * // Delete a few KnowledgeArticles
     * const { count } = await prisma.knowledgeArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeArticleDeleteManyArgs>(args?: SelectSubset<T, KnowledgeArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeArticleUpdateManyArgs>(args: SelectSubset<T, KnowledgeArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeArticle.
     * @param {KnowledgeArticleUpsertArgs} args - Arguments to update or create a KnowledgeArticle.
     * @example
     * // Update or create a KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.upsert({
     *   create: {
     *     // ... data to create a KnowledgeArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeArticle we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeArticleUpsertArgs>(args: SelectSubset<T, KnowledgeArticleUpsertArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleCountArgs} args - Arguments to filter KnowledgeArticles to count.
     * @example
     * // Count the number of KnowledgeArticles
     * const count = await prisma.knowledgeArticle.count({
     *   where: {
     *     // ... the filter for the KnowledgeArticles we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeArticleCountArgs>(
      args?: Subset<T, KnowledgeArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeArticleAggregateArgs>(args: Subset<T, KnowledgeArticleAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeArticleAggregateType<T>>

    /**
     * Group by KnowledgeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeArticleGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeArticle model
   */
  readonly fields: KnowledgeArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends KnowledgeCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeCategoryDefaultArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeArticle model
   */ 
  interface KnowledgeArticleFieldRefs {
    readonly id: FieldRef<"KnowledgeArticle", 'String'>
    readonly title: FieldRef<"KnowledgeArticle", 'String'>
    readonly content: FieldRef<"KnowledgeArticle", 'String'>
    readonly categoryId: FieldRef<"KnowledgeArticle", 'String'>
    readonly updatedAt: FieldRef<"KnowledgeArticle", 'DateTime'>
    readonly createdAt: FieldRef<"KnowledgeArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeArticle findUnique
   */
  export type KnowledgeArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle findUniqueOrThrow
   */
  export type KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle findFirst
   */
  export type KnowledgeArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeArticles.
     */
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle findFirstOrThrow
   */
  export type KnowledgeArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeArticles.
     */
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle findMany
   */
  export type KnowledgeArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticles to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle create
   */
  export type KnowledgeArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeArticle.
     */
    data: XOR<KnowledgeArticleCreateInput, KnowledgeArticleUncheckedCreateInput>
  }

  /**
   * KnowledgeArticle createMany
   */
  export type KnowledgeArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeArticles.
     */
    data: KnowledgeArticleCreateManyInput | KnowledgeArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeArticle createManyAndReturn
   */
  export type KnowledgeArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KnowledgeArticles.
     */
    data: KnowledgeArticleCreateManyInput | KnowledgeArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeArticle update
   */
  export type KnowledgeArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeArticle.
     */
    data: XOR<KnowledgeArticleUpdateInput, KnowledgeArticleUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeArticle to update.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle updateMany
   */
  export type KnowledgeArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeArticles.
     */
    data: XOR<KnowledgeArticleUpdateManyMutationInput, KnowledgeArticleUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeArticles to update
     */
    where?: KnowledgeArticleWhereInput
  }

  /**
   * KnowledgeArticle upsert
   */
  export type KnowledgeArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeArticle to update in case it exists.
     */
    where: KnowledgeArticleWhereUniqueInput
    /**
     * In case the KnowledgeArticle found by the `where` argument doesn't exist, create a new KnowledgeArticle with this data.
     */
    create: XOR<KnowledgeArticleCreateInput, KnowledgeArticleUncheckedCreateInput>
    /**
     * In case the KnowledgeArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeArticleUpdateInput, KnowledgeArticleUncheckedUpdateInput>
  }

  /**
   * KnowledgeArticle delete
   */
  export type KnowledgeArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeArticle to delete.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle deleteMany
   */
  export type KnowledgeArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeArticles to delete
     */
    where?: KnowledgeArticleWhereInput
  }

  /**
   * KnowledgeArticle without action
   */
  export type KnowledgeArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
  }


  /**
   * Model PulseSurvey
   */

  export type AggregatePulseSurvey = {
    _count: PulseSurveyCountAggregateOutputType | null
    _min: PulseSurveyMinAggregateOutputType | null
    _max: PulseSurveyMaxAggregateOutputType | null
  }

  export type PulseSurveyMinAggregateOutputType = {
    id: string | null
    halfTermName: string | null
    status: string | null
    opensAt: Date | null
    closesAt: Date | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type PulseSurveyMaxAggregateOutputType = {
    id: string | null
    halfTermName: string | null
    status: string | null
    opensAt: Date | null
    closesAt: Date | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type PulseSurveyCountAggregateOutputType = {
    id: number
    halfTermName: number
    status: number
    opensAt: number
    closesAt: number
    schoolId: number
    createdAt: number
    _all: number
  }


  export type PulseSurveyMinAggregateInputType = {
    id?: true
    halfTermName?: true
    status?: true
    opensAt?: true
    closesAt?: true
    schoolId?: true
    createdAt?: true
  }

  export type PulseSurveyMaxAggregateInputType = {
    id?: true
    halfTermName?: true
    status?: true
    opensAt?: true
    closesAt?: true
    schoolId?: true
    createdAt?: true
  }

  export type PulseSurveyCountAggregateInputType = {
    id?: true
    halfTermName?: true
    status?: true
    opensAt?: true
    closesAt?: true
    schoolId?: true
    createdAt?: true
    _all?: true
  }

  export type PulseSurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseSurvey to aggregate.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PulseSurveys
    **/
    _count?: true | PulseSurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PulseSurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PulseSurveyMaxAggregateInputType
  }

  export type GetPulseSurveyAggregateType<T extends PulseSurveyAggregateArgs> = {
        [P in keyof T & keyof AggregatePulseSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePulseSurvey[P]>
      : GetScalarType<T[P], AggregatePulseSurvey[P]>
  }




  export type PulseSurveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseSurveyWhereInput
    orderBy?: PulseSurveyOrderByWithAggregationInput | PulseSurveyOrderByWithAggregationInput[]
    by: PulseSurveyScalarFieldEnum[] | PulseSurveyScalarFieldEnum
    having?: PulseSurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PulseSurveyCountAggregateInputType | true
    _min?: PulseSurveyMinAggregateInputType
    _max?: PulseSurveyMaxAggregateInputType
  }

  export type PulseSurveyGroupByOutputType = {
    id: string
    halfTermName: string
    status: string
    opensAt: Date
    closesAt: Date
    schoolId: string
    createdAt: Date
    _count: PulseSurveyCountAggregateOutputType | null
    _min: PulseSurveyMinAggregateOutputType | null
    _max: PulseSurveyMaxAggregateOutputType | null
  }

  type GetPulseSurveyGroupByPayload<T extends PulseSurveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PulseSurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PulseSurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PulseSurveyGroupByOutputType[P]>
            : GetScalarType<T[P], PulseSurveyGroupByOutputType[P]>
        }
      >
    >


  export type PulseSurveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    halfTermName?: boolean
    status?: boolean
    opensAt?: boolean
    closesAt?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    responses?: boolean | PulseSurvey$responsesArgs<ExtArgs>
    _count?: boolean | PulseSurveyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseSurvey"]>

  export type PulseSurveySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    halfTermName?: boolean
    status?: boolean
    opensAt?: boolean
    closesAt?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseSurvey"]>

  export type PulseSurveySelectScalar = {
    id?: boolean
    halfTermName?: boolean
    status?: boolean
    opensAt?: boolean
    closesAt?: boolean
    schoolId?: boolean
    createdAt?: boolean
  }

  export type PulseSurveyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    responses?: boolean | PulseSurvey$responsesArgs<ExtArgs>
    _count?: boolean | PulseSurveyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PulseSurveyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $PulseSurveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PulseSurvey"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      responses: Prisma.$PulseResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      halfTermName: string
      status: string
      opensAt: Date
      closesAt: Date
      schoolId: string
      createdAt: Date
    }, ExtArgs["result"]["pulseSurvey"]>
    composites: {}
  }

  type PulseSurveyGetPayload<S extends boolean | null | undefined | PulseSurveyDefaultArgs> = $Result.GetResult<Prisma.$PulseSurveyPayload, S>

  type PulseSurveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PulseSurveyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PulseSurveyCountAggregateInputType | true
    }

  export interface PulseSurveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PulseSurvey'], meta: { name: 'PulseSurvey' } }
    /**
     * Find zero or one PulseSurvey that matches the filter.
     * @param {PulseSurveyFindUniqueArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PulseSurveyFindUniqueArgs>(args: SelectSubset<T, PulseSurveyFindUniqueArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PulseSurvey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PulseSurveyFindUniqueOrThrowArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PulseSurveyFindUniqueOrThrowArgs>(args: SelectSubset<T, PulseSurveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PulseSurvey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyFindFirstArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PulseSurveyFindFirstArgs>(args?: SelectSubset<T, PulseSurveyFindFirstArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PulseSurvey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyFindFirstOrThrowArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PulseSurveyFindFirstOrThrowArgs>(args?: SelectSubset<T, PulseSurveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PulseSurveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PulseSurveys
     * const pulseSurveys = await prisma.pulseSurvey.findMany()
     * 
     * // Get first 10 PulseSurveys
     * const pulseSurveys = await prisma.pulseSurvey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pulseSurveyWithIdOnly = await prisma.pulseSurvey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PulseSurveyFindManyArgs>(args?: SelectSubset<T, PulseSurveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PulseSurvey.
     * @param {PulseSurveyCreateArgs} args - Arguments to create a PulseSurvey.
     * @example
     * // Create one PulseSurvey
     * const PulseSurvey = await prisma.pulseSurvey.create({
     *   data: {
     *     // ... data to create a PulseSurvey
     *   }
     * })
     * 
     */
    create<T extends PulseSurveyCreateArgs>(args: SelectSubset<T, PulseSurveyCreateArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PulseSurveys.
     * @param {PulseSurveyCreateManyArgs} args - Arguments to create many PulseSurveys.
     * @example
     * // Create many PulseSurveys
     * const pulseSurvey = await prisma.pulseSurvey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PulseSurveyCreateManyArgs>(args?: SelectSubset<T, PulseSurveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PulseSurveys and returns the data saved in the database.
     * @param {PulseSurveyCreateManyAndReturnArgs} args - Arguments to create many PulseSurveys.
     * @example
     * // Create many PulseSurveys
     * const pulseSurvey = await prisma.pulseSurvey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PulseSurveys and only return the `id`
     * const pulseSurveyWithIdOnly = await prisma.pulseSurvey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PulseSurveyCreateManyAndReturnArgs>(args?: SelectSubset<T, PulseSurveyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PulseSurvey.
     * @param {PulseSurveyDeleteArgs} args - Arguments to delete one PulseSurvey.
     * @example
     * // Delete one PulseSurvey
     * const PulseSurvey = await prisma.pulseSurvey.delete({
     *   where: {
     *     // ... filter to delete one PulseSurvey
     *   }
     * })
     * 
     */
    delete<T extends PulseSurveyDeleteArgs>(args: SelectSubset<T, PulseSurveyDeleteArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PulseSurvey.
     * @param {PulseSurveyUpdateArgs} args - Arguments to update one PulseSurvey.
     * @example
     * // Update one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PulseSurveyUpdateArgs>(args: SelectSubset<T, PulseSurveyUpdateArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PulseSurveys.
     * @param {PulseSurveyDeleteManyArgs} args - Arguments to filter PulseSurveys to delete.
     * @example
     * // Delete a few PulseSurveys
     * const { count } = await prisma.pulseSurvey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PulseSurveyDeleteManyArgs>(args?: SelectSubset<T, PulseSurveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PulseSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PulseSurveys
     * const pulseSurvey = await prisma.pulseSurvey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PulseSurveyUpdateManyArgs>(args: SelectSubset<T, PulseSurveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PulseSurvey.
     * @param {PulseSurveyUpsertArgs} args - Arguments to update or create a PulseSurvey.
     * @example
     * // Update or create a PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.upsert({
     *   create: {
     *     // ... data to create a PulseSurvey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PulseSurvey we want to update
     *   }
     * })
     */
    upsert<T extends PulseSurveyUpsertArgs>(args: SelectSubset<T, PulseSurveyUpsertArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PulseSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyCountArgs} args - Arguments to filter PulseSurveys to count.
     * @example
     * // Count the number of PulseSurveys
     * const count = await prisma.pulseSurvey.count({
     *   where: {
     *     // ... the filter for the PulseSurveys we want to count
     *   }
     * })
    **/
    count<T extends PulseSurveyCountArgs>(
      args?: Subset<T, PulseSurveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PulseSurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PulseSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PulseSurveyAggregateArgs>(args: Subset<T, PulseSurveyAggregateArgs>): Prisma.PrismaPromise<GetPulseSurveyAggregateType<T>>

    /**
     * Group by PulseSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PulseSurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PulseSurveyGroupByArgs['orderBy'] }
        : { orderBy?: PulseSurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PulseSurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPulseSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PulseSurvey model
   */
  readonly fields: PulseSurveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PulseSurvey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PulseSurveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responses<T extends PulseSurvey$responsesArgs<ExtArgs> = {}>(args?: Subset<T, PulseSurvey$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PulseSurvey model
   */ 
  interface PulseSurveyFieldRefs {
    readonly id: FieldRef<"PulseSurvey", 'String'>
    readonly halfTermName: FieldRef<"PulseSurvey", 'String'>
    readonly status: FieldRef<"PulseSurvey", 'String'>
    readonly opensAt: FieldRef<"PulseSurvey", 'DateTime'>
    readonly closesAt: FieldRef<"PulseSurvey", 'DateTime'>
    readonly schoolId: FieldRef<"PulseSurvey", 'String'>
    readonly createdAt: FieldRef<"PulseSurvey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PulseSurvey findUnique
   */
  export type PulseSurveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey findUniqueOrThrow
   */
  export type PulseSurveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey findFirst
   */
  export type PulseSurveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseSurveys.
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseSurveys.
     */
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * PulseSurvey findFirstOrThrow
   */
  export type PulseSurveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseSurveys.
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseSurveys.
     */
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * PulseSurvey findMany
   */
  export type PulseSurveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurveys to fetch.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PulseSurveys.
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * PulseSurvey create
   */
  export type PulseSurveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * The data needed to create a PulseSurvey.
     */
    data: XOR<PulseSurveyCreateInput, PulseSurveyUncheckedCreateInput>
  }

  /**
   * PulseSurvey createMany
   */
  export type PulseSurveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PulseSurveys.
     */
    data: PulseSurveyCreateManyInput | PulseSurveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PulseSurvey createManyAndReturn
   */
  export type PulseSurveyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PulseSurveys.
     */
    data: PulseSurveyCreateManyInput | PulseSurveyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PulseSurvey update
   */
  export type PulseSurveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * The data needed to update a PulseSurvey.
     */
    data: XOR<PulseSurveyUpdateInput, PulseSurveyUncheckedUpdateInput>
    /**
     * Choose, which PulseSurvey to update.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey updateMany
   */
  export type PulseSurveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PulseSurveys.
     */
    data: XOR<PulseSurveyUpdateManyMutationInput, PulseSurveyUncheckedUpdateManyInput>
    /**
     * Filter which PulseSurveys to update
     */
    where?: PulseSurveyWhereInput
  }

  /**
   * PulseSurvey upsert
   */
  export type PulseSurveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * The filter to search for the PulseSurvey to update in case it exists.
     */
    where: PulseSurveyWhereUniqueInput
    /**
     * In case the PulseSurvey found by the `where` argument doesn't exist, create a new PulseSurvey with this data.
     */
    create: XOR<PulseSurveyCreateInput, PulseSurveyUncheckedCreateInput>
    /**
     * In case the PulseSurvey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PulseSurveyUpdateInput, PulseSurveyUncheckedUpdateInput>
  }

  /**
   * PulseSurvey delete
   */
  export type PulseSurveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter which PulseSurvey to delete.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey deleteMany
   */
  export type PulseSurveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseSurveys to delete
     */
    where?: PulseSurveyWhereInput
  }

  /**
   * PulseSurvey.responses
   */
  export type PulseSurvey$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    where?: PulseResponseWhereInput
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    cursor?: PulseResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseSurvey without action
   */
  export type PulseSurveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
  }


  /**
   * Model PulseResponse
   */

  export type AggregatePulseResponse = {
    _count: PulseResponseCountAggregateOutputType | null
    _min: PulseResponseMinAggregateOutputType | null
    _max: PulseResponseMaxAggregateOutputType | null
  }

  export type PulseResponseMinAggregateOutputType = {
    id: string | null
    pulseId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PulseResponseMaxAggregateOutputType = {
    id: string | null
    pulseId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PulseResponseCountAggregateOutputType = {
    id: number
    pulseId: number
    userId: number
    answers: number
    createdAt: number
    _all: number
  }


  export type PulseResponseMinAggregateInputType = {
    id?: true
    pulseId?: true
    userId?: true
    createdAt?: true
  }

  export type PulseResponseMaxAggregateInputType = {
    id?: true
    pulseId?: true
    userId?: true
    createdAt?: true
  }

  export type PulseResponseCountAggregateInputType = {
    id?: true
    pulseId?: true
    userId?: true
    answers?: true
    createdAt?: true
    _all?: true
  }

  export type PulseResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseResponse to aggregate.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PulseResponses
    **/
    _count?: true | PulseResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PulseResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PulseResponseMaxAggregateInputType
  }

  export type GetPulseResponseAggregateType<T extends PulseResponseAggregateArgs> = {
        [P in keyof T & keyof AggregatePulseResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePulseResponse[P]>
      : GetScalarType<T[P], AggregatePulseResponse[P]>
  }




  export type PulseResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseResponseWhereInput
    orderBy?: PulseResponseOrderByWithAggregationInput | PulseResponseOrderByWithAggregationInput[]
    by: PulseResponseScalarFieldEnum[] | PulseResponseScalarFieldEnum
    having?: PulseResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PulseResponseCountAggregateInputType | true
    _min?: PulseResponseMinAggregateInputType
    _max?: PulseResponseMaxAggregateInputType
  }

  export type PulseResponseGroupByOutputType = {
    id: string
    pulseId: string
    userId: string
    answers: JsonValue
    createdAt: Date
    _count: PulseResponseCountAggregateOutputType | null
    _min: PulseResponseMinAggregateOutputType | null
    _max: PulseResponseMaxAggregateOutputType | null
  }

  type GetPulseResponseGroupByPayload<T extends PulseResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PulseResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PulseResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PulseResponseGroupByOutputType[P]>
            : GetScalarType<T[P], PulseResponseGroupByOutputType[P]>
        }
      >
    >


  export type PulseResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pulseId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseResponse"]>

  export type PulseResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pulseId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseResponse"]>

  export type PulseResponseSelectScalar = {
    id?: boolean
    pulseId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
  }

  export type PulseResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PulseResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PulseResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PulseResponse"
    objects: {
      pulse: Prisma.$PulseSurveyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pulseId: string
      userId: string
      answers: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["pulseResponse"]>
    composites: {}
  }

  type PulseResponseGetPayload<S extends boolean | null | undefined | PulseResponseDefaultArgs> = $Result.GetResult<Prisma.$PulseResponsePayload, S>

  type PulseResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PulseResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PulseResponseCountAggregateInputType | true
    }

  export interface PulseResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PulseResponse'], meta: { name: 'PulseResponse' } }
    /**
     * Find zero or one PulseResponse that matches the filter.
     * @param {PulseResponseFindUniqueArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PulseResponseFindUniqueArgs>(args: SelectSubset<T, PulseResponseFindUniqueArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PulseResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PulseResponseFindUniqueOrThrowArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PulseResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, PulseResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PulseResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseFindFirstArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PulseResponseFindFirstArgs>(args?: SelectSubset<T, PulseResponseFindFirstArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PulseResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseFindFirstOrThrowArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PulseResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, PulseResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PulseResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PulseResponses
     * const pulseResponses = await prisma.pulseResponse.findMany()
     * 
     * // Get first 10 PulseResponses
     * const pulseResponses = await prisma.pulseResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pulseResponseWithIdOnly = await prisma.pulseResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PulseResponseFindManyArgs>(args?: SelectSubset<T, PulseResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PulseResponse.
     * @param {PulseResponseCreateArgs} args - Arguments to create a PulseResponse.
     * @example
     * // Create one PulseResponse
     * const PulseResponse = await prisma.pulseResponse.create({
     *   data: {
     *     // ... data to create a PulseResponse
     *   }
     * })
     * 
     */
    create<T extends PulseResponseCreateArgs>(args: SelectSubset<T, PulseResponseCreateArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PulseResponses.
     * @param {PulseResponseCreateManyArgs} args - Arguments to create many PulseResponses.
     * @example
     * // Create many PulseResponses
     * const pulseResponse = await prisma.pulseResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PulseResponseCreateManyArgs>(args?: SelectSubset<T, PulseResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PulseResponses and returns the data saved in the database.
     * @param {PulseResponseCreateManyAndReturnArgs} args - Arguments to create many PulseResponses.
     * @example
     * // Create many PulseResponses
     * const pulseResponse = await prisma.pulseResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PulseResponses and only return the `id`
     * const pulseResponseWithIdOnly = await prisma.pulseResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PulseResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, PulseResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PulseResponse.
     * @param {PulseResponseDeleteArgs} args - Arguments to delete one PulseResponse.
     * @example
     * // Delete one PulseResponse
     * const PulseResponse = await prisma.pulseResponse.delete({
     *   where: {
     *     // ... filter to delete one PulseResponse
     *   }
     * })
     * 
     */
    delete<T extends PulseResponseDeleteArgs>(args: SelectSubset<T, PulseResponseDeleteArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PulseResponse.
     * @param {PulseResponseUpdateArgs} args - Arguments to update one PulseResponse.
     * @example
     * // Update one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PulseResponseUpdateArgs>(args: SelectSubset<T, PulseResponseUpdateArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PulseResponses.
     * @param {PulseResponseDeleteManyArgs} args - Arguments to filter PulseResponses to delete.
     * @example
     * // Delete a few PulseResponses
     * const { count } = await prisma.pulseResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PulseResponseDeleteManyArgs>(args?: SelectSubset<T, PulseResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PulseResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PulseResponses
     * const pulseResponse = await prisma.pulseResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PulseResponseUpdateManyArgs>(args: SelectSubset<T, PulseResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PulseResponse.
     * @param {PulseResponseUpsertArgs} args - Arguments to update or create a PulseResponse.
     * @example
     * // Update or create a PulseResponse
     * const pulseResponse = await prisma.pulseResponse.upsert({
     *   create: {
     *     // ... data to create a PulseResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PulseResponse we want to update
     *   }
     * })
     */
    upsert<T extends PulseResponseUpsertArgs>(args: SelectSubset<T, PulseResponseUpsertArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PulseResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseCountArgs} args - Arguments to filter PulseResponses to count.
     * @example
     * // Count the number of PulseResponses
     * const count = await prisma.pulseResponse.count({
     *   where: {
     *     // ... the filter for the PulseResponses we want to count
     *   }
     * })
    **/
    count<T extends PulseResponseCountArgs>(
      args?: Subset<T, PulseResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PulseResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PulseResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PulseResponseAggregateArgs>(args: Subset<T, PulseResponseAggregateArgs>): Prisma.PrismaPromise<GetPulseResponseAggregateType<T>>

    /**
     * Group by PulseResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PulseResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PulseResponseGroupByArgs['orderBy'] }
        : { orderBy?: PulseResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PulseResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPulseResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PulseResponse model
   */
  readonly fields: PulseResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PulseResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PulseResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pulse<T extends PulseSurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PulseSurveyDefaultArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PulseResponse model
   */ 
  interface PulseResponseFieldRefs {
    readonly id: FieldRef<"PulseResponse", 'String'>
    readonly pulseId: FieldRef<"PulseResponse", 'String'>
    readonly userId: FieldRef<"PulseResponse", 'String'>
    readonly answers: FieldRef<"PulseResponse", 'Json'>
    readonly createdAt: FieldRef<"PulseResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PulseResponse findUnique
   */
  export type PulseResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse findUniqueOrThrow
   */
  export type PulseResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse findFirst
   */
  export type PulseResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseResponses.
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseResponses.
     */
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseResponse findFirstOrThrow
   */
  export type PulseResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseResponses.
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseResponses.
     */
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseResponse findMany
   */
  export type PulseResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponses to fetch.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PulseResponses.
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseResponse create
   */
  export type PulseResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a PulseResponse.
     */
    data: XOR<PulseResponseCreateInput, PulseResponseUncheckedCreateInput>
  }

  /**
   * PulseResponse createMany
   */
  export type PulseResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PulseResponses.
     */
    data: PulseResponseCreateManyInput | PulseResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PulseResponse createManyAndReturn
   */
  export type PulseResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PulseResponses.
     */
    data: PulseResponseCreateManyInput | PulseResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PulseResponse update
   */
  export type PulseResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a PulseResponse.
     */
    data: XOR<PulseResponseUpdateInput, PulseResponseUncheckedUpdateInput>
    /**
     * Choose, which PulseResponse to update.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse updateMany
   */
  export type PulseResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PulseResponses.
     */
    data: XOR<PulseResponseUpdateManyMutationInput, PulseResponseUncheckedUpdateManyInput>
    /**
     * Filter which PulseResponses to update
     */
    where?: PulseResponseWhereInput
  }

  /**
   * PulseResponse upsert
   */
  export type PulseResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the PulseResponse to update in case it exists.
     */
    where: PulseResponseWhereUniqueInput
    /**
     * In case the PulseResponse found by the `where` argument doesn't exist, create a new PulseResponse with this data.
     */
    create: XOR<PulseResponseCreateInput, PulseResponseUncheckedCreateInput>
    /**
     * In case the PulseResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PulseResponseUpdateInput, PulseResponseUncheckedUpdateInput>
  }

  /**
   * PulseResponse delete
   */
  export type PulseResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter which PulseResponse to delete.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse deleteMany
   */
  export type PulseResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseResponses to delete
     */
    where?: PulseResponseWhereInput
  }

  /**
   * PulseResponse without action
   */
  export type PulseResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type PolicySumAggregateOutputType = {
    fileSize: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fileUrl: string | null
    fileSize: number | null
    schoolId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fileUrl: string | null
    fileSize: number | null
    schoolId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fileUrl: number
    fileSize: number
    schoolId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    fileSize?: true
  }

  export type PolicySumAggregateInputType = {
    fileSize?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileSize?: true
    schoolId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileSize?: true
    schoolId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileSize?: true
    schoolId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    fileUrl: string
    fileSize: number | null
    schoolId: string
    updatedAt: Date
    createdAt: Date
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    schoolId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    schoolId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    schoolId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type PolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type PolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      fileUrl: string
      fileSize: number | null
      schoolId: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policies and returns the data saved in the database.
     * @param {PolicyCreateManyAndReturnArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */ 
  interface PolicyFieldRefs {
    readonly id: FieldRef<"Policy", 'String'>
    readonly name: FieldRef<"Policy", 'String'>
    readonly description: FieldRef<"Policy", 'String'>
    readonly fileUrl: FieldRef<"Policy", 'String'>
    readonly fileSize: FieldRef<"Policy", 'Int'>
    readonly schoolId: FieldRef<"Policy", 'String'>
    readonly updatedAt: FieldRef<"Policy", 'DateTime'>
    readonly createdAt: FieldRef<"Policy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy createManyAndReturn
   */
  export type PolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
  }


  /**
   * Model FileFolder
   */

  export type AggregateFileFolder = {
    _count: FileFolderCountAggregateOutputType | null
    _avg: FileFolderAvgAggregateOutputType | null
    _sum: FileFolderSumAggregateOutputType | null
    _min: FileFolderMinAggregateOutputType | null
    _max: FileFolderMaxAggregateOutputType | null
  }

  export type FileFolderAvgAggregateOutputType = {
    order: number | null
  }

  export type FileFolderSumAggregateOutputType = {
    order: number | null
  }

  export type FileFolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    schoolId: string | null
    order: number | null
    createdAt: Date | null
  }

  export type FileFolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    schoolId: string | null
    order: number | null
    createdAt: Date | null
  }

  export type FileFolderCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    color: number
    parentId: number
    schoolId: number
    order: number
    createdAt: number
    _all: number
  }


  export type FileFolderAvgAggregateInputType = {
    order?: true
  }

  export type FileFolderSumAggregateInputType = {
    order?: true
  }

  export type FileFolderMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    parentId?: true
    schoolId?: true
    order?: true
    createdAt?: true
  }

  export type FileFolderMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    parentId?: true
    schoolId?: true
    order?: true
    createdAt?: true
  }

  export type FileFolderCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    parentId?: true
    schoolId?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type FileFolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileFolder to aggregate.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileFolders
    **/
    _count?: true | FileFolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileFolderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileFolderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileFolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileFolderMaxAggregateInputType
  }

  export type GetFileFolderAggregateType<T extends FileFolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFileFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileFolder[P]>
      : GetScalarType<T[P], AggregateFileFolder[P]>
  }




  export type FileFolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithAggregationInput | FileFolderOrderByWithAggregationInput[]
    by: FileFolderScalarFieldEnum[] | FileFolderScalarFieldEnum
    having?: FileFolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileFolderCountAggregateInputType | true
    _avg?: FileFolderAvgAggregateInputType
    _sum?: FileFolderSumAggregateInputType
    _min?: FileFolderMinAggregateInputType
    _max?: FileFolderMaxAggregateInputType
  }

  export type FileFolderGroupByOutputType = {
    id: string
    name: string
    icon: string | null
    color: string | null
    parentId: string | null
    schoolId: string
    order: number
    createdAt: Date
    _count: FileFolderCountAggregateOutputType | null
    _avg: FileFolderAvgAggregateOutputType | null
    _sum: FileFolderSumAggregateOutputType | null
    _min: FileFolderMinAggregateOutputType | null
    _max: FileFolderMaxAggregateOutputType | null
  }

  type GetFileFolderGroupByPayload<T extends FileFolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileFolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileFolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileFolderGroupByOutputType[P]>
            : GetScalarType<T[P], FileFolderGroupByOutputType[P]>
        }
      >
    >


  export type FileFolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    schoolId?: boolean
    order?: boolean
    createdAt?: boolean
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    children?: boolean | FileFolder$childrenArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    files?: boolean | FileFolder$filesArgs<ExtArgs>
    _count?: boolean | FileFolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileFolder"]>

  export type FileFolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    schoolId?: boolean
    order?: boolean
    createdAt?: boolean
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileFolder"]>

  export type FileFolderSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    schoolId?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type FileFolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    children?: boolean | FileFolder$childrenArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    files?: boolean | FileFolder$filesArgs<ExtArgs>
    _count?: boolean | FileFolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileFolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $FileFolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileFolder"
    objects: {
      parent: Prisma.$FileFolderPayload<ExtArgs> | null
      children: Prisma.$FileFolderPayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs>
      files: Prisma.$SchoolFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string | null
      color: string | null
      parentId: string | null
      schoolId: string
      order: number
      createdAt: Date
    }, ExtArgs["result"]["fileFolder"]>
    composites: {}
  }

  type FileFolderGetPayload<S extends boolean | null | undefined | FileFolderDefaultArgs> = $Result.GetResult<Prisma.$FileFolderPayload, S>

  type FileFolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileFolderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileFolderCountAggregateInputType | true
    }

  export interface FileFolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileFolder'], meta: { name: 'FileFolder' } }
    /**
     * Find zero or one FileFolder that matches the filter.
     * @param {FileFolderFindUniqueArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFolderFindUniqueArgs>(args: SelectSubset<T, FileFolderFindUniqueArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FileFolder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileFolderFindUniqueOrThrowArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FileFolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindFirstArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFolderFindFirstArgs>(args?: SelectSubset<T, FileFolderFindFirstArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FileFolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindFirstOrThrowArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FileFolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileFolders
     * const fileFolders = await prisma.fileFolder.findMany()
     * 
     * // Get first 10 FileFolders
     * const fileFolders = await prisma.fileFolder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileFolderWithIdOnly = await prisma.fileFolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFolderFindManyArgs>(args?: SelectSubset<T, FileFolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FileFolder.
     * @param {FileFolderCreateArgs} args - Arguments to create a FileFolder.
     * @example
     * // Create one FileFolder
     * const FileFolder = await prisma.fileFolder.create({
     *   data: {
     *     // ... data to create a FileFolder
     *   }
     * })
     * 
     */
    create<T extends FileFolderCreateArgs>(args: SelectSubset<T, FileFolderCreateArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FileFolders.
     * @param {FileFolderCreateManyArgs} args - Arguments to create many FileFolders.
     * @example
     * // Create many FileFolders
     * const fileFolder = await prisma.fileFolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileFolderCreateManyArgs>(args?: SelectSubset<T, FileFolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileFolders and returns the data saved in the database.
     * @param {FileFolderCreateManyAndReturnArgs} args - Arguments to create many FileFolders.
     * @example
     * // Create many FileFolders
     * const fileFolder = await prisma.fileFolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileFolders and only return the `id`
     * const fileFolderWithIdOnly = await prisma.fileFolder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileFolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FileFolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FileFolder.
     * @param {FileFolderDeleteArgs} args - Arguments to delete one FileFolder.
     * @example
     * // Delete one FileFolder
     * const FileFolder = await prisma.fileFolder.delete({
     *   where: {
     *     // ... filter to delete one FileFolder
     *   }
     * })
     * 
     */
    delete<T extends FileFolderDeleteArgs>(args: SelectSubset<T, FileFolderDeleteArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FileFolder.
     * @param {FileFolderUpdateArgs} args - Arguments to update one FileFolder.
     * @example
     * // Update one FileFolder
     * const fileFolder = await prisma.fileFolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileFolderUpdateArgs>(args: SelectSubset<T, FileFolderUpdateArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FileFolders.
     * @param {FileFolderDeleteManyArgs} args - Arguments to filter FileFolders to delete.
     * @example
     * // Delete a few FileFolders
     * const { count } = await prisma.fileFolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileFolderDeleteManyArgs>(args?: SelectSubset<T, FileFolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileFolders
     * const fileFolder = await prisma.fileFolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileFolderUpdateManyArgs>(args: SelectSubset<T, FileFolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileFolder.
     * @param {FileFolderUpsertArgs} args - Arguments to update or create a FileFolder.
     * @example
     * // Update or create a FileFolder
     * const fileFolder = await prisma.fileFolder.upsert({
     *   create: {
     *     // ... data to create a FileFolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileFolder we want to update
     *   }
     * })
     */
    upsert<T extends FileFolderUpsertArgs>(args: SelectSubset<T, FileFolderUpsertArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FileFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderCountArgs} args - Arguments to filter FileFolders to count.
     * @example
     * // Count the number of FileFolders
     * const count = await prisma.fileFolder.count({
     *   where: {
     *     // ... the filter for the FileFolders we want to count
     *   }
     * })
    **/
    count<T extends FileFolderCountArgs>(
      args?: Subset<T, FileFolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileFolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileFolderAggregateArgs>(args: Subset<T, FileFolderAggregateArgs>): Prisma.PrismaPromise<GetFileFolderAggregateType<T>>

    /**
     * Group by FileFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileFolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileFolderGroupByArgs['orderBy'] }
        : { orderBy?: FileFolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileFolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileFolder model
   */
  readonly fields: FileFolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileFolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileFolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends FileFolder$parentArgs<ExtArgs> = {}>(args?: Subset<T, FileFolder$parentArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends FileFolder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, FileFolder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany"> | Null>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    files<T extends FileFolder$filesArgs<ExtArgs> = {}>(args?: Subset<T, FileFolder$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileFolder model
   */ 
  interface FileFolderFieldRefs {
    readonly id: FieldRef<"FileFolder", 'String'>
    readonly name: FieldRef<"FileFolder", 'String'>
    readonly icon: FieldRef<"FileFolder", 'String'>
    readonly color: FieldRef<"FileFolder", 'String'>
    readonly parentId: FieldRef<"FileFolder", 'String'>
    readonly schoolId: FieldRef<"FileFolder", 'String'>
    readonly order: FieldRef<"FileFolder", 'Int'>
    readonly createdAt: FieldRef<"FileFolder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileFolder findUnique
   */
  export type FileFolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder findUniqueOrThrow
   */
  export type FileFolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder findFirst
   */
  export type FileFolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileFolders.
     */
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder findFirstOrThrow
   */
  export type FileFolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileFolders.
     */
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder findMany
   */
  export type FileFolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolders to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder create
   */
  export type FileFolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The data needed to create a FileFolder.
     */
    data: XOR<FileFolderCreateInput, FileFolderUncheckedCreateInput>
  }

  /**
   * FileFolder createMany
   */
  export type FileFolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileFolders.
     */
    data: FileFolderCreateManyInput | FileFolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileFolder createManyAndReturn
   */
  export type FileFolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FileFolders.
     */
    data: FileFolderCreateManyInput | FileFolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileFolder update
   */
  export type FileFolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The data needed to update a FileFolder.
     */
    data: XOR<FileFolderUpdateInput, FileFolderUncheckedUpdateInput>
    /**
     * Choose, which FileFolder to update.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder updateMany
   */
  export type FileFolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileFolders.
     */
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyInput>
    /**
     * Filter which FileFolders to update
     */
    where?: FileFolderWhereInput
  }

  /**
   * FileFolder upsert
   */
  export type FileFolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The filter to search for the FileFolder to update in case it exists.
     */
    where: FileFolderWhereUniqueInput
    /**
     * In case the FileFolder found by the `where` argument doesn't exist, create a new FileFolder with this data.
     */
    create: XOR<FileFolderCreateInput, FileFolderUncheckedCreateInput>
    /**
     * In case the FileFolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileFolderUpdateInput, FileFolderUncheckedUpdateInput>
  }

  /**
   * FileFolder delete
   */
  export type FileFolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter which FileFolder to delete.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder deleteMany
   */
  export type FileFolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileFolders to delete
     */
    where?: FileFolderWhereInput
  }

  /**
   * FileFolder.parent
   */
  export type FileFolder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
  }

  /**
   * FileFolder.children
   */
  export type FileFolder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    cursor?: FileFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder.files
   */
  export type FileFolder$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    where?: SchoolFileWhereInput
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    cursor?: SchoolFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * FileFolder without action
   */
  export type FileFolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
  }


  /**
   * Model SchoolFile
   */

  export type AggregateSchoolFile = {
    _count: SchoolFileCountAggregateOutputType | null
    _avg: SchoolFileAvgAggregateOutputType | null
    _sum: SchoolFileSumAggregateOutputType | null
    _min: SchoolFileMinAggregateOutputType | null
    _max: SchoolFileMaxAggregateOutputType | null
  }

  export type SchoolFileAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type SchoolFileSumAggregateOutputType = {
    fileSize: number | null
  }

  export type SchoolFileMinAggregateOutputType = {
    id: string | null
    name: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    folderId: string | null
    schoolId: string | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolFileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    folderId: string | null
    schoolId: string | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolFileCountAggregateOutputType = {
    id: number
    name: number
    fileName: number
    fileUrl: number
    fileType: number
    fileSize: number
    folderId: number
    schoolId: number
    uploadedAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolFileAvgAggregateInputType = {
    fileSize?: true
  }

  export type SchoolFileSumAggregateInputType = {
    fileSize?: true
  }

  export type SchoolFileMinAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    folderId?: true
    schoolId?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type SchoolFileMaxAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    folderId?: true
    schoolId?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type SchoolFileCountAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    folderId?: true
    schoolId?: true
    uploadedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolFile to aggregate.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolFiles
    **/
    _count?: true | SchoolFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolFileMaxAggregateInputType
  }

  export type GetSchoolFileAggregateType<T extends SchoolFileAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolFile[P]>
      : GetScalarType<T[P], AggregateSchoolFile[P]>
  }




  export type SchoolFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolFileWhereInput
    orderBy?: SchoolFileOrderByWithAggregationInput | SchoolFileOrderByWithAggregationInput[]
    by: SchoolFileScalarFieldEnum[] | SchoolFileScalarFieldEnum
    having?: SchoolFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolFileCountAggregateInputType | true
    _avg?: SchoolFileAvgAggregateInputType
    _sum?: SchoolFileSumAggregateInputType
    _min?: SchoolFileMinAggregateInputType
    _max?: SchoolFileMaxAggregateInputType
  }

  export type SchoolFileGroupByOutputType = {
    id: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId: string | null
    schoolId: string
    uploadedAt: Date
    updatedAt: Date
    _count: SchoolFileCountAggregateOutputType | null
    _avg: SchoolFileAvgAggregateOutputType | null
    _sum: SchoolFileSumAggregateOutputType | null
    _min: SchoolFileMinAggregateOutputType | null
    _max: SchoolFileMaxAggregateOutputType | null
  }

  type GetSchoolFileGroupByPayload<T extends SchoolFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolFileGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolFileGroupByOutputType[P]>
        }
      >
    >


  export type SchoolFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    folderId?: boolean
    schoolId?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolFile"]>

  export type SchoolFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    folderId?: boolean
    schoolId?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolFile"]>

  export type SchoolFileSelectScalar = {
    id?: boolean
    name?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    folderId?: boolean
    schoolId?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolFile"
    objects: {
      folder: Prisma.$FileFolderPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      fileName: string
      fileUrl: string
      fileType: string
      fileSize: number
      folderId: string | null
      schoolId: string
      uploadedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolFile"]>
    composites: {}
  }

  type SchoolFileGetPayload<S extends boolean | null | undefined | SchoolFileDefaultArgs> = $Result.GetResult<Prisma.$SchoolFilePayload, S>

  type SchoolFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolFileCountAggregateInputType | true
    }

  export interface SchoolFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolFile'], meta: { name: 'SchoolFile' } }
    /**
     * Find zero or one SchoolFile that matches the filter.
     * @param {SchoolFileFindUniqueArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFileFindUniqueArgs>(args: SelectSubset<T, SchoolFileFindUniqueArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolFileFindUniqueOrThrowArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFileFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileFindFirstArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFileFindFirstArgs>(args?: SelectSubset<T, SchoolFileFindFirstArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileFindFirstOrThrowArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFileFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolFiles
     * const schoolFiles = await prisma.schoolFile.findMany()
     * 
     * // Get first 10 SchoolFiles
     * const schoolFiles = await prisma.schoolFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolFileWithIdOnly = await prisma.schoolFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFileFindManyArgs>(args?: SelectSubset<T, SchoolFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolFile.
     * @param {SchoolFileCreateArgs} args - Arguments to create a SchoolFile.
     * @example
     * // Create one SchoolFile
     * const SchoolFile = await prisma.schoolFile.create({
     *   data: {
     *     // ... data to create a SchoolFile
     *   }
     * })
     * 
     */
    create<T extends SchoolFileCreateArgs>(args: SelectSubset<T, SchoolFileCreateArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolFiles.
     * @param {SchoolFileCreateManyArgs} args - Arguments to create many SchoolFiles.
     * @example
     * // Create many SchoolFiles
     * const schoolFile = await prisma.schoolFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolFileCreateManyArgs>(args?: SelectSubset<T, SchoolFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolFiles and returns the data saved in the database.
     * @param {SchoolFileCreateManyAndReturnArgs} args - Arguments to create many SchoolFiles.
     * @example
     * // Create many SchoolFiles
     * const schoolFile = await prisma.schoolFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolFiles and only return the `id`
     * const schoolFileWithIdOnly = await prisma.schoolFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolFileCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolFile.
     * @param {SchoolFileDeleteArgs} args - Arguments to delete one SchoolFile.
     * @example
     * // Delete one SchoolFile
     * const SchoolFile = await prisma.schoolFile.delete({
     *   where: {
     *     // ... filter to delete one SchoolFile
     *   }
     * })
     * 
     */
    delete<T extends SchoolFileDeleteArgs>(args: SelectSubset<T, SchoolFileDeleteArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolFile.
     * @param {SchoolFileUpdateArgs} args - Arguments to update one SchoolFile.
     * @example
     * // Update one SchoolFile
     * const schoolFile = await prisma.schoolFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolFileUpdateArgs>(args: SelectSubset<T, SchoolFileUpdateArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolFiles.
     * @param {SchoolFileDeleteManyArgs} args - Arguments to filter SchoolFiles to delete.
     * @example
     * // Delete a few SchoolFiles
     * const { count } = await prisma.schoolFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolFileDeleteManyArgs>(args?: SelectSubset<T, SchoolFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolFiles
     * const schoolFile = await prisma.schoolFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolFileUpdateManyArgs>(args: SelectSubset<T, SchoolFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolFile.
     * @param {SchoolFileUpsertArgs} args - Arguments to update or create a SchoolFile.
     * @example
     * // Update or create a SchoolFile
     * const schoolFile = await prisma.schoolFile.upsert({
     *   create: {
     *     // ... data to create a SchoolFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolFile we want to update
     *   }
     * })
     */
    upsert<T extends SchoolFileUpsertArgs>(args: SelectSubset<T, SchoolFileUpsertArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileCountArgs} args - Arguments to filter SchoolFiles to count.
     * @example
     * // Count the number of SchoolFiles
     * const count = await prisma.schoolFile.count({
     *   where: {
     *     // ... the filter for the SchoolFiles we want to count
     *   }
     * })
    **/
    count<T extends SchoolFileCountArgs>(
      args?: Subset<T, SchoolFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolFileAggregateArgs>(args: Subset<T, SchoolFileAggregateArgs>): Prisma.PrismaPromise<GetSchoolFileAggregateType<T>>

    /**
     * Group by SchoolFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolFileGroupByArgs['orderBy'] }
        : { orderBy?: SchoolFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolFile model
   */
  readonly fields: SchoolFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    folder<T extends SchoolFile$folderArgs<ExtArgs> = {}>(args?: Subset<T, SchoolFile$folderArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolFile model
   */ 
  interface SchoolFileFieldRefs {
    readonly id: FieldRef<"SchoolFile", 'String'>
    readonly name: FieldRef<"SchoolFile", 'String'>
    readonly fileName: FieldRef<"SchoolFile", 'String'>
    readonly fileUrl: FieldRef<"SchoolFile", 'String'>
    readonly fileType: FieldRef<"SchoolFile", 'String'>
    readonly fileSize: FieldRef<"SchoolFile", 'Int'>
    readonly folderId: FieldRef<"SchoolFile", 'String'>
    readonly schoolId: FieldRef<"SchoolFile", 'String'>
    readonly uploadedAt: FieldRef<"SchoolFile", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolFile findUnique
   */
  export type SchoolFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile findUniqueOrThrow
   */
  export type SchoolFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile findFirst
   */
  export type SchoolFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolFiles.
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolFiles.
     */
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * SchoolFile findFirstOrThrow
   */
  export type SchoolFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolFiles.
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolFiles.
     */
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * SchoolFile findMany
   */
  export type SchoolFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFiles to fetch.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolFiles.
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * SchoolFile create
   */
  export type SchoolFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolFile.
     */
    data: XOR<SchoolFileCreateInput, SchoolFileUncheckedCreateInput>
  }

  /**
   * SchoolFile createMany
   */
  export type SchoolFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolFiles.
     */
    data: SchoolFileCreateManyInput | SchoolFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolFile createManyAndReturn
   */
  export type SchoolFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolFiles.
     */
    data: SchoolFileCreateManyInput | SchoolFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolFile update
   */
  export type SchoolFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolFile.
     */
    data: XOR<SchoolFileUpdateInput, SchoolFileUncheckedUpdateInput>
    /**
     * Choose, which SchoolFile to update.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile updateMany
   */
  export type SchoolFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolFiles.
     */
    data: XOR<SchoolFileUpdateManyMutationInput, SchoolFileUncheckedUpdateManyInput>
    /**
     * Filter which SchoolFiles to update
     */
    where?: SchoolFileWhereInput
  }

  /**
   * SchoolFile upsert
   */
  export type SchoolFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolFile to update in case it exists.
     */
    where: SchoolFileWhereUniqueInput
    /**
     * In case the SchoolFile found by the `where` argument doesn't exist, create a new SchoolFile with this data.
     */
    create: XOR<SchoolFileCreateInput, SchoolFileUncheckedCreateInput>
    /**
     * In case the SchoolFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolFileUpdateInput, SchoolFileUncheckedUpdateInput>
  }

  /**
   * SchoolFile delete
   */
  export type SchoolFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter which SchoolFile to delete.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile deleteMany
   */
  export type SchoolFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolFiles to delete
     */
    where?: SchoolFileWhereInput
  }

  /**
   * SchoolFile.folder
   */
  export type SchoolFile$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
  }

  /**
   * SchoolFile without action
   */
  export type SchoolFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    city: 'city',
    academicYear: 'academicYear',
    brandColor: 'brandColor',
    accentColor: 'accentColor',
    tagline: 'tagline',
    logoUrl: 'logoUrl',
    logoIconUrl: 'logoIconUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    schoolId: 'schoolId',
    googleId: 'googleId',
    microsoftId: 'microsoftId',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ChildScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    classId: 'classId'
  };

  export type ChildScalarFieldEnum = (typeof ChildScalarFieldEnum)[keyof typeof ChildScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    colorBg: 'colorBg',
    colorText: 'colorText',
    schoolId: 'schoolId'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    targetClass: 'targetClass',
    classId: 'classId',
    schoolId: 'schoolId',
    senderId: 'senderId',
    senderName: 'senderName',
    actionType: 'actionType',
    actionLabel: 'actionLabel',
    actionDueDate: 'actionDueDate',
    actionAmount: 'actionAmount',
    isPinned: 'isPinned',
    isUrgent: 'isUrgent',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageAcknowledgmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type MessageAcknowledgmentScalarFieldEnum = (typeof MessageAcknowledgmentScalarFieldEnum)[keyof typeof MessageAcknowledgmentScalarFieldEnum]


  export const SurveyScalarFieldEnum: {
    id: 'id',
    question: 'question',
    options: 'options',
    active: 'active',
    targetClass: 'targetClass',
    classId: 'classId',
    schoolId: 'schoolId',
    createdAt: 'createdAt'
  };

  export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


  export const SurveyResponseScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    userId: 'userId',
    response: 'response',
    createdAt: 'createdAt'
  };

  export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time',
    location: 'location',
    targetClass: 'targetClass',
    classId: 'classId',
    schoolId: 'schoolId',
    requiresRsvp: 'requiresRsvp',
    createdAt: 'createdAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventRsvpScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type EventRsvpScalarFieldEnum = (typeof EventRsvpScalarFieldEnum)[keyof typeof EventRsvpScalarFieldEnum]


  export const TermDateScalarFieldEnum: {
    id: 'id',
    term: 'term',
    termName: 'termName',
    label: 'label',
    sublabel: 'sublabel',
    date: 'date',
    endDate: 'endDate',
    type: 'type',
    color: 'color',
    schoolId: 'schoolId'
  };

  export type TermDateScalarFieldEnum = (typeof TermDateScalarFieldEnum)[keyof typeof TermDateScalarFieldEnum]


  export const ScheduleItemScalarFieldEnum: {
    id: 'id',
    targetClass: 'targetClass',
    classId: 'classId',
    schoolId: 'schoolId',
    isRecurring: 'isRecurring',
    dayOfWeek: 'dayOfWeek',
    active: 'active',
    date: 'date',
    type: 'type',
    label: 'label',
    description: 'description',
    icon: 'icon',
    createdAt: 'createdAt'
  };

  export type ScheduleItemScalarFieldEnum = (typeof ScheduleItemScalarFieldEnum)[keyof typeof ScheduleItemScalarFieldEnum]


  export const WeeklyMessageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    weekOf: 'weekOf',
    isCurrent: 'isCurrent',
    schoolId: 'schoolId',
    createdAt: 'createdAt'
  };

  export type WeeklyMessageScalarFieldEnum = (typeof WeeklyMessageScalarFieldEnum)[keyof typeof WeeklyMessageScalarFieldEnum]


  export const WeeklyMessageHeartScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type WeeklyMessageHeartScalarFieldEnum = (typeof WeeklyMessageHeartScalarFieldEnum)[keyof typeof WeeklyMessageHeartScalarFieldEnum]


  export const KnowledgeCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    color: 'color',
    order: 'order',
    schoolId: 'schoolId'
  };

  export type KnowledgeCategoryScalarFieldEnum = (typeof KnowledgeCategoryScalarFieldEnum)[keyof typeof KnowledgeCategoryScalarFieldEnum]


  export const KnowledgeArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    categoryId: 'categoryId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type KnowledgeArticleScalarFieldEnum = (typeof KnowledgeArticleScalarFieldEnum)[keyof typeof KnowledgeArticleScalarFieldEnum]


  export const PulseSurveyScalarFieldEnum: {
    id: 'id',
    halfTermName: 'halfTermName',
    status: 'status',
    opensAt: 'opensAt',
    closesAt: 'closesAt',
    schoolId: 'schoolId',
    createdAt: 'createdAt'
  };

  export type PulseSurveyScalarFieldEnum = (typeof PulseSurveyScalarFieldEnum)[keyof typeof PulseSurveyScalarFieldEnum]


  export const PulseResponseScalarFieldEnum: {
    id: 'id',
    pulseId: 'pulseId',
    userId: 'userId',
    answers: 'answers',
    createdAt: 'createdAt'
  };

  export type PulseResponseScalarFieldEnum = (typeof PulseResponseScalarFieldEnum)[keyof typeof PulseResponseScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fileUrl: 'fileUrl',
    fileSize: 'fileSize',
    schoolId: 'schoolId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const FileFolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    color: 'color',
    parentId: 'parentId',
    schoolId: 'schoolId',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type FileFolderScalarFieldEnum = (typeof FileFolderScalarFieldEnum)[keyof typeof FileFolderScalarFieldEnum]


  export const SchoolFileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    folderId: 'folderId',
    schoolId: 'schoolId',
    uploadedAt: 'uploadedAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolFileScalarFieldEnum = (typeof SchoolFileScalarFieldEnum)[keyof typeof SchoolFileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    shortName?: StringFilter<"School"> | string
    city?: StringFilter<"School"> | string
    academicYear?: StringFilter<"School"> | string
    brandColor?: StringFilter<"School"> | string
    accentColor?: StringFilter<"School"> | string
    tagline?: StringNullableFilter<"School"> | string | null
    logoUrl?: StringNullableFilter<"School"> | string | null
    logoIconUrl?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    classes?: ClassListRelationFilter
    messages?: MessageListRelationFilter
    surveys?: SurveyListRelationFilter
    events?: EventListRelationFilter
    termDates?: TermDateListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
    weeklyMessages?: WeeklyMessageListRelationFilter
    knowledgeCategories?: KnowledgeCategoryListRelationFilter
    pulseSurveys?: PulseSurveyListRelationFilter
    policies?: PolicyListRelationFilter
    folders?: FileFolderListRelationFilter
    files?: SchoolFileListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    logoIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    surveys?: SurveyOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    termDates?: TermDateOrderByRelationAggregateInput
    scheduleItems?: ScheduleItemOrderByRelationAggregateInput
    weeklyMessages?: WeeklyMessageOrderByRelationAggregateInput
    knowledgeCategories?: KnowledgeCategoryOrderByRelationAggregateInput
    pulseSurveys?: PulseSurveyOrderByRelationAggregateInput
    policies?: PolicyOrderByRelationAggregateInput
    folders?: FileFolderOrderByRelationAggregateInput
    files?: SchoolFileOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    shortName?: StringFilter<"School"> | string
    city?: StringFilter<"School"> | string
    academicYear?: StringFilter<"School"> | string
    brandColor?: StringFilter<"School"> | string
    accentColor?: StringFilter<"School"> | string
    tagline?: StringNullableFilter<"School"> | string | null
    logoUrl?: StringNullableFilter<"School"> | string | null
    logoIconUrl?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    classes?: ClassListRelationFilter
    messages?: MessageListRelationFilter
    surveys?: SurveyListRelationFilter
    events?: EventListRelationFilter
    termDates?: TermDateListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
    weeklyMessages?: WeeklyMessageListRelationFilter
    knowledgeCategories?: KnowledgeCategoryListRelationFilter
    pulseSurveys?: PulseSurveyListRelationFilter
    policies?: PolicyListRelationFilter
    folders?: FileFolderListRelationFilter
    files?: SchoolFileListRelationFilter
  }, "id">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    logoIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    shortName?: StringWithAggregatesFilter<"School"> | string
    city?: StringWithAggregatesFilter<"School"> | string
    academicYear?: StringWithAggregatesFilter<"School"> | string
    brandColor?: StringWithAggregatesFilter<"School"> | string
    accentColor?: StringWithAggregatesFilter<"School"> | string
    tagline?: StringNullableWithAggregatesFilter<"School"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"School"> | string | null
    logoIconUrl?: StringNullableWithAggregatesFilter<"School"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    googleId?: StringNullableFilter<"User"> | string | null
    microsoftId?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    children?: ChildListRelationFilter
    messageAcks?: MessageAcknowledgmentListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
    eventRsvps?: EventRsvpListRelationFilter
    pulseResponses?: PulseResponseListRelationFilter
    weeklyHearts?: WeeklyMessageHeartListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrderInput | SortOrder
    microsoftId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    children?: ChildOrderByRelationAggregateInput
    messageAcks?: MessageAcknowledgmentOrderByRelationAggregateInput
    surveyResponses?: SurveyResponseOrderByRelationAggregateInput
    eventRsvps?: EventRsvpOrderByRelationAggregateInput
    pulseResponses?: PulseResponseOrderByRelationAggregateInput
    weeklyHearts?: WeeklyMessageHeartOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    microsoftId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    children?: ChildListRelationFilter
    messageAcks?: MessageAcknowledgmentListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
    eventRsvps?: EventRsvpListRelationFilter
    pulseResponses?: PulseResponseListRelationFilter
    weeklyHearts?: WeeklyMessageHeartListRelationFilter
  }, "id" | "email" | "googleId" | "microsoftId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrderInput | SortOrder
    microsoftId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    schoolId?: StringWithAggregatesFilter<"User"> | string
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    microsoftId?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ChildWhereInput = {
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    id?: StringFilter<"Child"> | string
    name?: StringFilter<"Child"> | string
    parentId?: StringFilter<"Child"> | string
    classId?: StringFilter<"Child"> | string
    parent?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type ChildOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
    parent?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type ChildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    name?: StringFilter<"Child"> | string
    parentId?: StringFilter<"Child"> | string
    classId?: StringFilter<"Child"> | string
    parent?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "id">

  export type ChildOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
    _count?: ChildCountOrderByAggregateInput
    _max?: ChildMaxOrderByAggregateInput
    _min?: ChildMinOrderByAggregateInput
  }

  export type ChildScalarWhereWithAggregatesInput = {
    AND?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    OR?: ChildScalarWhereWithAggregatesInput[]
    NOT?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Child"> | string
    name?: StringWithAggregatesFilter<"Child"> | string
    parentId?: StringWithAggregatesFilter<"Child"> | string
    classId?: StringWithAggregatesFilter<"Child"> | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    colorBg?: StringFilter<"Class"> | string
    colorText?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    children?: ChildListRelationFilter
    messages?: MessageListRelationFilter
    surveys?: SurveyListRelationFilter
    events?: EventListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
    school?: SchoolOrderByWithRelationInput
    children?: ChildOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    surveys?: SurveyOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    scheduleItems?: ScheduleItemOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: ClassSchoolIdNameCompoundUniqueInput
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    colorBg?: StringFilter<"Class"> | string
    colorText?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    children?: ChildListRelationFilter
    messages?: MessageListRelationFilter
    surveys?: SurveyListRelationFilter
    events?: EventListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
  }, "id" | "schoolId_name">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    colorBg?: StringWithAggregatesFilter<"Class"> | string
    colorText?: StringWithAggregatesFilter<"Class"> | string
    schoolId?: StringWithAggregatesFilter<"Class"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    title?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    targetClass?: StringFilter<"Message"> | string
    classId?: StringNullableFilter<"Message"> | string | null
    schoolId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderName?: StringFilter<"Message"> | string
    actionType?: StringNullableFilter<"Message"> | string | null
    actionLabel?: StringNullableFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    isUrgent?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    acknowledgments?: MessageAcknowledgmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    actionDueDate?: SortOrderInput | SortOrder
    actionAmount?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    createdAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    acknowledgments?: MessageAcknowledgmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    title?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    targetClass?: StringFilter<"Message"> | string
    classId?: StringNullableFilter<"Message"> | string | null
    schoolId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderName?: StringFilter<"Message"> | string
    actionType?: StringNullableFilter<"Message"> | string | null
    actionLabel?: StringNullableFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    isUrgent?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    acknowledgments?: MessageAcknowledgmentListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    actionDueDate?: SortOrderInput | SortOrder
    actionAmount?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    title?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    targetClass?: StringWithAggregatesFilter<"Message"> | string
    classId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    schoolId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    senderName?: StringWithAggregatesFilter<"Message"> | string
    actionType?: StringNullableWithAggregatesFilter<"Message"> | string | null
    actionLabel?: StringNullableWithAggregatesFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableWithAggregatesFilter<"Message"> | string | null
    isPinned?: BoolWithAggregatesFilter<"Message"> | boolean
    isUrgent?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type MessageAcknowledgmentWhereInput = {
    AND?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    OR?: MessageAcknowledgmentWhereInput[]
    NOT?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    id?: StringFilter<"MessageAcknowledgment"> | string
    messageId?: StringFilter<"MessageAcknowledgment"> | string
    userId?: StringFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeFilter<"MessageAcknowledgment"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageAcknowledgmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageAcknowledgmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageAcknowledgmentMessageIdUserIdCompoundUniqueInput
    AND?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    OR?: MessageAcknowledgmentWhereInput[]
    NOT?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    messageId?: StringFilter<"MessageAcknowledgment"> | string
    userId?: StringFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeFilter<"MessageAcknowledgment"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId">

  export type MessageAcknowledgmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: MessageAcknowledgmentCountOrderByAggregateInput
    _max?: MessageAcknowledgmentMaxOrderByAggregateInput
    _min?: MessageAcknowledgmentMinOrderByAggregateInput
  }

  export type MessageAcknowledgmentScalarWhereWithAggregatesInput = {
    AND?: MessageAcknowledgmentScalarWhereWithAggregatesInput | MessageAcknowledgmentScalarWhereWithAggregatesInput[]
    OR?: MessageAcknowledgmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAcknowledgmentScalarWhereWithAggregatesInput | MessageAcknowledgmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAcknowledgment"> | string
    messageId?: StringWithAggregatesFilter<"MessageAcknowledgment"> | string
    userId?: StringWithAggregatesFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageAcknowledgment"> | Date | string
  }

  export type SurveyWhereInput = {
    AND?: SurveyWhereInput | SurveyWhereInput[]
    OR?: SurveyWhereInput[]
    NOT?: SurveyWhereInput | SurveyWhereInput[]
    id?: StringFilter<"Survey"> | string
    question?: StringFilter<"Survey"> | string
    options?: JsonFilter<"Survey">
    active?: BoolFilter<"Survey"> | boolean
    targetClass?: StringFilter<"Survey"> | string
    classId?: StringNullableFilter<"Survey"> | string | null
    schoolId?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    responses?: SurveyResponseListRelationFilter
  }

  export type SurveyOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    active?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    responses?: SurveyResponseOrderByRelationAggregateInput
  }

  export type SurveyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyWhereInput | SurveyWhereInput[]
    OR?: SurveyWhereInput[]
    NOT?: SurveyWhereInput | SurveyWhereInput[]
    question?: StringFilter<"Survey"> | string
    options?: JsonFilter<"Survey">
    active?: BoolFilter<"Survey"> | boolean
    targetClass?: StringFilter<"Survey"> | string
    classId?: StringNullableFilter<"Survey"> | string | null
    schoolId?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    responses?: SurveyResponseListRelationFilter
  }, "id">

  export type SurveyOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    active?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    _count?: SurveyCountOrderByAggregateInput
    _max?: SurveyMaxOrderByAggregateInput
    _min?: SurveyMinOrderByAggregateInput
  }

  export type SurveyScalarWhereWithAggregatesInput = {
    AND?: SurveyScalarWhereWithAggregatesInput | SurveyScalarWhereWithAggregatesInput[]
    OR?: SurveyScalarWhereWithAggregatesInput[]
    NOT?: SurveyScalarWhereWithAggregatesInput | SurveyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Survey"> | string
    question?: StringWithAggregatesFilter<"Survey"> | string
    options?: JsonWithAggregatesFilter<"Survey">
    active?: BoolWithAggregatesFilter<"Survey"> | boolean
    targetClass?: StringWithAggregatesFilter<"Survey"> | string
    classId?: StringNullableWithAggregatesFilter<"Survey"> | string | null
    schoolId?: StringWithAggregatesFilter<"Survey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Survey"> | Date | string
  }

  export type SurveyResponseWhereInput = {
    AND?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    OR?: SurveyResponseWhereInput[]
    NOT?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    id?: StringFilter<"SurveyResponse"> | string
    surveyId?: StringFilter<"SurveyResponse"> | string
    userId?: StringFilter<"SurveyResponse"> | string
    response?: StringFilter<"SurveyResponse"> | string
    createdAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SurveyResponseOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    survey?: SurveyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SurveyResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    surveyId_userId?: SurveyResponseSurveyIdUserIdCompoundUniqueInput
    AND?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    OR?: SurveyResponseWhereInput[]
    NOT?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    surveyId?: StringFilter<"SurveyResponse"> | string
    userId?: StringFilter<"SurveyResponse"> | string
    response?: StringFilter<"SurveyResponse"> | string
    createdAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "surveyId_userId">

  export type SurveyResponseOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    _count?: SurveyResponseCountOrderByAggregateInput
    _max?: SurveyResponseMaxOrderByAggregateInput
    _min?: SurveyResponseMinOrderByAggregateInput
  }

  export type SurveyResponseScalarWhereWithAggregatesInput = {
    AND?: SurveyResponseScalarWhereWithAggregatesInput | SurveyResponseScalarWhereWithAggregatesInput[]
    OR?: SurveyResponseScalarWhereWithAggregatesInput[]
    NOT?: SurveyResponseScalarWhereWithAggregatesInput | SurveyResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SurveyResponse"> | string
    surveyId?: StringWithAggregatesFilter<"SurveyResponse"> | string
    userId?: StringWithAggregatesFilter<"SurveyResponse"> | string
    response?: StringWithAggregatesFilter<"SurveyResponse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SurveyResponse"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    targetClass?: StringFilter<"Event"> | string
    classId?: StringNullableFilter<"Event"> | string | null
    schoolId?: StringFilter<"Event"> | string
    requiresRsvp?: BoolFilter<"Event"> | boolean
    createdAt?: DateTimeFilter<"Event"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    rsvps?: EventRsvpListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    rsvps?: EventRsvpOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    targetClass?: StringFilter<"Event"> | string
    classId?: StringNullableFilter<"Event"> | string | null
    schoolId?: StringFilter<"Event"> | string
    requiresRsvp?: BoolFilter<"Event"> | boolean
    createdAt?: DateTimeFilter<"Event"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    rsvps?: EventRsvpListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    time?: StringNullableWithAggregatesFilter<"Event"> | string | null
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    targetClass?: StringWithAggregatesFilter<"Event"> | string
    classId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    schoolId?: StringWithAggregatesFilter<"Event"> | string
    requiresRsvp?: BoolWithAggregatesFilter<"Event"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventRsvpWhereInput = {
    AND?: EventRsvpWhereInput | EventRsvpWhereInput[]
    OR?: EventRsvpWhereInput[]
    NOT?: EventRsvpWhereInput | EventRsvpWhereInput[]
    id?: StringFilter<"EventRsvp"> | string
    eventId?: StringFilter<"EventRsvp"> | string
    userId?: StringFilter<"EventRsvp"> | string
    status?: StringFilter<"EventRsvp"> | string
    createdAt?: DateTimeFilter<"EventRsvp"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EventRsvpOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventRsvpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventRsvpEventIdUserIdCompoundUniqueInput
    AND?: EventRsvpWhereInput | EventRsvpWhereInput[]
    OR?: EventRsvpWhereInput[]
    NOT?: EventRsvpWhereInput | EventRsvpWhereInput[]
    eventId?: StringFilter<"EventRsvp"> | string
    userId?: StringFilter<"EventRsvp"> | string
    status?: StringFilter<"EventRsvp"> | string
    createdAt?: DateTimeFilter<"EventRsvp"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "eventId_userId">

  export type EventRsvpOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: EventRsvpCountOrderByAggregateInput
    _max?: EventRsvpMaxOrderByAggregateInput
    _min?: EventRsvpMinOrderByAggregateInput
  }

  export type EventRsvpScalarWhereWithAggregatesInput = {
    AND?: EventRsvpScalarWhereWithAggregatesInput | EventRsvpScalarWhereWithAggregatesInput[]
    OR?: EventRsvpScalarWhereWithAggregatesInput[]
    NOT?: EventRsvpScalarWhereWithAggregatesInput | EventRsvpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventRsvp"> | string
    eventId?: StringWithAggregatesFilter<"EventRsvp"> | string
    userId?: StringWithAggregatesFilter<"EventRsvp"> | string
    status?: StringWithAggregatesFilter<"EventRsvp"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventRsvp"> | Date | string
  }

  export type TermDateWhereInput = {
    AND?: TermDateWhereInput | TermDateWhereInput[]
    OR?: TermDateWhereInput[]
    NOT?: TermDateWhereInput | TermDateWhereInput[]
    id?: StringFilter<"TermDate"> | string
    term?: IntFilter<"TermDate"> | number
    termName?: StringFilter<"TermDate"> | string
    label?: StringFilter<"TermDate"> | string
    sublabel?: StringNullableFilter<"TermDate"> | string | null
    date?: DateTimeFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableFilter<"TermDate"> | Date | string | null
    type?: StringFilter<"TermDate"> | string
    color?: StringFilter<"TermDate"> | string
    schoolId?: StringFilter<"TermDate"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type TermDateOrderByWithRelationInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrderInput | SortOrder
    date?: SortOrder
    endDate?: SortOrderInput | SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type TermDateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TermDateWhereInput | TermDateWhereInput[]
    OR?: TermDateWhereInput[]
    NOT?: TermDateWhereInput | TermDateWhereInput[]
    term?: IntFilter<"TermDate"> | number
    termName?: StringFilter<"TermDate"> | string
    label?: StringFilter<"TermDate"> | string
    sublabel?: StringNullableFilter<"TermDate"> | string | null
    date?: DateTimeFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableFilter<"TermDate"> | Date | string | null
    type?: StringFilter<"TermDate"> | string
    color?: StringFilter<"TermDate"> | string
    schoolId?: StringFilter<"TermDate"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type TermDateOrderByWithAggregationInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrderInput | SortOrder
    date?: SortOrder
    endDate?: SortOrderInput | SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
    _count?: TermDateCountOrderByAggregateInput
    _avg?: TermDateAvgOrderByAggregateInput
    _max?: TermDateMaxOrderByAggregateInput
    _min?: TermDateMinOrderByAggregateInput
    _sum?: TermDateSumOrderByAggregateInput
  }

  export type TermDateScalarWhereWithAggregatesInput = {
    AND?: TermDateScalarWhereWithAggregatesInput | TermDateScalarWhereWithAggregatesInput[]
    OR?: TermDateScalarWhereWithAggregatesInput[]
    NOT?: TermDateScalarWhereWithAggregatesInput | TermDateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TermDate"> | string
    term?: IntWithAggregatesFilter<"TermDate"> | number
    termName?: StringWithAggregatesFilter<"TermDate"> | string
    label?: StringWithAggregatesFilter<"TermDate"> | string
    sublabel?: StringNullableWithAggregatesFilter<"TermDate"> | string | null
    date?: DateTimeWithAggregatesFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"TermDate"> | Date | string | null
    type?: StringWithAggregatesFilter<"TermDate"> | string
    color?: StringWithAggregatesFilter<"TermDate"> | string
    schoolId?: StringWithAggregatesFilter<"TermDate"> | string
  }

  export type ScheduleItemWhereInput = {
    AND?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    OR?: ScheduleItemWhereInput[]
    NOT?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    id?: StringFilter<"ScheduleItem"> | string
    targetClass?: StringFilter<"ScheduleItem"> | string
    classId?: StringNullableFilter<"ScheduleItem"> | string | null
    schoolId?: StringFilter<"ScheduleItem"> | string
    isRecurring?: BoolFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableFilter<"ScheduleItem"> | number | null
    active?: BoolFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableFilter<"ScheduleItem"> | Date | string | null
    type?: StringFilter<"ScheduleItem"> | string
    label?: StringFilter<"ScheduleItem"> | string
    description?: StringNullableFilter<"ScheduleItem"> | string | null
    icon?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type ScheduleItemOrderByWithRelationInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    active?: SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type ScheduleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    OR?: ScheduleItemWhereInput[]
    NOT?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    targetClass?: StringFilter<"ScheduleItem"> | string
    classId?: StringNullableFilter<"ScheduleItem"> | string | null
    schoolId?: StringFilter<"ScheduleItem"> | string
    isRecurring?: BoolFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableFilter<"ScheduleItem"> | number | null
    active?: BoolFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableFilter<"ScheduleItem"> | Date | string | null
    type?: StringFilter<"ScheduleItem"> | string
    label?: StringFilter<"ScheduleItem"> | string
    description?: StringNullableFilter<"ScheduleItem"> | string | null
    icon?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type ScheduleItemOrderByWithAggregationInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    active?: SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ScheduleItemCountOrderByAggregateInput
    _avg?: ScheduleItemAvgOrderByAggregateInput
    _max?: ScheduleItemMaxOrderByAggregateInput
    _min?: ScheduleItemMinOrderByAggregateInput
    _sum?: ScheduleItemSumOrderByAggregateInput
  }

  export type ScheduleItemScalarWhereWithAggregatesInput = {
    AND?: ScheduleItemScalarWhereWithAggregatesInput | ScheduleItemScalarWhereWithAggregatesInput[]
    OR?: ScheduleItemScalarWhereWithAggregatesInput[]
    NOT?: ScheduleItemScalarWhereWithAggregatesInput | ScheduleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleItem"> | string
    targetClass?: StringWithAggregatesFilter<"ScheduleItem"> | string
    classId?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    schoolId?: StringWithAggregatesFilter<"ScheduleItem"> | string
    isRecurring?: BoolWithAggregatesFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableWithAggregatesFilter<"ScheduleItem"> | number | null
    active?: BoolWithAggregatesFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableWithAggregatesFilter<"ScheduleItem"> | Date | string | null
    type?: StringWithAggregatesFilter<"ScheduleItem"> | string
    label?: StringWithAggregatesFilter<"ScheduleItem"> | string
    description?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleItem"> | Date | string
  }

  export type WeeklyMessageWhereInput = {
    AND?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    OR?: WeeklyMessageWhereInput[]
    NOT?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    id?: StringFilter<"WeeklyMessage"> | string
    title?: StringFilter<"WeeklyMessage"> | string
    content?: StringFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolFilter<"WeeklyMessage"> | boolean
    schoolId?: StringFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeFilter<"WeeklyMessage"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    hearts?: WeeklyMessageHeartListRelationFilter
  }

  export type WeeklyMessageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    hearts?: WeeklyMessageHeartOrderByRelationAggregateInput
  }

  export type WeeklyMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    OR?: WeeklyMessageWhereInput[]
    NOT?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    title?: StringFilter<"WeeklyMessage"> | string
    content?: StringFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolFilter<"WeeklyMessage"> | boolean
    schoolId?: StringFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeFilter<"WeeklyMessage"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    hearts?: WeeklyMessageHeartListRelationFilter
  }, "id">

  export type WeeklyMessageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    _count?: WeeklyMessageCountOrderByAggregateInput
    _max?: WeeklyMessageMaxOrderByAggregateInput
    _min?: WeeklyMessageMinOrderByAggregateInput
  }

  export type WeeklyMessageScalarWhereWithAggregatesInput = {
    AND?: WeeklyMessageScalarWhereWithAggregatesInput | WeeklyMessageScalarWhereWithAggregatesInput[]
    OR?: WeeklyMessageScalarWhereWithAggregatesInput[]
    NOT?: WeeklyMessageScalarWhereWithAggregatesInput | WeeklyMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    title?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    content?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeWithAggregatesFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolWithAggregatesFilter<"WeeklyMessage"> | boolean
    schoolId?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyMessage"> | Date | string
  }

  export type WeeklyMessageHeartWhereInput = {
    AND?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    OR?: WeeklyMessageHeartWhereInput[]
    NOT?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    id?: StringFilter<"WeeklyMessageHeart"> | string
    messageId?: StringFilter<"WeeklyMessageHeart"> | string
    userId?: StringFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeFilter<"WeeklyMessageHeart"> | Date | string
    message?: XOR<WeeklyMessageRelationFilter, WeeklyMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WeeklyMessageHeartOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    message?: WeeklyMessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WeeklyMessageHeartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: WeeklyMessageHeartMessageIdUserIdCompoundUniqueInput
    AND?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    OR?: WeeklyMessageHeartWhereInput[]
    NOT?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    messageId?: StringFilter<"WeeklyMessageHeart"> | string
    userId?: StringFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeFilter<"WeeklyMessageHeart"> | Date | string
    message?: XOR<WeeklyMessageRelationFilter, WeeklyMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId">

  export type WeeklyMessageHeartOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: WeeklyMessageHeartCountOrderByAggregateInput
    _max?: WeeklyMessageHeartMaxOrderByAggregateInput
    _min?: WeeklyMessageHeartMinOrderByAggregateInput
  }

  export type WeeklyMessageHeartScalarWhereWithAggregatesInput = {
    AND?: WeeklyMessageHeartScalarWhereWithAggregatesInput | WeeklyMessageHeartScalarWhereWithAggregatesInput[]
    OR?: WeeklyMessageHeartScalarWhereWithAggregatesInput[]
    NOT?: WeeklyMessageHeartScalarWhereWithAggregatesInput | WeeklyMessageHeartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyMessageHeart"> | string
    messageId?: StringWithAggregatesFilter<"WeeklyMessageHeart"> | string
    userId?: StringWithAggregatesFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyMessageHeart"> | Date | string
  }

  export type KnowledgeCategoryWhereInput = {
    AND?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    OR?: KnowledgeCategoryWhereInput[]
    NOT?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    id?: StringFilter<"KnowledgeCategory"> | string
    name?: StringFilter<"KnowledgeCategory"> | string
    icon?: StringFilter<"KnowledgeCategory"> | string
    color?: StringFilter<"KnowledgeCategory"> | string
    order?: IntFilter<"KnowledgeCategory"> | number
    schoolId?: StringFilter<"KnowledgeCategory"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    articles?: KnowledgeArticleListRelationFilter
  }

  export type KnowledgeCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    school?: SchoolOrderByWithRelationInput
    articles?: KnowledgeArticleOrderByRelationAggregateInput
  }

  export type KnowledgeCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    OR?: KnowledgeCategoryWhereInput[]
    NOT?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    name?: StringFilter<"KnowledgeCategory"> | string
    icon?: StringFilter<"KnowledgeCategory"> | string
    color?: StringFilter<"KnowledgeCategory"> | string
    order?: IntFilter<"KnowledgeCategory"> | number
    schoolId?: StringFilter<"KnowledgeCategory"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    articles?: KnowledgeArticleListRelationFilter
  }, "id">

  export type KnowledgeCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    _count?: KnowledgeCategoryCountOrderByAggregateInput
    _avg?: KnowledgeCategoryAvgOrderByAggregateInput
    _max?: KnowledgeCategoryMaxOrderByAggregateInput
    _min?: KnowledgeCategoryMinOrderByAggregateInput
    _sum?: KnowledgeCategorySumOrderByAggregateInput
  }

  export type KnowledgeCategoryScalarWhereWithAggregatesInput = {
    AND?: KnowledgeCategoryScalarWhereWithAggregatesInput | KnowledgeCategoryScalarWhereWithAggregatesInput[]
    OR?: KnowledgeCategoryScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeCategoryScalarWhereWithAggregatesInput | KnowledgeCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    name?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    icon?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    color?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    order?: IntWithAggregatesFilter<"KnowledgeCategory"> | number
    schoolId?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
  }

  export type KnowledgeArticleWhereInput = {
    AND?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    OR?: KnowledgeArticleWhereInput[]
    NOT?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    id?: StringFilter<"KnowledgeArticle"> | string
    title?: StringFilter<"KnowledgeArticle"> | string
    content?: StringFilter<"KnowledgeArticle"> | string
    categoryId?: StringFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    category?: XOR<KnowledgeCategoryRelationFilter, KnowledgeCategoryWhereInput>
  }

  export type KnowledgeArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    category?: KnowledgeCategoryOrderByWithRelationInput
  }

  export type KnowledgeArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    OR?: KnowledgeArticleWhereInput[]
    NOT?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    title?: StringFilter<"KnowledgeArticle"> | string
    content?: StringFilter<"KnowledgeArticle"> | string
    categoryId?: StringFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    category?: XOR<KnowledgeCategoryRelationFilter, KnowledgeCategoryWhereInput>
  }, "id">

  export type KnowledgeArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: KnowledgeArticleCountOrderByAggregateInput
    _max?: KnowledgeArticleMaxOrderByAggregateInput
    _min?: KnowledgeArticleMinOrderByAggregateInput
  }

  export type KnowledgeArticleScalarWhereWithAggregatesInput = {
    AND?: KnowledgeArticleScalarWhereWithAggregatesInput | KnowledgeArticleScalarWhereWithAggregatesInput[]
    OR?: KnowledgeArticleScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeArticleScalarWhereWithAggregatesInput | KnowledgeArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    title?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    content?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    categoryId?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeArticle"> | Date | string
  }

  export type PulseSurveyWhereInput = {
    AND?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    OR?: PulseSurveyWhereInput[]
    NOT?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    id?: StringFilter<"PulseSurvey"> | string
    halfTermName?: StringFilter<"PulseSurvey"> | string
    status?: StringFilter<"PulseSurvey"> | string
    opensAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    schoolId?: StringFilter<"PulseSurvey"> | string
    createdAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    responses?: PulseResponseListRelationFilter
  }

  export type PulseSurveyOrderByWithRelationInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    responses?: PulseResponseOrderByRelationAggregateInput
  }

  export type PulseSurveyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    OR?: PulseSurveyWhereInput[]
    NOT?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    halfTermName?: StringFilter<"PulseSurvey"> | string
    status?: StringFilter<"PulseSurvey"> | string
    opensAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    schoolId?: StringFilter<"PulseSurvey"> | string
    createdAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    responses?: PulseResponseListRelationFilter
  }, "id">

  export type PulseSurveyOrderByWithAggregationInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    _count?: PulseSurveyCountOrderByAggregateInput
    _max?: PulseSurveyMaxOrderByAggregateInput
    _min?: PulseSurveyMinOrderByAggregateInput
  }

  export type PulseSurveyScalarWhereWithAggregatesInput = {
    AND?: PulseSurveyScalarWhereWithAggregatesInput | PulseSurveyScalarWhereWithAggregatesInput[]
    OR?: PulseSurveyScalarWhereWithAggregatesInput[]
    NOT?: PulseSurveyScalarWhereWithAggregatesInput | PulseSurveyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PulseSurvey"> | string
    halfTermName?: StringWithAggregatesFilter<"PulseSurvey"> | string
    status?: StringWithAggregatesFilter<"PulseSurvey"> | string
    opensAt?: DateTimeWithAggregatesFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeWithAggregatesFilter<"PulseSurvey"> | Date | string
    schoolId?: StringWithAggregatesFilter<"PulseSurvey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PulseSurvey"> | Date | string
  }

  export type PulseResponseWhereInput = {
    AND?: PulseResponseWhereInput | PulseResponseWhereInput[]
    OR?: PulseResponseWhereInput[]
    NOT?: PulseResponseWhereInput | PulseResponseWhereInput[]
    id?: StringFilter<"PulseResponse"> | string
    pulseId?: StringFilter<"PulseResponse"> | string
    userId?: StringFilter<"PulseResponse"> | string
    answers?: JsonFilter<"PulseResponse">
    createdAt?: DateTimeFilter<"PulseResponse"> | Date | string
    pulse?: XOR<PulseSurveyRelationFilter, PulseSurveyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PulseResponseOrderByWithRelationInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    pulse?: PulseSurveyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PulseResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pulseId_userId?: PulseResponsePulseIdUserIdCompoundUniqueInput
    AND?: PulseResponseWhereInput | PulseResponseWhereInput[]
    OR?: PulseResponseWhereInput[]
    NOT?: PulseResponseWhereInput | PulseResponseWhereInput[]
    pulseId?: StringFilter<"PulseResponse"> | string
    userId?: StringFilter<"PulseResponse"> | string
    answers?: JsonFilter<"PulseResponse">
    createdAt?: DateTimeFilter<"PulseResponse"> | Date | string
    pulse?: XOR<PulseSurveyRelationFilter, PulseSurveyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "pulseId_userId">

  export type PulseResponseOrderByWithAggregationInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    _count?: PulseResponseCountOrderByAggregateInput
    _max?: PulseResponseMaxOrderByAggregateInput
    _min?: PulseResponseMinOrderByAggregateInput
  }

  export type PulseResponseScalarWhereWithAggregatesInput = {
    AND?: PulseResponseScalarWhereWithAggregatesInput | PulseResponseScalarWhereWithAggregatesInput[]
    OR?: PulseResponseScalarWhereWithAggregatesInput[]
    NOT?: PulseResponseScalarWhereWithAggregatesInput | PulseResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PulseResponse"> | string
    pulseId?: StringWithAggregatesFilter<"PulseResponse"> | string
    userId?: StringWithAggregatesFilter<"PulseResponse"> | string
    answers?: JsonWithAggregatesFilter<"PulseResponse">
    createdAt?: DateTimeWithAggregatesFilter<"PulseResponse"> | Date | string
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    id?: StringFilter<"Policy"> | string
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    fileUrl?: StringFilter<"Policy"> | string
    fileSize?: IntNullableFilter<"Policy"> | number | null
    schoolId?: StringFilter<"Policy"> | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    fileUrl?: StringFilter<"Policy"> | string
    fileSize?: IntNullableFilter<"Policy"> | number | null
    schoolId?: StringFilter<"Policy"> | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Policy"> | string
    name?: StringWithAggregatesFilter<"Policy"> | string
    description?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    fileUrl?: StringWithAggregatesFilter<"Policy"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Policy"> | number | null
    schoolId?: StringWithAggregatesFilter<"Policy"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
  }

  export type FileFolderWhereInput = {
    AND?: FileFolderWhereInput | FileFolderWhereInput[]
    OR?: FileFolderWhereInput[]
    NOT?: FileFolderWhereInput | FileFolderWhereInput[]
    id?: StringFilter<"FileFolder"> | string
    name?: StringFilter<"FileFolder"> | string
    icon?: StringNullableFilter<"FileFolder"> | string | null
    color?: StringNullableFilter<"FileFolder"> | string | null
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    schoolId?: StringFilter<"FileFolder"> | string
    order?: IntFilter<"FileFolder"> | number
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
    parent?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    children?: FileFolderListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    files?: SchoolFileListRelationFilter
  }

  export type FileFolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    parent?: FileFolderOrderByWithRelationInput
    children?: FileFolderOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
    files?: SchoolFileOrderByRelationAggregateInput
  }

  export type FileFolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileFolderWhereInput | FileFolderWhereInput[]
    OR?: FileFolderWhereInput[]
    NOT?: FileFolderWhereInput | FileFolderWhereInput[]
    name?: StringFilter<"FileFolder"> | string
    icon?: StringNullableFilter<"FileFolder"> | string | null
    color?: StringNullableFilter<"FileFolder"> | string | null
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    schoolId?: StringFilter<"FileFolder"> | string
    order?: IntFilter<"FileFolder"> | number
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
    parent?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    children?: FileFolderListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    files?: SchoolFileListRelationFilter
  }, "id">

  export type FileFolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: FileFolderCountOrderByAggregateInput
    _avg?: FileFolderAvgOrderByAggregateInput
    _max?: FileFolderMaxOrderByAggregateInput
    _min?: FileFolderMinOrderByAggregateInput
    _sum?: FileFolderSumOrderByAggregateInput
  }

  export type FileFolderScalarWhereWithAggregatesInput = {
    AND?: FileFolderScalarWhereWithAggregatesInput | FileFolderScalarWhereWithAggregatesInput[]
    OR?: FileFolderScalarWhereWithAggregatesInput[]
    NOT?: FileFolderScalarWhereWithAggregatesInput | FileFolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileFolder"> | string
    name?: StringWithAggregatesFilter<"FileFolder"> | string
    icon?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    color?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    schoolId?: StringWithAggregatesFilter<"FileFolder"> | string
    order?: IntWithAggregatesFilter<"FileFolder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FileFolder"> | Date | string
  }

  export type SchoolFileWhereInput = {
    AND?: SchoolFileWhereInput | SchoolFileWhereInput[]
    OR?: SchoolFileWhereInput[]
    NOT?: SchoolFileWhereInput | SchoolFileWhereInput[]
    id?: StringFilter<"SchoolFile"> | string
    name?: StringFilter<"SchoolFile"> | string
    fileName?: StringFilter<"SchoolFile"> | string
    fileUrl?: StringFilter<"SchoolFile"> | string
    fileType?: StringFilter<"SchoolFile"> | string
    fileSize?: IntFilter<"SchoolFile"> | number
    folderId?: StringNullableFilter<"SchoolFile"> | string | null
    schoolId?: StringFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    folder?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type SchoolFileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    folder?: FileFolderOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolFileWhereInput | SchoolFileWhereInput[]
    OR?: SchoolFileWhereInput[]
    NOT?: SchoolFileWhereInput | SchoolFileWhereInput[]
    name?: StringFilter<"SchoolFile"> | string
    fileName?: StringFilter<"SchoolFile"> | string
    fileUrl?: StringFilter<"SchoolFile"> | string
    fileType?: StringFilter<"SchoolFile"> | string
    fileSize?: IntFilter<"SchoolFile"> | number
    folderId?: StringNullableFilter<"SchoolFile"> | string | null
    schoolId?: StringFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    folder?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type SchoolFileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolFileCountOrderByAggregateInput
    _avg?: SchoolFileAvgOrderByAggregateInput
    _max?: SchoolFileMaxOrderByAggregateInput
    _min?: SchoolFileMinOrderByAggregateInput
    _sum?: SchoolFileSumOrderByAggregateInput
  }

  export type SchoolFileScalarWhereWithAggregatesInput = {
    AND?: SchoolFileScalarWhereWithAggregatesInput | SchoolFileScalarWhereWithAggregatesInput[]
    OR?: SchoolFileScalarWhereWithAggregatesInput[]
    NOT?: SchoolFileScalarWhereWithAggregatesInput | SchoolFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolFile"> | string
    name?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileName?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileUrl?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileType?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileSize?: IntWithAggregatesFilter<"SchoolFile"> | number
    folderId?: StringNullableWithAggregatesFilter<"SchoolFile"> | string | null
    schoolId?: StringWithAggregatesFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolFile"> | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateInput = {
    id?: string
    name: string
    parent: UserCreateNestedOneWithoutChildrenInput
    class: ClassCreateNestedOneWithoutChildrenInput
  }

  export type ChildUncheckedCreateInput = {
    id?: string
    name: string
    parentId: string
    classId: string
  }

  export type ChildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: UserUpdateOneRequiredWithoutChildrenNestedInput
    class?: ClassUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildCreateManyInput = {
    id?: string
    name: string
    parentId: string
    classId: string
  }

  export type ChildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ChildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    surveys?: SurveyCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    surveys?: SurveyUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentCreateInput = {
    id?: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAcknowledgmentsInput
    user: UserCreateNestedOneWithoutMessageAcksInput
  }

  export type MessageAcknowledgmentUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAcknowledgmentsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageAcksNestedInput
  }

  export type MessageAcknowledgmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyCreateInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutSurveysInput
    school: SchoolCreateNestedOneWithoutSurveysInput
    responses?: SurveyResponseCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    classId?: string | null
    schoolId: string
    createdAt?: Date | string
    responses?: SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutSurveysNestedInput
    school?: SchoolUpdateOneRequiredWithoutSurveysNestedInput
    responses?: SurveyResponseUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyCreateManyInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    classId?: string | null
    schoolId: string
    createdAt?: Date | string
  }

  export type SurveyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseCreateInput = {
    id?: string
    response: string
    createdAt?: Date | string
    survey: SurveyCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutSurveyResponsesInput
  }

  export type SurveyResponseUncheckedCreateInput = {
    id?: string
    surveyId: string
    userId: string
    response: string
    createdAt?: Date | string
  }

  export type SurveyResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutSurveyResponsesNestedInput
  }

  export type SurveyResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseCreateManyInput = {
    id?: string
    surveyId: string
    userId: string
    response: string
    createdAt?: Date | string
  }

  export type SurveyResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutEventsInput
    school: SchoolCreateNestedOneWithoutEventsInput
    rsvps?: EventRsvpCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    rsvps?: EventRsvpUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutEventsNestedInput
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: EventRsvpUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: EventRsvpUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpCreateInput = {
    id?: string
    status: string
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutRsvpsInput
    user: UserCreateNestedOneWithoutEventRsvpsInput
  }

  export type EventRsvpUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRsvpsNestedInput
    user?: UserUpdateOneRequiredWithoutEventRsvpsNestedInput
  }

  export type EventRsvpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermDateCreateInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
    school: SchoolCreateNestedOneWithoutTermDatesInput
  }

  export type TermDateUncheckedCreateInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
    schoolId: string
  }

  export type TermDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutTermDatesNestedInput
  }

  export type TermDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateCreateManyInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
    schoolId: string
  }

  export type TermDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleItemCreateInput = {
    id?: string
    targetClass: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutScheduleItemsInput
    school: SchoolCreateNestedOneWithoutScheduleItemsInput
  }

  export type ScheduleItemUncheckedCreateInput = {
    id?: string
    targetClass: string
    classId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutScheduleItemsNestedInput
    school?: SchoolUpdateOneRequiredWithoutScheduleItemsNestedInput
  }

  export type ScheduleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemCreateManyInput = {
    id?: string
    targetClass: string
    classId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageCreateInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutWeeklyMessagesInput
    hearts?: WeeklyMessageHeartCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    hearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutWeeklyMessagesNestedInput
    hearts?: WeeklyMessageHeartUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageCreateManyInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartCreateInput = {
    id?: string
    createdAt?: Date | string
    message: WeeklyMessageCreateNestedOneWithoutHeartsInput
    user: UserCreateNestedOneWithoutWeeklyHeartsInput
  }

  export type WeeklyMessageHeartUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: WeeklyMessageUpdateOneRequiredWithoutHeartsNestedInput
    user?: UserUpdateOneRequiredWithoutWeeklyHeartsNestedInput
  }

  export type WeeklyMessageHeartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCategoryCreateInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    school: SchoolCreateNestedOneWithoutKnowledgeCategoriesInput
    articles?: KnowledgeArticleCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryUncheckedCreateInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    schoolId: string
    articles?: KnowledgeArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    school?: SchoolUpdateOneRequiredWithoutKnowledgeCategoriesNestedInput
    articles?: KnowledgeArticleUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    articles?: KnowledgeArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryCreateManyInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    schoolId: string
  }

  export type KnowledgeCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type KnowledgeCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type KnowledgeArticleCreateInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
    category: KnowledgeCategoryCreateNestedOneWithoutArticlesInput
  }

  export type KnowledgeArticleUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: KnowledgeCategoryUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type KnowledgeArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleCreateManyInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseSurveyCreateInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutPulseSurveysInput
    responses?: PulseResponseCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyUncheckedCreateInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    schoolId: string
    createdAt?: Date | string
    responses?: PulseResponseUncheckedCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPulseSurveysNestedInput
    responses?: PulseResponseUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PulseResponseUncheckedUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyCreateManyInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    schoolId: string
    createdAt?: Date | string
  }

  export type PulseSurveyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseSurveyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseCreateInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pulse: PulseSurveyCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutPulseResponsesInput
  }

  export type PulseResponseUncheckedCreateInput = {
    id?: string
    pulseId: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pulse?: PulseSurveyUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutPulseResponsesNestedInput
  }

  export type PulseResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseCreateManyInput = {
    id?: string
    pulseId: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    schoolId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    schoolId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderCreateInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    children?: FileFolderCreateNestedManyWithoutParentInput
    school: SchoolCreateNestedOneWithoutFoldersInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    children?: FileFolderUpdateManyWithoutParentNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderCreateManyInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
  }

  export type FileFolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileCreateInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    folder?: FileFolderCreateNestedOneWithoutFilesInput
    school: SchoolCreateNestedOneWithoutFilesInput
  }

  export type SchoolFileUncheckedCreateInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FileFolderUpdateOneWithoutFilesNestedInput
    school?: SchoolUpdateOneRequiredWithoutFilesNestedInput
  }

  export type SchoolFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileCreateManyInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type SurveyListRelationFilter = {
    every?: SurveyWhereInput
    some?: SurveyWhereInput
    none?: SurveyWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type TermDateListRelationFilter = {
    every?: TermDateWhereInput
    some?: TermDateWhereInput
    none?: TermDateWhereInput
  }

  export type ScheduleItemListRelationFilter = {
    every?: ScheduleItemWhereInput
    some?: ScheduleItemWhereInput
    none?: ScheduleItemWhereInput
  }

  export type WeeklyMessageListRelationFilter = {
    every?: WeeklyMessageWhereInput
    some?: WeeklyMessageWhereInput
    none?: WeeklyMessageWhereInput
  }

  export type KnowledgeCategoryListRelationFilter = {
    every?: KnowledgeCategoryWhereInput
    some?: KnowledgeCategoryWhereInput
    none?: KnowledgeCategoryWhereInput
  }

  export type PulseSurveyListRelationFilter = {
    every?: PulseSurveyWhereInput
    some?: PulseSurveyWhereInput
    none?: PulseSurveyWhereInput
  }

  export type PolicyListRelationFilter = {
    every?: PolicyWhereInput
    some?: PolicyWhereInput
    none?: PolicyWhereInput
  }

  export type FileFolderListRelationFilter = {
    every?: FileFolderWhereInput
    some?: FileFolderWhereInput
    none?: FileFolderWhereInput
  }

  export type SchoolFileListRelationFilter = {
    every?: SchoolFileWhereInput
    some?: SchoolFileWhereInput
    none?: SchoolFileWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TermDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PulseSurveyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileFolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    logoIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    logoIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    logoIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type ChildListRelationFilter = {
    every?: ChildWhereInput
    some?: ChildWhereInput
    none?: ChildWhereInput
  }

  export type MessageAcknowledgmentListRelationFilter = {
    every?: MessageAcknowledgmentWhereInput
    some?: MessageAcknowledgmentWhereInput
    none?: MessageAcknowledgmentWhereInput
  }

  export type SurveyResponseListRelationFilter = {
    every?: SurveyResponseWhereInput
    some?: SurveyResponseWhereInput
    none?: SurveyResponseWhereInput
  }

  export type EventRsvpListRelationFilter = {
    every?: EventRsvpWhereInput
    some?: EventRsvpWhereInput
    none?: EventRsvpWhereInput
  }

  export type PulseResponseListRelationFilter = {
    every?: PulseResponseWhereInput
    some?: PulseResponseWhereInput
    none?: PulseResponseWhereInput
  }

  export type WeeklyMessageHeartListRelationFilter = {
    every?: WeeklyMessageHeartWhereInput
    some?: WeeklyMessageHeartWhereInput
    none?: WeeklyMessageHeartWhereInput
  }

  export type ChildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageAcknowledgmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventRsvpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PulseResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyMessageHeartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrder
    microsoftId?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrder
    microsoftId?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrder
    microsoftId?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClassRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ChildCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
  }

  export type ChildMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
  }

  export type ChildMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
  }

  export type ClassSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ClassNullableRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrder
    actionLabel?: SortOrder
    actionDueDate?: SortOrder
    actionAmount?: SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrder
    actionLabel?: SortOrder
    actionDueDate?: SortOrder
    actionAmount?: SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrder
    actionLabel?: SortOrder
    actionDueDate?: SortOrder
    actionAmount?: SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageAcknowledgmentMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageAcknowledgmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAcknowledgmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAcknowledgmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SurveyCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    active?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    active?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    active?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SurveyRelationFilter = {
    is?: SurveyWhereInput
    isNot?: SurveyWhereInput
  }

  export type SurveyResponseSurveyIdUserIdCompoundUniqueInput = {
    surveyId: string
    userId: string
  }

  export type SurveyResponseCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventRsvpEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventRsvpCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EventRsvpMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EventRsvpMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TermDateCountOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
  }

  export type TermDateAvgOrderByAggregateInput = {
    term?: SortOrder
  }

  export type TermDateMaxOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
  }

  export type TermDateMinOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
  }

  export type TermDateSumOrderByAggregateInput = {
    term?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ScheduleItemCountOrderByAggregateInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrder
    active?: SortOrder
    date?: SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduleItemAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type ScheduleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrder
    active?: SortOrder
    date?: SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduleItemMinOrderByAggregateInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrder
    active?: SortOrder
    date?: SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduleItemSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type WeeklyMessageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageRelationFilter = {
    is?: WeeklyMessageWhereInput
    isNot?: WeeklyMessageWhereInput
  }

  export type WeeklyMessageHeartMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type WeeklyMessageHeartCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageHeartMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageHeartMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeArticleListRelationFilter = {
    every?: KnowledgeArticleWhereInput
    some?: KnowledgeArticleWhereInput
    none?: KnowledgeArticleWhereInput
  }

  export type KnowledgeArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
  }

  export type KnowledgeCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type KnowledgeCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
  }

  export type KnowledgeCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
  }

  export type KnowledgeCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type KnowledgeCategoryRelationFilter = {
    is?: KnowledgeCategoryWhereInput
    isNot?: KnowledgeCategoryWhereInput
  }

  export type KnowledgeArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseSurveyCountOrderByAggregateInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseSurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseSurveyMinOrderByAggregateInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseSurveyRelationFilter = {
    is?: PulseSurveyWhereInput
    isNot?: PulseSurveyWhereInput
  }

  export type PulseResponsePulseIdUserIdCompoundUniqueInput = {
    pulseId: string
    userId: string
  }

  export type PulseResponseCountOrderByAggregateInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseResponseMinOrderByAggregateInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type FileFolderNullableRelationFilter = {
    is?: FileFolderWhereInput | null
    isNot?: FileFolderWhereInput | null
  }

  export type FileFolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FileFolderAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FileFolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FileFolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FileFolderSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SchoolFileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolFileAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type SchoolFileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolFileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolFileSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSchoolInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SurveyCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SurveyCreateWithoutSchoolInput, SurveyUncheckedCreateWithoutSchoolInput> | SurveyCreateWithoutSchoolInput[] | SurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSchoolInput | SurveyCreateOrConnectWithoutSchoolInput[]
    createMany?: SurveyCreateManySchoolInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type TermDateCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type WeeklyMessageCreateNestedManyWithoutSchoolInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
  }

  export type KnowledgeCategoryCreateNestedManyWithoutSchoolInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
  }

  export type PulseSurveyCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
  }

  export type PolicyCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type FileFolderCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolFileCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SurveyCreateWithoutSchoolInput, SurveyUncheckedCreateWithoutSchoolInput> | SurveyCreateWithoutSchoolInput[] | SurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSchoolInput | SurveyCreateOrConnectWithoutSchoolInput[]
    createMany?: SurveyCreateManySchoolInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type TermDateUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
  }

  export type KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
  }

  export type PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type FileFolderUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolFileUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSchoolInput | MessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSchoolInput | MessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSchoolInput | MessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SurveyUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SurveyCreateWithoutSchoolInput, SurveyUncheckedCreateWithoutSchoolInput> | SurveyCreateWithoutSchoolInput[] | SurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSchoolInput | SurveyCreateOrConnectWithoutSchoolInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutSchoolInput | SurveyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SurveyCreateManySchoolInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutSchoolInput | SurveyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutSchoolInput | SurveyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type EventUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSchoolInput | EventUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSchoolInput | EventUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSchoolInput | EventUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type TermDateUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    upsert?: TermDateUpsertWithWhereUniqueWithoutSchoolInput | TermDateUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    set?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    disconnect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    delete?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    update?: TermDateUpdateWithWhereUniqueWithoutSchoolInput | TermDateUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TermDateUpdateManyWithWhereWithoutSchoolInput | TermDateUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput | ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput | ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutSchoolInput | ScheduleItemUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type WeeklyMessageUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    upsert?: WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    set?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    disconnect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    delete?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    update?: WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: WeeklyMessageUpdateManyWithWhereWithoutSchoolInput | WeeklyMessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
  }

  export type KnowledgeCategoryUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    upsert?: KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    set?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    disconnect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    delete?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    update?: KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput | KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
  }

  export type PulseSurveyUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    upsert?: PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput | PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    set?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    disconnect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    delete?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    update?: PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput | PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PulseSurveyUpdateManyWithWhereWithoutSchoolInput | PulseSurveyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
  }

  export type PolicyUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutSchoolInput | PolicyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutSchoolInput | PolicyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutSchoolInput | PolicyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type FileFolderUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutSchoolInput | FileFolderUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutSchoolInput | FileFolderUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutSchoolInput | FileFolderUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolFileUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutSchoolInput | SchoolFileUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutSchoolInput | SchoolFileUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutSchoolInput | SchoolFileUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSchoolInput | MessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSchoolInput | MessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSchoolInput | MessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SurveyCreateWithoutSchoolInput, SurveyUncheckedCreateWithoutSchoolInput> | SurveyCreateWithoutSchoolInput[] | SurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutSchoolInput | SurveyCreateOrConnectWithoutSchoolInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutSchoolInput | SurveyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SurveyCreateManySchoolInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutSchoolInput | SurveyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutSchoolInput | SurveyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSchoolInput | EventUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSchoolInput | EventUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSchoolInput | EventUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type TermDateUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    upsert?: TermDateUpsertWithWhereUniqueWithoutSchoolInput | TermDateUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    set?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    disconnect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    delete?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    update?: TermDateUpdateWithWhereUniqueWithoutSchoolInput | TermDateUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TermDateUpdateManyWithWhereWithoutSchoolInput | TermDateUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput | ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput | ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutSchoolInput | ScheduleItemUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    upsert?: WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    set?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    disconnect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    delete?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    update?: WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: WeeklyMessageUpdateManyWithWhereWithoutSchoolInput | WeeklyMessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
  }

  export type KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    upsert?: KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    set?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    disconnect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    delete?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    update?: KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput | KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
  }

  export type PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    upsert?: PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput | PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    set?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    disconnect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    delete?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    update?: PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput | PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PulseSurveyUpdateManyWithWhereWithoutSchoolInput | PulseSurveyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutSchoolInput | PolicyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutSchoolInput | PolicyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutSchoolInput | PolicyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type FileFolderUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutSchoolInput | FileFolderUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutSchoolInput | FileFolderUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutSchoolInput | FileFolderUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutSchoolInput | SchoolFileUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutSchoolInput | SchoolFileUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutSchoolInput | SchoolFileUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type ChildCreateNestedManyWithoutParentInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type MessageAcknowledgmentCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type SurveyResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<SurveyResponseCreateWithoutUserInput, SurveyResponseUncheckedCreateWithoutUserInput> | SurveyResponseCreateWithoutUserInput[] | SurveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserInput | SurveyResponseCreateOrConnectWithoutUserInput[]
    createMany?: SurveyResponseCreateManyUserInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type EventRsvpCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type PulseResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type WeeklyMessageHeartCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type ChildUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type SurveyResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SurveyResponseCreateWithoutUserInput, SurveyResponseUncheckedCreateWithoutUserInput> | SurveyResponseCreateWithoutUserInput[] | SurveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserInput | SurveyResponseCreateOrConnectWithoutUserInput[]
    createMany?: SurveyResponseCreateManyUserInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type EventRsvpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type PulseResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type SchoolUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type ChildUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutParentInput | ChildUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutParentInput | ChildUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutParentInput | ChildUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type MessageAcknowledgmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput | MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type SurveyResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutUserInput, SurveyResponseUncheckedCreateWithoutUserInput> | SurveyResponseCreateWithoutUserInput[] | SurveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserInput | SurveyResponseCreateOrConnectWithoutUserInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutUserInput | SurveyResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SurveyResponseCreateManyUserInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutUserInput | SurveyResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutUserInput | SurveyResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type EventRsvpUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutUserInput | EventRsvpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutUserInput | EventRsvpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutUserInput | EventRsvpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type PulseResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutUserInput | PulseResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutUserInput | PulseResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutUserInput | PulseResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type WeeklyMessageHeartUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput | WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type ChildUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutParentInput | ChildUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutParentInput | ChildUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutParentInput | ChildUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput | MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type SurveyResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutUserInput, SurveyResponseUncheckedCreateWithoutUserInput> | SurveyResponseCreateWithoutUserInput[] | SurveyResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserInput | SurveyResponseCreateOrConnectWithoutUserInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutUserInput | SurveyResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SurveyResponseCreateManyUserInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutUserInput | SurveyResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutUserInput | SurveyResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type EventRsvpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutUserInput | EventRsvpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutUserInput | EventRsvpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutUserInput | EventRsvpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type PulseResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutUserInput | PulseResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutUserInput | PulseResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutUserInput | PulseResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput | WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutChildrenInput = {
    create?: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: UserCreateOrConnectWithoutChildrenInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ClassCreateOrConnectWithoutChildrenInput
    connect?: ClassWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: UserCreateOrConnectWithoutChildrenInput
    upsert?: UserUpsertWithoutChildrenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChildrenInput, UserUpdateWithoutChildrenInput>, UserUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ClassCreateOrConnectWithoutChildrenInput
    upsert?: ClassUpsertWithoutChildrenInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutChildrenInput, ClassUpdateWithoutChildrenInput>, ClassUncheckedUpdateWithoutChildrenInput>
  }

  export type SchoolCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    connect?: SchoolWhereUniqueInput
  }

  export type ChildCreateNestedManyWithoutClassInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutClassInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SurveyCreateNestedManyWithoutClassInput = {
    create?: XOR<SurveyCreateWithoutClassInput, SurveyUncheckedCreateWithoutClassInput> | SurveyCreateWithoutClassInput[] | SurveyUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutClassInput | SurveyCreateOrConnectWithoutClassInput[]
    createMany?: SurveyCreateManyClassInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutClassInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutClassInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type ChildUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<SurveyCreateWithoutClassInput, SurveyUncheckedCreateWithoutClassInput> | SurveyCreateWithoutClassInput[] | SurveyUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutClassInput | SurveyCreateOrConnectWithoutClassInput[]
    createMany?: SurveyCreateManyClassInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    upsert?: SchoolUpsertWithoutClassesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassesInput, SchoolUpdateWithoutClassesInput>, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type ChildUpdateManyWithoutClassNestedInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutClassInput | ChildUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutClassInput | ChildUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutClassInput | ChildUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutClassNestedInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClassInput | MessageUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClassInput | MessageUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClassInput | MessageUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SurveyUpdateManyWithoutClassNestedInput = {
    create?: XOR<SurveyCreateWithoutClassInput, SurveyUncheckedCreateWithoutClassInput> | SurveyCreateWithoutClassInput[] | SurveyUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutClassInput | SurveyCreateOrConnectWithoutClassInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutClassInput | SurveyUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SurveyCreateManyClassInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutClassInput | SurveyUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutClassInput | SurveyUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type EventUpdateManyWithoutClassNestedInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutClassInput | EventUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutClassInput | EventUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EventUpdateManyWithWhereWithoutClassInput | EventUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutClassNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutClassInput | ScheduleItemUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutClassInput | ScheduleItemUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutClassInput | ScheduleItemUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type ChildUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutClassInput | ChildUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutClassInput | ChildUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutClassInput | ChildUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClassInput | MessageUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClassInput | MessageUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClassInput | MessageUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<SurveyCreateWithoutClassInput, SurveyUncheckedCreateWithoutClassInput> | SurveyCreateWithoutClassInput[] | SurveyUncheckedCreateWithoutClassInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutClassInput | SurveyCreateOrConnectWithoutClassInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutClassInput | SurveyUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: SurveyCreateManyClassInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutClassInput | SurveyUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutClassInput | SurveyUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutClassInput | EventUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutClassInput | EventUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EventUpdateManyWithWhereWithoutClassInput | EventUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutClassInput | ScheduleItemUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutClassInput | ScheduleItemUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutClassInput | ScheduleItemUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMessagesInput
    connect?: ClassWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutMessagesInput
    connect?: SchoolWhereUniqueInput
  }

  export type MessageAcknowledgmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClassUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMessagesInput
    upsert?: ClassUpsertWithoutMessagesInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutMessagesInput, ClassUpdateWithoutMessagesInput>, ClassUncheckedUpdateWithoutMessagesInput>
  }

  export type SchoolUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutMessagesInput
    upsert?: SchoolUpsertWithoutMessagesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutMessagesInput, SchoolUpdateWithoutMessagesInput>, SchoolUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageAcknowledgmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput | MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput | MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAcknowledgmentsInput = {
    create?: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAcknowledgmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageAcksInput = {
    create?: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageAcksInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAcknowledgmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAcknowledgmentsInput
    upsert?: MessageUpsertWithoutAcknowledgmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAcknowledgmentsInput, MessageUpdateWithoutAcknowledgmentsInput>, MessageUncheckedUpdateWithoutAcknowledgmentsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageAcksNestedInput = {
    create?: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageAcksInput
    upsert?: UserUpsertWithoutMessageAcksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageAcksInput, UserUpdateWithoutMessageAcksInput>, UserUncheckedUpdateWithoutMessageAcksInput>
  }

  export type ClassCreateNestedOneWithoutSurveysInput = {
    create?: XOR<ClassCreateWithoutSurveysInput, ClassUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSurveysInput
    connect?: ClassWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutSurveysInput = {
    create?: XOR<SchoolCreateWithoutSurveysInput, SchoolUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSurveysInput
    connect?: SchoolWhereUniqueInput
  }

  export type SurveyResponseCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type ClassUpdateOneWithoutSurveysNestedInput = {
    create?: XOR<ClassCreateWithoutSurveysInput, ClassUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSurveysInput
    upsert?: ClassUpsertWithoutSurveysInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSurveysInput, ClassUpdateWithoutSurveysInput>, ClassUncheckedUpdateWithoutSurveysInput>
  }

  export type SchoolUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<SchoolCreateWithoutSurveysInput, SchoolUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSurveysInput
    upsert?: SchoolUpsertWithoutSurveysInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSurveysInput, SchoolUpdateWithoutSurveysInput>, SchoolUncheckedUpdateWithoutSurveysInput>
  }

  export type SurveyResponseUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput | SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput | SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutSurveyInput | SurveyResponseUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput | SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput | SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutSurveyInput | SurveyResponseUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type SurveyCreateNestedOneWithoutResponsesInput = {
    create?: XOR<SurveyCreateWithoutResponsesInput, SurveyUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutResponsesInput
    connect?: SurveyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSurveyResponsesInput = {
    create?: XOR<UserCreateWithoutSurveyResponsesInput, UserUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSurveyResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type SurveyUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<SurveyCreateWithoutResponsesInput, SurveyUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutResponsesInput
    upsert?: SurveyUpsertWithoutResponsesInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutResponsesInput, SurveyUpdateWithoutResponsesInput>, SurveyUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutSurveyResponsesNestedInput = {
    create?: XOR<UserCreateWithoutSurveyResponsesInput, UserUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSurveyResponsesInput
    upsert?: UserUpsertWithoutSurveyResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSurveyResponsesInput, UserUpdateWithoutSurveyResponsesInput>, UserUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type ClassCreateNestedOneWithoutEventsInput = {
    create?: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEventsInput
    connect?: ClassWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutEventsInput = {
    create?: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEventsInput
    connect?: SchoolWhereUniqueInput
  }

  export type EventRsvpCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type EventRsvpUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type ClassUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEventsInput
    upsert?: ClassUpsertWithoutEventsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutEventsInput, ClassUpdateWithoutEventsInput>, ClassUncheckedUpdateWithoutEventsInput>
  }

  export type SchoolUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEventsInput
    upsert?: SchoolUpsertWithoutEventsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEventsInput, SchoolUpdateWithoutEventsInput>, SchoolUncheckedUpdateWithoutEventsInput>
  }

  export type EventRsvpUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutEventInput | EventRsvpUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutEventInput | EventRsvpUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutEventInput | EventRsvpUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type EventRsvpUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutEventInput | EventRsvpUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutEventInput | EventRsvpUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutEventInput | EventRsvpUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutRsvpsInput = {
    create?: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRsvpsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventRsvpsInput = {
    create?: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRsvpsInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutRsvpsNestedInput = {
    create?: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRsvpsInput
    upsert?: EventUpsertWithoutRsvpsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutRsvpsInput, EventUpdateWithoutRsvpsInput>, EventUncheckedUpdateWithoutRsvpsInput>
  }

  export type UserUpdateOneRequiredWithoutEventRsvpsNestedInput = {
    create?: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRsvpsInput
    upsert?: UserUpsertWithoutEventRsvpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventRsvpsInput, UserUpdateWithoutEventRsvpsInput>, UserUncheckedUpdateWithoutEventRsvpsInput>
  }

  export type SchoolCreateNestedOneWithoutTermDatesInput = {
    create?: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTermDatesInput
    connect?: SchoolWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SchoolUpdateOneRequiredWithoutTermDatesNestedInput = {
    create?: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTermDatesInput
    upsert?: SchoolUpsertWithoutTermDatesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTermDatesInput, SchoolUpdateWithoutTermDatesInput>, SchoolUncheckedUpdateWithoutTermDatesInput>
  }

  export type ClassCreateNestedOneWithoutScheduleItemsInput = {
    create?: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutScheduleItemsInput
    connect?: ClassWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutScheduleItemsInput = {
    create?: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutScheduleItemsInput
    connect?: SchoolWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassUpdateOneWithoutScheduleItemsNestedInput = {
    create?: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutScheduleItemsInput
    upsert?: ClassUpsertWithoutScheduleItemsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutScheduleItemsInput, ClassUpdateWithoutScheduleItemsInput>, ClassUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type SchoolUpdateOneRequiredWithoutScheduleItemsNestedInput = {
    create?: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutScheduleItemsInput
    upsert?: SchoolUpsertWithoutScheduleItemsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutScheduleItemsInput, SchoolUpdateWithoutScheduleItemsInput>, SchoolUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type SchoolCreateNestedOneWithoutWeeklyMessagesInput = {
    create?: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutWeeklyMessagesInput
    connect?: SchoolWhereUniqueInput
  }

  export type WeeklyMessageHeartCreateNestedManyWithoutMessageInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type WeeklyMessageHeartUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutWeeklyMessagesNestedInput = {
    create?: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutWeeklyMessagesInput
    upsert?: SchoolUpsertWithoutWeeklyMessagesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutWeeklyMessagesInput, SchoolUpdateWithoutWeeklyMessagesInput>, SchoolUncheckedUpdateWithoutWeeklyMessagesInput>
  }

  export type WeeklyMessageHeartUpdateManyWithoutMessageNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput | WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput | WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type WeeklyMessageCreateNestedOneWithoutHeartsInput = {
    create?: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutHeartsInput
    connect?: WeeklyMessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWeeklyHeartsInput = {
    create?: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeeklyHeartsInput
    connect?: UserWhereUniqueInput
  }

  export type WeeklyMessageUpdateOneRequiredWithoutHeartsNestedInput = {
    create?: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutHeartsInput
    upsert?: WeeklyMessageUpsertWithoutHeartsInput
    connect?: WeeklyMessageWhereUniqueInput
    update?: XOR<XOR<WeeklyMessageUpdateToOneWithWhereWithoutHeartsInput, WeeklyMessageUpdateWithoutHeartsInput>, WeeklyMessageUncheckedUpdateWithoutHeartsInput>
  }

  export type UserUpdateOneRequiredWithoutWeeklyHeartsNestedInput = {
    create?: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeeklyHeartsInput
    upsert?: UserUpsertWithoutWeeklyHeartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWeeklyHeartsInput, UserUpdateWithoutWeeklyHeartsInput>, UserUncheckedUpdateWithoutWeeklyHeartsInput>
  }

  export type SchoolCreateNestedOneWithoutKnowledgeCategoriesInput = {
    create?: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutKnowledgeCategoriesInput
    connect?: SchoolWhereUniqueInput
  }

  export type KnowledgeArticleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
  }

  export type KnowledgeArticleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutKnowledgeCategoriesNestedInput = {
    create?: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutKnowledgeCategoriesInput
    upsert?: SchoolUpsertWithoutKnowledgeCategoriesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutKnowledgeCategoriesInput, SchoolUpdateWithoutKnowledgeCategoriesInput>, SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput>
  }

  export type KnowledgeArticleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    set?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    disconnect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    delete?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    update?: KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput | KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
  }

  export type KnowledgeArticleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    set?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    disconnect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    delete?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    update?: KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput | KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
  }

  export type KnowledgeCategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutArticlesInput
    connect?: KnowledgeCategoryWhereUniqueInput
  }

  export type KnowledgeCategoryUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutArticlesInput
    upsert?: KnowledgeCategoryUpsertWithoutArticlesInput
    connect?: KnowledgeCategoryWhereUniqueInput
    update?: XOR<XOR<KnowledgeCategoryUpdateToOneWithWhereWithoutArticlesInput, KnowledgeCategoryUpdateWithoutArticlesInput>, KnowledgeCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type SchoolCreateNestedOneWithoutPulseSurveysInput = {
    create?: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPulseSurveysInput
    connect?: SchoolWhereUniqueInput
  }

  export type PulseResponseCreateNestedManyWithoutPulseInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type PulseResponseUncheckedCreateNestedManyWithoutPulseInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutPulseSurveysNestedInput = {
    create?: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPulseSurveysInput
    upsert?: SchoolUpsertWithoutPulseSurveysInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutPulseSurveysInput, SchoolUpdateWithoutPulseSurveysInput>, SchoolUncheckedUpdateWithoutPulseSurveysInput>
  }

  export type PulseResponseUpdateManyWithoutPulseNestedInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutPulseInput | PulseResponseUpsertWithWhereUniqueWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutPulseInput | PulseResponseUpdateWithWhereUniqueWithoutPulseInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutPulseInput | PulseResponseUpdateManyWithWhereWithoutPulseInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type PulseResponseUncheckedUpdateManyWithoutPulseNestedInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutPulseInput | PulseResponseUpsertWithWhereUniqueWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutPulseInput | PulseResponseUpdateWithWhereUniqueWithoutPulseInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutPulseInput | PulseResponseUpdateManyWithWhereWithoutPulseInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type PulseSurveyCreateNestedOneWithoutResponsesInput = {
    create?: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutResponsesInput
    connect?: PulseSurveyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPulseResponsesInput = {
    create?: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPulseResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type PulseSurveyUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutResponsesInput
    upsert?: PulseSurveyUpsertWithoutResponsesInput
    connect?: PulseSurveyWhereUniqueInput
    update?: XOR<XOR<PulseSurveyUpdateToOneWithWhereWithoutResponsesInput, PulseSurveyUpdateWithoutResponsesInput>, PulseSurveyUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutPulseResponsesNestedInput = {
    create?: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPulseResponsesInput
    upsert?: UserUpsertWithoutPulseResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPulseResponsesInput, UserUpdateWithoutPulseResponsesInput>, UserUncheckedUpdateWithoutPulseResponsesInput>
  }

  export type SchoolCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPoliciesInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutPoliciesNestedInput = {
    create?: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPoliciesInput
    upsert?: SchoolUpsertWithoutPoliciesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutPoliciesInput, SchoolUpdateWithoutPoliciesInput>, SchoolUncheckedUpdateWithoutPoliciesInput>
  }

  export type FileFolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutChildrenInput
    connect?: FileFolderWhereUniqueInput
  }

  export type FileFolderCreateNestedManyWithoutParentInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutFoldersInput = {
    create?: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFoldersInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolFileCreateNestedManyWithoutFolderInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type FileFolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolFileUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type FileFolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutChildrenInput
    upsert?: FileFolderUpsertWithoutChildrenInput
    disconnect?: FileFolderWhereInput | boolean
    delete?: FileFolderWhereInput | boolean
    connect?: FileFolderWhereUniqueInput
    update?: XOR<XOR<FileFolderUpdateToOneWithWhereWithoutChildrenInput, FileFolderUpdateWithoutChildrenInput>, FileFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FileFolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutParentInput | FileFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutParentInput | FileFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutParentInput | FileFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFoldersInput
    upsert?: SchoolUpsertWithoutFoldersInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFoldersInput, SchoolUpdateWithoutFoldersInput>, SchoolUncheckedUpdateWithoutFoldersInput>
  }

  export type SchoolFileUpdateManyWithoutFolderNestedInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutFolderInput | SchoolFileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutFolderInput | SchoolFileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutFolderInput | SchoolFileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type FileFolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutParentInput | FileFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutParentInput | FileFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutParentInput | FileFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolFileUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutFolderInput | SchoolFileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutFolderInput | SchoolFileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutFolderInput | SchoolFileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type FileFolderCreateNestedOneWithoutFilesInput = {
    create?: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutFilesInput
    connect?: FileFolderWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutFilesInput = {
    create?: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFilesInput
    connect?: SchoolWhereUniqueInput
  }

  export type FileFolderUpdateOneWithoutFilesNestedInput = {
    create?: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutFilesInput
    upsert?: FileFolderUpsertWithoutFilesInput
    disconnect?: FileFolderWhereInput | boolean
    delete?: FileFolderWhereInput | boolean
    connect?: FileFolderWhereUniqueInput
    update?: XOR<XOR<FileFolderUpdateToOneWithWhereWithoutFilesInput, FileFolderUpdateWithoutFilesInput>, FileFolderUncheckedUpdateWithoutFilesInput>
  }

  export type SchoolUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFilesInput
    upsert?: SchoolUpsertWithoutFilesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFilesInput, SchoolUpdateWithoutFilesInput>, SchoolUncheckedUpdateWithoutFilesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutSchoolInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    children?: ChildCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    surveys?: SurveyCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateManySchoolInputEnvelope = {
    data: ClassCreateManySchoolInput | ClassCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSchoolInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput>
  }

  export type MessageCreateManySchoolInputEnvelope = {
    data: MessageCreateManySchoolInput | MessageCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SurveyCreateWithoutSchoolInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutSurveysInput
    responses?: SurveyResponseCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutSchoolInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    classId?: string | null
    createdAt?: Date | string
    responses?: SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutSchoolInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutSchoolInput, SurveyUncheckedCreateWithoutSchoolInput>
  }

  export type SurveyCreateManySchoolInputEnvelope = {
    data: SurveyCreateManySchoolInput | SurveyCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutEventsInput
    rsvps?: EventRsvpCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    requiresRsvp?: boolean
    createdAt?: Date | string
    rsvps?: EventRsvpUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutSchoolInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput>
  }

  export type EventCreateManySchoolInputEnvelope = {
    data: EventCreateManySchoolInput | EventCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type TermDateCreateWithoutSchoolInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
  }

  export type TermDateUncheckedCreateWithoutSchoolInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
  }

  export type TermDateCreateOrConnectWithoutSchoolInput = {
    where: TermDateWhereUniqueInput
    create: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput>
  }

  export type TermDateCreateManySchoolInputEnvelope = {
    data: TermDateCreateManySchoolInput | TermDateCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleItemCreateWithoutSchoolInput = {
    id?: string
    targetClass: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutScheduleItemsInput
  }

  export type ScheduleItemUncheckedCreateWithoutSchoolInput = {
    id?: string
    targetClass: string
    classId?: string | null
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemCreateOrConnectWithoutSchoolInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput>
  }

  export type ScheduleItemCreateManySchoolInputEnvelope = {
    data: ScheduleItemCreateManySchoolInput | ScheduleItemCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyMessageCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    hearts?: WeeklyMessageHeartCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    hearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageCreateOrConnectWithoutSchoolInput = {
    where: WeeklyMessageWhereUniqueInput
    create: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput>
  }

  export type WeeklyMessageCreateManySchoolInputEnvelope = {
    data: WeeklyMessageCreateManySchoolInput | WeeklyMessageCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeCategoryCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    articles?: KnowledgeArticleCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    articles?: KnowledgeArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryCreateOrConnectWithoutSchoolInput = {
    where: KnowledgeCategoryWhereUniqueInput
    create: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput>
  }

  export type KnowledgeCategoryCreateManySchoolInputEnvelope = {
    data: KnowledgeCategoryCreateManySchoolInput | KnowledgeCategoryCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type PulseSurveyCreateWithoutSchoolInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    createdAt?: Date | string
    responses?: PulseResponseCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyUncheckedCreateWithoutSchoolInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    createdAt?: Date | string
    responses?: PulseResponseUncheckedCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyCreateOrConnectWithoutSchoolInput = {
    where: PulseSurveyWhereUniqueInput
    create: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput>
  }

  export type PulseSurveyCreateManySchoolInputEnvelope = {
    data: PulseSurveyCreateManySchoolInput | PulseSurveyCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type PolicyCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyCreateOrConnectWithoutSchoolInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput>
  }

  export type PolicyCreateManySchoolInputEnvelope = {
    data: PolicyCreateManySchoolInput | PolicyCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type FileFolderCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    children?: FileFolderCreateNestedManyWithoutParentInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderCreateOrConnectWithoutSchoolInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput>
  }

  export type FileFolderCreateManySchoolInputEnvelope = {
    data: FileFolderCreateManySchoolInput | FileFolderCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolFileCreateWithoutSchoolInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    folder?: FileFolderCreateNestedOneWithoutFilesInput
  }

  export type SchoolFileUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileCreateOrConnectWithoutSchoolInput = {
    where: SchoolFileWhereUniqueInput
    create: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolFileCreateManySchoolInputEnvelope = {
    data: SchoolFileCreateManySchoolInput | SchoolFileCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    googleId?: StringNullableFilter<"User"> | string | null
    microsoftId?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    colorBg?: StringFilter<"Class"> | string
    colorText?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSchoolInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSchoolInput, MessageUncheckedUpdateWithoutSchoolInput>
    create: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSchoolInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSchoolInput, MessageUncheckedUpdateWithoutSchoolInput>
  }

  export type MessageUpdateManyWithWhereWithoutSchoolInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSchoolInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    title?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    targetClass?: StringFilter<"Message"> | string
    classId?: StringNullableFilter<"Message"> | string | null
    schoolId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderName?: StringFilter<"Message"> | string
    actionType?: StringNullableFilter<"Message"> | string | null
    actionLabel?: StringNullableFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    isUrgent?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type SurveyUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutSchoolInput, SurveyUncheckedUpdateWithoutSchoolInput>
    create: XOR<SurveyCreateWithoutSchoolInput, SurveyUncheckedCreateWithoutSchoolInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutSchoolInput, SurveyUncheckedUpdateWithoutSchoolInput>
  }

  export type SurveyUpdateManyWithWhereWithoutSchoolInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SurveyScalarWhereInput = {
    AND?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
    OR?: SurveyScalarWhereInput[]
    NOT?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
    id?: StringFilter<"Survey"> | string
    question?: StringFilter<"Survey"> | string
    options?: JsonFilter<"Survey">
    active?: BoolFilter<"Survey"> | boolean
    targetClass?: StringFilter<"Survey"> | string
    classId?: StringNullableFilter<"Survey"> | string | null
    schoolId?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutSchoolInput, EventUncheckedUpdateWithoutSchoolInput>
    create: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput>
  }

  export type EventUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutSchoolInput, EventUncheckedUpdateWithoutSchoolInput>
  }

  export type EventUpdateManyWithWhereWithoutSchoolInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    targetClass?: StringFilter<"Event"> | string
    classId?: StringNullableFilter<"Event"> | string | null
    schoolId?: StringFilter<"Event"> | string
    requiresRsvp?: BoolFilter<"Event"> | boolean
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type TermDateUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TermDateWhereUniqueInput
    update: XOR<TermDateUpdateWithoutSchoolInput, TermDateUncheckedUpdateWithoutSchoolInput>
    create: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput>
  }

  export type TermDateUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TermDateWhereUniqueInput
    data: XOR<TermDateUpdateWithoutSchoolInput, TermDateUncheckedUpdateWithoutSchoolInput>
  }

  export type TermDateUpdateManyWithWhereWithoutSchoolInput = {
    where: TermDateScalarWhereInput
    data: XOR<TermDateUpdateManyMutationInput, TermDateUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TermDateScalarWhereInput = {
    AND?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
    OR?: TermDateScalarWhereInput[]
    NOT?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
    id?: StringFilter<"TermDate"> | string
    term?: IntFilter<"TermDate"> | number
    termName?: StringFilter<"TermDate"> | string
    label?: StringFilter<"TermDate"> | string
    sublabel?: StringNullableFilter<"TermDate"> | string | null
    date?: DateTimeFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableFilter<"TermDate"> | Date | string | null
    type?: StringFilter<"TermDate"> | string
    color?: StringFilter<"TermDate"> | string
    schoolId?: StringFilter<"TermDate"> | string
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutSchoolInput, ScheduleItemUncheckedUpdateWithoutSchoolInput>
    create: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutSchoolInput, ScheduleItemUncheckedUpdateWithoutSchoolInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutSchoolInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ScheduleItemScalarWhereInput = {
    AND?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
    OR?: ScheduleItemScalarWhereInput[]
    NOT?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
    id?: StringFilter<"ScheduleItem"> | string
    targetClass?: StringFilter<"ScheduleItem"> | string
    classId?: StringNullableFilter<"ScheduleItem"> | string | null
    schoolId?: StringFilter<"ScheduleItem"> | string
    isRecurring?: BoolFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableFilter<"ScheduleItem"> | number | null
    active?: BoolFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableFilter<"ScheduleItem"> | Date | string | null
    type?: StringFilter<"ScheduleItem"> | string
    label?: StringFilter<"ScheduleItem"> | string
    description?: StringNullableFilter<"ScheduleItem"> | string | null
    icon?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
  }

  export type WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput = {
    where: WeeklyMessageWhereUniqueInput
    update: XOR<WeeklyMessageUpdateWithoutSchoolInput, WeeklyMessageUncheckedUpdateWithoutSchoolInput>
    create: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput>
  }

  export type WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput = {
    where: WeeklyMessageWhereUniqueInput
    data: XOR<WeeklyMessageUpdateWithoutSchoolInput, WeeklyMessageUncheckedUpdateWithoutSchoolInput>
  }

  export type WeeklyMessageUpdateManyWithWhereWithoutSchoolInput = {
    where: WeeklyMessageScalarWhereInput
    data: XOR<WeeklyMessageUpdateManyMutationInput, WeeklyMessageUncheckedUpdateManyWithoutSchoolInput>
  }

  export type WeeklyMessageScalarWhereInput = {
    AND?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
    OR?: WeeklyMessageScalarWhereInput[]
    NOT?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
    id?: StringFilter<"WeeklyMessage"> | string
    title?: StringFilter<"WeeklyMessage"> | string
    content?: StringFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolFilter<"WeeklyMessage"> | boolean
    schoolId?: StringFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeFilter<"WeeklyMessage"> | Date | string
  }

  export type KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput = {
    where: KnowledgeCategoryWhereUniqueInput
    update: XOR<KnowledgeCategoryUpdateWithoutSchoolInput, KnowledgeCategoryUncheckedUpdateWithoutSchoolInput>
    create: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput>
  }

  export type KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput = {
    where: KnowledgeCategoryWhereUniqueInput
    data: XOR<KnowledgeCategoryUpdateWithoutSchoolInput, KnowledgeCategoryUncheckedUpdateWithoutSchoolInput>
  }

  export type KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput = {
    where: KnowledgeCategoryScalarWhereInput
    data: XOR<KnowledgeCategoryUpdateManyMutationInput, KnowledgeCategoryUncheckedUpdateManyWithoutSchoolInput>
  }

  export type KnowledgeCategoryScalarWhereInput = {
    AND?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
    OR?: KnowledgeCategoryScalarWhereInput[]
    NOT?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
    id?: StringFilter<"KnowledgeCategory"> | string
    name?: StringFilter<"KnowledgeCategory"> | string
    icon?: StringFilter<"KnowledgeCategory"> | string
    color?: StringFilter<"KnowledgeCategory"> | string
    order?: IntFilter<"KnowledgeCategory"> | number
    schoolId?: StringFilter<"KnowledgeCategory"> | string
  }

  export type PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput = {
    where: PulseSurveyWhereUniqueInput
    update: XOR<PulseSurveyUpdateWithoutSchoolInput, PulseSurveyUncheckedUpdateWithoutSchoolInput>
    create: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput>
  }

  export type PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput = {
    where: PulseSurveyWhereUniqueInput
    data: XOR<PulseSurveyUpdateWithoutSchoolInput, PulseSurveyUncheckedUpdateWithoutSchoolInput>
  }

  export type PulseSurveyUpdateManyWithWhereWithoutSchoolInput = {
    where: PulseSurveyScalarWhereInput
    data: XOR<PulseSurveyUpdateManyMutationInput, PulseSurveyUncheckedUpdateManyWithoutSchoolInput>
  }

  export type PulseSurveyScalarWhereInput = {
    AND?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
    OR?: PulseSurveyScalarWhereInput[]
    NOT?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
    id?: StringFilter<"PulseSurvey"> | string
    halfTermName?: StringFilter<"PulseSurvey"> | string
    status?: StringFilter<"PulseSurvey"> | string
    opensAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    schoolId?: StringFilter<"PulseSurvey"> | string
    createdAt?: DateTimeFilter<"PulseSurvey"> | Date | string
  }

  export type PolicyUpsertWithWhereUniqueWithoutSchoolInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutSchoolInput, PolicyUncheckedUpdateWithoutSchoolInput>
    create: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutSchoolInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutSchoolInput, PolicyUncheckedUpdateWithoutSchoolInput>
  }

  export type PolicyUpdateManyWithWhereWithoutSchoolInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutSchoolInput>
  }

  export type PolicyScalarWhereInput = {
    AND?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    OR?: PolicyScalarWhereInput[]
    NOT?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    id?: StringFilter<"Policy"> | string
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    fileUrl?: StringFilter<"Policy"> | string
    fileSize?: IntNullableFilter<"Policy"> | number | null
    schoolId?: StringFilter<"Policy"> | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    createdAt?: DateTimeFilter<"Policy"> | Date | string
  }

  export type FileFolderUpsertWithWhereUniqueWithoutSchoolInput = {
    where: FileFolderWhereUniqueInput
    update: XOR<FileFolderUpdateWithoutSchoolInput, FileFolderUncheckedUpdateWithoutSchoolInput>
    create: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput>
  }

  export type FileFolderUpdateWithWhereUniqueWithoutSchoolInput = {
    where: FileFolderWhereUniqueInput
    data: XOR<FileFolderUpdateWithoutSchoolInput, FileFolderUncheckedUpdateWithoutSchoolInput>
  }

  export type FileFolderUpdateManyWithWhereWithoutSchoolInput = {
    where: FileFolderScalarWhereInput
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyWithoutSchoolInput>
  }

  export type FileFolderScalarWhereInput = {
    AND?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
    OR?: FileFolderScalarWhereInput[]
    NOT?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
    id?: StringFilter<"FileFolder"> | string
    name?: StringFilter<"FileFolder"> | string
    icon?: StringNullableFilter<"FileFolder"> | string | null
    color?: StringNullableFilter<"FileFolder"> | string | null
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    schoolId?: StringFilter<"FileFolder"> | string
    order?: IntFilter<"FileFolder"> | number
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
  }

  export type SchoolFileUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolFileWhereUniqueInput
    update: XOR<SchoolFileUpdateWithoutSchoolInput, SchoolFileUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolFileUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolFileWhereUniqueInput
    data: XOR<SchoolFileUpdateWithoutSchoolInput, SchoolFileUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolFileUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolFileScalarWhereInput
    data: XOR<SchoolFileUpdateManyMutationInput, SchoolFileUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolFileScalarWhereInput = {
    AND?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
    OR?: SchoolFileScalarWhereInput[]
    NOT?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
    id?: StringFilter<"SchoolFile"> | string
    name?: StringFilter<"SchoolFile"> | string
    fileName?: StringFilter<"SchoolFile"> | string
    fileUrl?: StringFilter<"SchoolFile"> | string
    fileType?: StringFilter<"SchoolFile"> | string
    fileSize?: IntFilter<"SchoolFile"> | number
    folderId?: StringNullableFilter<"SchoolFile"> | string | null
    schoolId?: StringFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolFile"> | Date | string
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type ChildCreateWithoutParentInput = {
    id?: string
    name: string
    class: ClassCreateNestedOneWithoutChildrenInput
  }

  export type ChildUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    classId: string
  }

  export type ChildCreateOrConnectWithoutParentInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput>
  }

  export type ChildCreateManyParentInputEnvelope = {
    data: ChildCreateManyParentInput | ChildCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MessageAcknowledgmentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAcknowledgmentsInput
  }

  export type MessageAcknowledgmentUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentCreateOrConnectWithoutUserInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    create: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput>
  }

  export type MessageAcknowledgmentCreateManyUserInputEnvelope = {
    data: MessageAcknowledgmentCreateManyUserInput | MessageAcknowledgmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseCreateWithoutUserInput = {
    id?: string
    response: string
    createdAt?: Date | string
    survey: SurveyCreateNestedOneWithoutResponsesInput
  }

  export type SurveyResponseUncheckedCreateWithoutUserInput = {
    id?: string
    surveyId: string
    response: string
    createdAt?: Date | string
  }

  export type SurveyResponseCreateOrConnectWithoutUserInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutUserInput, SurveyResponseUncheckedCreateWithoutUserInput>
  }

  export type SurveyResponseCreateManyUserInputEnvelope = {
    data: SurveyResponseCreateManyUserInput | SurveyResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventRsvpCreateWithoutUserInput = {
    id?: string
    status: string
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutRsvpsInput
  }

  export type EventRsvpUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpCreateOrConnectWithoutUserInput = {
    where: EventRsvpWhereUniqueInput
    create: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput>
  }

  export type EventRsvpCreateManyUserInputEnvelope = {
    data: EventRsvpCreateManyUserInput | EventRsvpCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PulseResponseCreateWithoutUserInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pulse: PulseSurveyCreateNestedOneWithoutResponsesInput
  }

  export type PulseResponseUncheckedCreateWithoutUserInput = {
    id?: string
    pulseId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseCreateOrConnectWithoutUserInput = {
    where: PulseResponseWhereUniqueInput
    create: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput>
  }

  export type PulseResponseCreateManyUserInputEnvelope = {
    data: PulseResponseCreateManyUserInput | PulseResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyMessageHeartCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    message: WeeklyMessageCreateNestedOneWithoutHeartsInput
  }

  export type WeeklyMessageHeartUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartCreateOrConnectWithoutUserInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    create: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput>
  }

  export type WeeklyMessageHeartCreateManyUserInputEnvelope = {
    data: WeeklyMessageHeartCreateManyUserInput | WeeklyMessageHeartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ChildUpsertWithWhereUniqueWithoutParentInput = {
    where: ChildWhereUniqueInput
    update: XOR<ChildUpdateWithoutParentInput, ChildUncheckedUpdateWithoutParentInput>
    create: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput>
  }

  export type ChildUpdateWithWhereUniqueWithoutParentInput = {
    where: ChildWhereUniqueInput
    data: XOR<ChildUpdateWithoutParentInput, ChildUncheckedUpdateWithoutParentInput>
  }

  export type ChildUpdateManyWithWhereWithoutParentInput = {
    where: ChildScalarWhereInput
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyWithoutParentInput>
  }

  export type ChildScalarWhereInput = {
    AND?: ChildScalarWhereInput | ChildScalarWhereInput[]
    OR?: ChildScalarWhereInput[]
    NOT?: ChildScalarWhereInput | ChildScalarWhereInput[]
    id?: StringFilter<"Child"> | string
    name?: StringFilter<"Child"> | string
    parentId?: StringFilter<"Child"> | string
    classId?: StringFilter<"Child"> | string
  }

  export type MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    update: XOR<MessageAcknowledgmentUpdateWithoutUserInput, MessageAcknowledgmentUncheckedUpdateWithoutUserInput>
    create: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput>
  }

  export type MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    data: XOR<MessageAcknowledgmentUpdateWithoutUserInput, MessageAcknowledgmentUncheckedUpdateWithoutUserInput>
  }

  export type MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput = {
    where: MessageAcknowledgmentScalarWhereInput
    data: XOR<MessageAcknowledgmentUpdateManyMutationInput, MessageAcknowledgmentUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageAcknowledgmentScalarWhereInput = {
    AND?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
    OR?: MessageAcknowledgmentScalarWhereInput[]
    NOT?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
    id?: StringFilter<"MessageAcknowledgment"> | string
    messageId?: StringFilter<"MessageAcknowledgment"> | string
    userId?: StringFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeFilter<"MessageAcknowledgment"> | Date | string
  }

  export type SurveyResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: SurveyResponseWhereUniqueInput
    update: XOR<SurveyResponseUpdateWithoutUserInput, SurveyResponseUncheckedUpdateWithoutUserInput>
    create: XOR<SurveyResponseCreateWithoutUserInput, SurveyResponseUncheckedCreateWithoutUserInput>
  }

  export type SurveyResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: SurveyResponseWhereUniqueInput
    data: XOR<SurveyResponseUpdateWithoutUserInput, SurveyResponseUncheckedUpdateWithoutUserInput>
  }

  export type SurveyResponseUpdateManyWithWhereWithoutUserInput = {
    where: SurveyResponseScalarWhereInput
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type SurveyResponseScalarWhereInput = {
    AND?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
    OR?: SurveyResponseScalarWhereInput[]
    NOT?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
    id?: StringFilter<"SurveyResponse"> | string
    surveyId?: StringFilter<"SurveyResponse"> | string
    userId?: StringFilter<"SurveyResponse"> | string
    response?: StringFilter<"SurveyResponse"> | string
    createdAt?: DateTimeFilter<"SurveyResponse"> | Date | string
  }

  export type EventRsvpUpsertWithWhereUniqueWithoutUserInput = {
    where: EventRsvpWhereUniqueInput
    update: XOR<EventRsvpUpdateWithoutUserInput, EventRsvpUncheckedUpdateWithoutUserInput>
    create: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput>
  }

  export type EventRsvpUpdateWithWhereUniqueWithoutUserInput = {
    where: EventRsvpWhereUniqueInput
    data: XOR<EventRsvpUpdateWithoutUserInput, EventRsvpUncheckedUpdateWithoutUserInput>
  }

  export type EventRsvpUpdateManyWithWhereWithoutUserInput = {
    where: EventRsvpScalarWhereInput
    data: XOR<EventRsvpUpdateManyMutationInput, EventRsvpUncheckedUpdateManyWithoutUserInput>
  }

  export type EventRsvpScalarWhereInput = {
    AND?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
    OR?: EventRsvpScalarWhereInput[]
    NOT?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
    id?: StringFilter<"EventRsvp"> | string
    eventId?: StringFilter<"EventRsvp"> | string
    userId?: StringFilter<"EventRsvp"> | string
    status?: StringFilter<"EventRsvp"> | string
    createdAt?: DateTimeFilter<"EventRsvp"> | Date | string
  }

  export type PulseResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: PulseResponseWhereUniqueInput
    update: XOR<PulseResponseUpdateWithoutUserInput, PulseResponseUncheckedUpdateWithoutUserInput>
    create: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput>
  }

  export type PulseResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: PulseResponseWhereUniqueInput
    data: XOR<PulseResponseUpdateWithoutUserInput, PulseResponseUncheckedUpdateWithoutUserInput>
  }

  export type PulseResponseUpdateManyWithWhereWithoutUserInput = {
    where: PulseResponseScalarWhereInput
    data: XOR<PulseResponseUpdateManyMutationInput, PulseResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type PulseResponseScalarWhereInput = {
    AND?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
    OR?: PulseResponseScalarWhereInput[]
    NOT?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
    id?: StringFilter<"PulseResponse"> | string
    pulseId?: StringFilter<"PulseResponse"> | string
    userId?: StringFilter<"PulseResponse"> | string
    answers?: JsonFilter<"PulseResponse">
    createdAt?: DateTimeFilter<"PulseResponse"> | Date | string
  }

  export type WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    update: XOR<WeeklyMessageHeartUpdateWithoutUserInput, WeeklyMessageHeartUncheckedUpdateWithoutUserInput>
    create: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput>
  }

  export type WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    data: XOR<WeeklyMessageHeartUpdateWithoutUserInput, WeeklyMessageHeartUncheckedUpdateWithoutUserInput>
  }

  export type WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput = {
    where: WeeklyMessageHeartScalarWhereInput
    data: XOR<WeeklyMessageHeartUpdateManyMutationInput, WeeklyMessageHeartUncheckedUpdateManyWithoutUserInput>
  }

  export type WeeklyMessageHeartScalarWhereInput = {
    AND?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
    OR?: WeeklyMessageHeartScalarWhereInput[]
    NOT?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
    id?: StringFilter<"WeeklyMessageHeart"> | string
    messageId?: StringFilter<"WeeklyMessageHeart"> | string
    userId?: StringFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeFilter<"WeeklyMessageHeart"> | Date | string
  }

  export type UserCreateWithoutChildrenInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChildrenInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChildrenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
  }

  export type ClassCreateWithoutChildrenInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    messages?: MessageCreateNestedManyWithoutClassInput
    surveys?: SurveyCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutChildrenInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
  }

  export type UserUpsertWithoutChildrenInput = {
    update: XOR<UserUpdateWithoutChildrenInput, UserUncheckedUpdateWithoutChildrenInput>
    create: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChildrenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChildrenInput, UserUncheckedUpdateWithoutChildrenInput>
  }

  export type UserUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutChildrenInput = {
    update: XOR<ClassUpdateWithoutChildrenInput, ClassUncheckedUpdateWithoutChildrenInput>
    create: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutChildrenInput, ClassUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    surveys?: SurveyUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolCreateWithoutClassesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
  }

  export type ChildCreateWithoutClassInput = {
    id?: string
    name: string
    parent: UserCreateNestedOneWithoutChildrenInput
  }

  export type ChildUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    parentId: string
  }

  export type ChildCreateOrConnectWithoutClassInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput>
  }

  export type ChildCreateManyClassInputEnvelope = {
    data: ChildCreateManyClassInput | ChildCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutClassInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutMessagesInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutClassInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutClassInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput>
  }

  export type MessageCreateManyClassInputEnvelope = {
    data: MessageCreateManyClassInput | MessageCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SurveyCreateWithoutClassInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutSurveysInput
    responses?: SurveyResponseCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutClassInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    schoolId: string
    createdAt?: Date | string
    responses?: SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutClassInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutClassInput, SurveyUncheckedCreateWithoutClassInput>
  }

  export type SurveyCreateManyClassInputEnvelope = {
    data: SurveyCreateManyClassInput | SurveyCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutClassInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutEventsInput
    rsvps?: EventRsvpCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutClassInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    rsvps?: EventRsvpUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutClassInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput>
  }

  export type EventCreateManyClassInputEnvelope = {
    data: EventCreateManyClassInput | EventCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleItemCreateWithoutClassInput = {
    id?: string
    targetClass: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutScheduleItemsInput
  }

  export type ScheduleItemUncheckedCreateWithoutClassInput = {
    id?: string
    targetClass: string
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemCreateOrConnectWithoutClassInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput>
  }

  export type ScheduleItemCreateManyClassInputEnvelope = {
    data: ScheduleItemCreateManyClassInput | ScheduleItemCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutClassesInput = {
    update: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ChildUpsertWithWhereUniqueWithoutClassInput = {
    where: ChildWhereUniqueInput
    update: XOR<ChildUpdateWithoutClassInput, ChildUncheckedUpdateWithoutClassInput>
    create: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput>
  }

  export type ChildUpdateWithWhereUniqueWithoutClassInput = {
    where: ChildWhereUniqueInput
    data: XOR<ChildUpdateWithoutClassInput, ChildUncheckedUpdateWithoutClassInput>
  }

  export type ChildUpdateManyWithWhereWithoutClassInput = {
    where: ChildScalarWhereInput
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyWithoutClassInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutClassInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutClassInput, MessageUncheckedUpdateWithoutClassInput>
    create: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutClassInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutClassInput, MessageUncheckedUpdateWithoutClassInput>
  }

  export type MessageUpdateManyWithWhereWithoutClassInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutClassInput>
  }

  export type SurveyUpsertWithWhereUniqueWithoutClassInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutClassInput, SurveyUncheckedUpdateWithoutClassInput>
    create: XOR<SurveyCreateWithoutClassInput, SurveyUncheckedCreateWithoutClassInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutClassInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutClassInput, SurveyUncheckedUpdateWithoutClassInput>
  }

  export type SurveyUpdateManyWithWhereWithoutClassInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutClassInput>
  }

  export type EventUpsertWithWhereUniqueWithoutClassInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutClassInput, EventUncheckedUpdateWithoutClassInput>
    create: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput>
  }

  export type EventUpdateWithWhereUniqueWithoutClassInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutClassInput, EventUncheckedUpdateWithoutClassInput>
  }

  export type EventUpdateManyWithWhereWithoutClassInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutClassInput>
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutClassInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutClassInput, ScheduleItemUncheckedUpdateWithoutClassInput>
    create: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutClassInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutClassInput, ScheduleItemUncheckedUpdateWithoutClassInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutClassInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassCreateWithoutMessagesInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    surveys?: SurveyCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutMessagesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
  }

  export type SchoolCreateWithoutMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutMessagesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
  }

  export type MessageAcknowledgmentCreateWithoutMessageInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessageAcksInput
  }

  export type MessageAcknowledgmentUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentCreateOrConnectWithoutMessageInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    create: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAcknowledgmentCreateManyMessageInputEnvelope = {
    data: MessageAcknowledgmentCreateManyMessageInput | MessageAcknowledgmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutMessagesInput = {
    update: XOR<ClassUpdateWithoutMessagesInput, ClassUncheckedUpdateWithoutMessagesInput>
    create: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutMessagesInput, ClassUncheckedUpdateWithoutMessagesInput>
  }

  export type ClassUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    surveys?: SurveyUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolUpsertWithoutMessagesInput = {
    update: XOR<SchoolUpdateWithoutMessagesInput, SchoolUncheckedUpdateWithoutMessagesInput>
    create: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutMessagesInput, SchoolUncheckedUpdateWithoutMessagesInput>
  }

  export type SchoolUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    update: XOR<MessageAcknowledgmentUpdateWithoutMessageInput, MessageAcknowledgmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    data: XOR<MessageAcknowledgmentUpdateWithoutMessageInput, MessageAcknowledgmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAcknowledgmentScalarWhereInput
    data: XOR<MessageAcknowledgmentUpdateManyMutationInput, MessageAcknowledgmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutAcknowledgmentsInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutAcknowledgmentsInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutAcknowledgmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
  }

  export type UserCreateWithoutMessageAcksInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageAcksInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageAcksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
  }

  export type MessageUpsertWithoutAcknowledgmentsInput = {
    update: XOR<MessageUpdateWithoutAcknowledgmentsInput, MessageUncheckedUpdateWithoutAcknowledgmentsInput>
    create: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAcknowledgmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAcknowledgmentsInput, MessageUncheckedUpdateWithoutAcknowledgmentsInput>
  }

  export type MessageUpdateWithoutAcknowledgmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutAcknowledgmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessageAcksInput = {
    update: XOR<UserUpdateWithoutMessageAcksInput, UserUncheckedUpdateWithoutMessageAcksInput>
    create: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageAcksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageAcksInput, UserUncheckedUpdateWithoutMessageAcksInput>
  }

  export type UserUpdateWithoutMessageAcksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageAcksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassCreateWithoutSurveysInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSurveysInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSurveysInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSurveysInput, ClassUncheckedCreateWithoutSurveysInput>
  }

  export type SchoolCreateWithoutSurveysInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSurveysInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSurveysInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSurveysInput, SchoolUncheckedCreateWithoutSurveysInput>
  }

  export type SurveyResponseCreateWithoutSurveyInput = {
    id?: string
    response: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSurveyResponsesInput
  }

  export type SurveyResponseUncheckedCreateWithoutSurveyInput = {
    id?: string
    userId: string
    response: string
    createdAt?: Date | string
  }

  export type SurveyResponseCreateOrConnectWithoutSurveyInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyResponseCreateManySurveyInputEnvelope = {
    data: SurveyResponseCreateManySurveyInput | SurveyResponseCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutSurveysInput = {
    update: XOR<ClassUpdateWithoutSurveysInput, ClassUncheckedUpdateWithoutSurveysInput>
    create: XOR<ClassCreateWithoutSurveysInput, ClassUncheckedCreateWithoutSurveysInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSurveysInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSurveysInput, ClassUncheckedUpdateWithoutSurveysInput>
  }

  export type ClassUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolUpsertWithoutSurveysInput = {
    update: XOR<SchoolUpdateWithoutSurveysInput, SchoolUncheckedUpdateWithoutSurveysInput>
    create: XOR<SchoolCreateWithoutSurveysInput, SchoolUncheckedCreateWithoutSurveysInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSurveysInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSurveysInput, SchoolUncheckedUpdateWithoutSurveysInput>
  }

  export type SchoolUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput = {
    where: SurveyResponseWhereUniqueInput
    update: XOR<SurveyResponseUpdateWithoutSurveyInput, SurveyResponseUncheckedUpdateWithoutSurveyInput>
    create: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput = {
    where: SurveyResponseWhereUniqueInput
    data: XOR<SurveyResponseUpdateWithoutSurveyInput, SurveyResponseUncheckedUpdateWithoutSurveyInput>
  }

  export type SurveyResponseUpdateManyWithWhereWithoutSurveyInput = {
    where: SurveyResponseScalarWhereInput
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyWithoutSurveyInput>
  }

  export type SurveyCreateWithoutResponsesInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutSurveysInput
    school: SchoolCreateNestedOneWithoutSurveysInput
  }

  export type SurveyUncheckedCreateWithoutResponsesInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    classId?: string | null
    schoolId: string
    createdAt?: Date | string
  }

  export type SurveyCreateOrConnectWithoutResponsesInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutResponsesInput, SurveyUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutSurveyResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSurveyResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSurveyResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSurveyResponsesInput, UserUncheckedCreateWithoutSurveyResponsesInput>
  }

  export type SurveyUpsertWithoutResponsesInput = {
    update: XOR<SurveyUpdateWithoutResponsesInput, SurveyUncheckedUpdateWithoutResponsesInput>
    create: XOR<SurveyCreateWithoutResponsesInput, SurveyUncheckedCreateWithoutResponsesInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutResponsesInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutResponsesInput, SurveyUncheckedUpdateWithoutResponsesInput>
  }

  export type SurveyUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutSurveysNestedInput
    school?: SchoolUpdateOneRequiredWithoutSurveysNestedInput
  }

  export type SurveyUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSurveyResponsesInput = {
    update: XOR<UserUpdateWithoutSurveyResponsesInput, UserUncheckedUpdateWithoutSurveyResponsesInput>
    create: XOR<UserCreateWithoutSurveyResponsesInput, UserUncheckedCreateWithoutSurveyResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSurveyResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSurveyResponsesInput, UserUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type UserUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassCreateWithoutEventsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    surveys?: SurveyCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutEventsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
  }

  export type SchoolCreateWithoutEventsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEventsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
  }

  export type EventRsvpCreateWithoutEventInput = {
    id?: string
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEventRsvpsInput
  }

  export type EventRsvpUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpCreateOrConnectWithoutEventInput = {
    where: EventRsvpWhereUniqueInput
    create: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput>
  }

  export type EventRsvpCreateManyEventInputEnvelope = {
    data: EventRsvpCreateManyEventInput | EventRsvpCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutEventsInput = {
    update: XOR<ClassUpdateWithoutEventsInput, ClassUncheckedUpdateWithoutEventsInput>
    create: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutEventsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutEventsInput, ClassUncheckedUpdateWithoutEventsInput>
  }

  export type ClassUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    surveys?: SurveyUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolUpsertWithoutEventsInput = {
    update: XOR<SchoolUpdateWithoutEventsInput, SchoolUncheckedUpdateWithoutEventsInput>
    create: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEventsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEventsInput, SchoolUncheckedUpdateWithoutEventsInput>
  }

  export type SchoolUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type EventRsvpUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRsvpWhereUniqueInput
    update: XOR<EventRsvpUpdateWithoutEventInput, EventRsvpUncheckedUpdateWithoutEventInput>
    create: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput>
  }

  export type EventRsvpUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRsvpWhereUniqueInput
    data: XOR<EventRsvpUpdateWithoutEventInput, EventRsvpUncheckedUpdateWithoutEventInput>
  }

  export type EventRsvpUpdateManyWithWhereWithoutEventInput = {
    where: EventRsvpScalarWhereInput
    data: XOR<EventRsvpUpdateManyMutationInput, EventRsvpUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutRsvpsInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutEventsInput
    school: SchoolCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutRsvpsInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
  }

  export type EventCreateOrConnectWithoutRsvpsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
  }

  export type UserCreateWithoutEventRsvpsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventRsvpsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventRsvpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
  }

  export type EventUpsertWithoutRsvpsInput = {
    update: XOR<EventUpdateWithoutRsvpsInput, EventUncheckedUpdateWithoutRsvpsInput>
    create: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutRsvpsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutRsvpsInput, EventUncheckedUpdateWithoutRsvpsInput>
  }

  export type EventUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutEventsNestedInput
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEventRsvpsInput = {
    update: XOR<UserUpdateWithoutEventRsvpsInput, UserUncheckedUpdateWithoutEventRsvpsInput>
    create: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventRsvpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventRsvpsInput, UserUncheckedUpdateWithoutEventRsvpsInput>
  }

  export type UserUpdateWithoutEventRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolCreateWithoutTermDatesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTermDatesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTermDatesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
  }

  export type SchoolUpsertWithoutTermDatesInput = {
    update: XOR<SchoolUpdateWithoutTermDatesInput, SchoolUncheckedUpdateWithoutTermDatesInput>
    create: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTermDatesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTermDatesInput, SchoolUncheckedUpdateWithoutTermDatesInput>
  }

  export type SchoolUpdateWithoutTermDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTermDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    surveys?: SurveyCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutScheduleItemsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
  }

  export type SchoolCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutScheduleItemsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
  }

  export type ClassUpsertWithoutScheduleItemsInput = {
    update: XOR<ClassUpdateWithoutScheduleItemsInput, ClassUncheckedUpdateWithoutScheduleItemsInput>
    create: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutScheduleItemsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutScheduleItemsInput, ClassUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type ClassUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    surveys?: SurveyUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolUpsertWithoutScheduleItemsInput = {
    update: XOR<SchoolUpdateWithoutScheduleItemsInput, SchoolUncheckedUpdateWithoutScheduleItemsInput>
    create: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutScheduleItemsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutScheduleItemsInput, SchoolUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type SchoolUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutWeeklyMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutWeeklyMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutWeeklyMessagesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
  }

  export type WeeklyMessageHeartCreateWithoutMessageInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWeeklyHeartsInput
  }

  export type WeeklyMessageHeartUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartCreateOrConnectWithoutMessageInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    create: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput>
  }

  export type WeeklyMessageHeartCreateManyMessageInputEnvelope = {
    data: WeeklyMessageHeartCreateManyMessageInput | WeeklyMessageHeartCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutWeeklyMessagesInput = {
    update: XOR<SchoolUpdateWithoutWeeklyMessagesInput, SchoolUncheckedUpdateWithoutWeeklyMessagesInput>
    create: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutWeeklyMessagesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutWeeklyMessagesInput, SchoolUncheckedUpdateWithoutWeeklyMessagesInput>
  }

  export type SchoolUpdateWithoutWeeklyMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutWeeklyMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    update: XOR<WeeklyMessageHeartUpdateWithoutMessageInput, WeeklyMessageHeartUncheckedUpdateWithoutMessageInput>
    create: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput>
  }

  export type WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    data: XOR<WeeklyMessageHeartUpdateWithoutMessageInput, WeeklyMessageHeartUncheckedUpdateWithoutMessageInput>
  }

  export type WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput = {
    where: WeeklyMessageHeartScalarWhereInput
    data: XOR<WeeklyMessageHeartUpdateManyMutationInput, WeeklyMessageHeartUncheckedUpdateManyWithoutMessageInput>
  }

  export type WeeklyMessageCreateWithoutHeartsInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutWeeklyMessagesInput
  }

  export type WeeklyMessageUncheckedCreateWithoutHeartsInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageCreateOrConnectWithoutHeartsInput = {
    where: WeeklyMessageWhereUniqueInput
    create: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
  }

  export type UserCreateWithoutWeeklyHeartsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWeeklyHeartsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWeeklyHeartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
  }

  export type WeeklyMessageUpsertWithoutHeartsInput = {
    update: XOR<WeeklyMessageUpdateWithoutHeartsInput, WeeklyMessageUncheckedUpdateWithoutHeartsInput>
    create: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
    where?: WeeklyMessageWhereInput
  }

  export type WeeklyMessageUpdateToOneWithWhereWithoutHeartsInput = {
    where?: WeeklyMessageWhereInput
    data: XOR<WeeklyMessageUpdateWithoutHeartsInput, WeeklyMessageUncheckedUpdateWithoutHeartsInput>
  }

  export type WeeklyMessageUpdateWithoutHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutWeeklyMessagesNestedInput
  }

  export type WeeklyMessageUncheckedUpdateWithoutHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutWeeklyHeartsInput = {
    update: XOR<UserUpdateWithoutWeeklyHeartsInput, UserUncheckedUpdateWithoutWeeklyHeartsInput>
    create: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWeeklyHeartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWeeklyHeartsInput, UserUncheckedUpdateWithoutWeeklyHeartsInput>
  }

  export type UserUpdateWithoutWeeklyHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWeeklyHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolCreateWithoutKnowledgeCategoriesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutKnowledgeCategoriesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutKnowledgeCategoriesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
  }

  export type KnowledgeArticleCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleCreateOrConnectWithoutCategoryInput = {
    where: KnowledgeArticleWhereUniqueInput
    create: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput>
  }

  export type KnowledgeArticleCreateManyCategoryInputEnvelope = {
    data: KnowledgeArticleCreateManyCategoryInput | KnowledgeArticleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutKnowledgeCategoriesInput = {
    update: XOR<SchoolUpdateWithoutKnowledgeCategoriesInput, SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput>
    create: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutKnowledgeCategoriesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutKnowledgeCategoriesInput, SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput>
  }

  export type SchoolUpdateWithoutKnowledgeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: KnowledgeArticleWhereUniqueInput
    update: XOR<KnowledgeArticleUpdateWithoutCategoryInput, KnowledgeArticleUncheckedUpdateWithoutCategoryInput>
    create: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput>
  }

  export type KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: KnowledgeArticleWhereUniqueInput
    data: XOR<KnowledgeArticleUpdateWithoutCategoryInput, KnowledgeArticleUncheckedUpdateWithoutCategoryInput>
  }

  export type KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput = {
    where: KnowledgeArticleScalarWhereInput
    data: XOR<KnowledgeArticleUpdateManyMutationInput, KnowledgeArticleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type KnowledgeArticleScalarWhereInput = {
    AND?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
    OR?: KnowledgeArticleScalarWhereInput[]
    NOT?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
    id?: StringFilter<"KnowledgeArticle"> | string
    title?: StringFilter<"KnowledgeArticle"> | string
    content?: StringFilter<"KnowledgeArticle"> | string
    categoryId?: StringFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
  }

  export type KnowledgeCategoryCreateWithoutArticlesInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    school: SchoolCreateNestedOneWithoutKnowledgeCategoriesInput
  }

  export type KnowledgeCategoryUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    schoolId: string
  }

  export type KnowledgeCategoryCreateOrConnectWithoutArticlesInput = {
    where: KnowledgeCategoryWhereUniqueInput
    create: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
  }

  export type KnowledgeCategoryUpsertWithoutArticlesInput = {
    update: XOR<KnowledgeCategoryUpdateWithoutArticlesInput, KnowledgeCategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
    where?: KnowledgeCategoryWhereInput
  }

  export type KnowledgeCategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: KnowledgeCategoryWhereInput
    data: XOR<KnowledgeCategoryUpdateWithoutArticlesInput, KnowledgeCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type KnowledgeCategoryUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    school?: SchoolUpdateOneRequiredWithoutKnowledgeCategoriesNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolCreateWithoutPulseSurveysInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutPulseSurveysInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutPulseSurveysInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
  }

  export type PulseResponseCreateWithoutPulseInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPulseResponsesInput
  }

  export type PulseResponseUncheckedCreateWithoutPulseInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseCreateOrConnectWithoutPulseInput = {
    where: PulseResponseWhereUniqueInput
    create: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput>
  }

  export type PulseResponseCreateManyPulseInputEnvelope = {
    data: PulseResponseCreateManyPulseInput | PulseResponseCreateManyPulseInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutPulseSurveysInput = {
    update: XOR<SchoolUpdateWithoutPulseSurveysInput, SchoolUncheckedUpdateWithoutPulseSurveysInput>
    create: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutPulseSurveysInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutPulseSurveysInput, SchoolUncheckedUpdateWithoutPulseSurveysInput>
  }

  export type SchoolUpdateWithoutPulseSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutPulseSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type PulseResponseUpsertWithWhereUniqueWithoutPulseInput = {
    where: PulseResponseWhereUniqueInput
    update: XOR<PulseResponseUpdateWithoutPulseInput, PulseResponseUncheckedUpdateWithoutPulseInput>
    create: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput>
  }

  export type PulseResponseUpdateWithWhereUniqueWithoutPulseInput = {
    where: PulseResponseWhereUniqueInput
    data: XOR<PulseResponseUpdateWithoutPulseInput, PulseResponseUncheckedUpdateWithoutPulseInput>
  }

  export type PulseResponseUpdateManyWithWhereWithoutPulseInput = {
    where: PulseResponseScalarWhereInput
    data: XOR<PulseResponseUpdateManyMutationInput, PulseResponseUncheckedUpdateManyWithoutPulseInput>
  }

  export type PulseSurveyCreateWithoutResponsesInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutPulseSurveysInput
  }

  export type PulseSurveyUncheckedCreateWithoutResponsesInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    schoolId: string
    createdAt?: Date | string
  }

  export type PulseSurveyCreateOrConnectWithoutResponsesInput = {
    where: PulseSurveyWhereUniqueInput
    create: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutPulseResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPulseResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPulseResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
  }

  export type PulseSurveyUpsertWithoutResponsesInput = {
    update: XOR<PulseSurveyUpdateWithoutResponsesInput, PulseSurveyUncheckedUpdateWithoutResponsesInput>
    create: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
    where?: PulseSurveyWhereInput
  }

  export type PulseSurveyUpdateToOneWithWhereWithoutResponsesInput = {
    where?: PulseSurveyWhereInput
    data: XOR<PulseSurveyUpdateWithoutResponsesInput, PulseSurveyUncheckedUpdateWithoutResponsesInput>
  }

  export type PulseSurveyUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPulseSurveysNestedInput
  }

  export type PulseSurveyUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPulseResponsesInput = {
    update: XOR<UserUpdateWithoutPulseResponsesInput, UserUncheckedUpdateWithoutPulseResponsesInput>
    create: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPulseResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPulseResponsesInput, UserUncheckedUpdateWithoutPulseResponsesInput>
  }

  export type UserUpdateWithoutPulseResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPulseResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolCreateWithoutPoliciesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutPoliciesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutPoliciesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
  }

  export type SchoolUpsertWithoutPoliciesInput = {
    update: XOR<SchoolUpdateWithoutPoliciesInput, SchoolUncheckedUpdateWithoutPoliciesInput>
    create: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutPoliciesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutPoliciesInput, SchoolUncheckedUpdateWithoutPoliciesInput>
  }

  export type SchoolUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type FileFolderCreateWithoutChildrenInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    school: SchoolCreateNestedOneWithoutFoldersInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderCreateOrConnectWithoutChildrenInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
  }

  export type FileFolderCreateWithoutParentInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    children?: FileFolderCreateNestedManyWithoutParentInput
    school: SchoolCreateNestedOneWithoutFoldersInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderCreateOrConnectWithoutParentInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput>
  }

  export type FileFolderCreateManyParentInputEnvelope = {
    data: FileFolderCreateManyParentInput | FileFolderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutFoldersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFoldersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFoldersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
  }

  export type SchoolFileCreateWithoutFolderInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFilesInput
  }

  export type SchoolFileUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileCreateOrConnectWithoutFolderInput = {
    where: SchoolFileWhereUniqueInput
    create: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput>
  }

  export type SchoolFileCreateManyFolderInputEnvelope = {
    data: SchoolFileCreateManyFolderInput | SchoolFileCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type FileFolderUpsertWithoutChildrenInput = {
    update: XOR<FileFolderUpdateWithoutChildrenInput, FileFolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
    where?: FileFolderWhereInput
  }

  export type FileFolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FileFolderWhereInput
    data: XOR<FileFolderUpdateWithoutChildrenInput, FileFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FileFolderUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUpsertWithWhereUniqueWithoutParentInput = {
    where: FileFolderWhereUniqueInput
    update: XOR<FileFolderUpdateWithoutParentInput, FileFolderUncheckedUpdateWithoutParentInput>
    create: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput>
  }

  export type FileFolderUpdateWithWhereUniqueWithoutParentInput = {
    where: FileFolderWhereUniqueInput
    data: XOR<FileFolderUpdateWithoutParentInput, FileFolderUncheckedUpdateWithoutParentInput>
  }

  export type FileFolderUpdateManyWithWhereWithoutParentInput = {
    where: FileFolderScalarWhereInput
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyWithoutParentInput>
  }

  export type SchoolUpsertWithoutFoldersInput = {
    update: XOR<SchoolUpdateWithoutFoldersInput, SchoolUncheckedUpdateWithoutFoldersInput>
    create: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFoldersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFoldersInput, SchoolUncheckedUpdateWithoutFoldersInput>
  }

  export type SchoolUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolFileUpsertWithWhereUniqueWithoutFolderInput = {
    where: SchoolFileWhereUniqueInput
    update: XOR<SchoolFileUpdateWithoutFolderInput, SchoolFileUncheckedUpdateWithoutFolderInput>
    create: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput>
  }

  export type SchoolFileUpdateWithWhereUniqueWithoutFolderInput = {
    where: SchoolFileWhereUniqueInput
    data: XOR<SchoolFileUpdateWithoutFolderInput, SchoolFileUncheckedUpdateWithoutFolderInput>
  }

  export type SchoolFileUpdateManyWithWhereWithoutFolderInput = {
    where: SchoolFileScalarWhereInput
    data: XOR<SchoolFileUpdateManyMutationInput, SchoolFileUncheckedUpdateManyWithoutFolderInput>
  }

  export type FileFolderCreateWithoutFilesInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    children?: FileFolderCreateNestedManyWithoutParentInput
    school: SchoolCreateNestedOneWithoutFoldersInput
  }

  export type FileFolderUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type FileFolderCreateOrConnectWithoutFilesInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
  }

  export type SchoolCreateWithoutFilesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    surveys?: SurveyCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFilesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
  }

  export type FileFolderUpsertWithoutFilesInput = {
    update: XOR<FileFolderUpdateWithoutFilesInput, FileFolderUncheckedUpdateWithoutFilesInput>
    create: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    where?: FileFolderWhereInput
  }

  export type FileFolderUpdateToOneWithWhereWithoutFilesInput = {
    where?: FileFolderWhereInput
    data: XOR<FileFolderUpdateWithoutFilesInput, FileFolderUncheckedUpdateWithoutFilesInput>
  }

  export type FileFolderUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    children?: FileFolderUpdateManyWithoutParentNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type SchoolUpsertWithoutFilesInput = {
    update: XOR<SchoolUpdateWithoutFilesInput, SchoolUncheckedUpdateWithoutFilesInput>
    create: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFilesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFilesInput, SchoolUncheckedUpdateWithoutFilesInput>
  }

  export type SchoolUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserCreateManySchoolInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type ClassCreateManySchoolInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
  }

  export type MessageCreateManySchoolInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
  }

  export type SurveyCreateManySchoolInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    classId?: string | null
    createdAt?: Date | string
  }

  export type EventCreateManySchoolInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    requiresRsvp?: boolean
    createdAt?: Date | string
  }

  export type TermDateCreateManySchoolInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
  }

  export type ScheduleItemCreateManySchoolInput = {
    id?: string
    targetClass: string
    classId?: string | null
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type WeeklyMessageCreateManySchoolInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type KnowledgeCategoryCreateManySchoolInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
  }

  export type PulseSurveyCreateManySchoolInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    createdAt?: Date | string
  }

  export type PolicyCreateManySchoolInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type FileFolderCreateManySchoolInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type SchoolFileCreateManySchoolInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    children?: ChildUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    surveys?: SurveyUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutSurveysNestedInput
    responses?: SurveyResponseUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutEventsNestedInput
    rsvps?: EventRsvpUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: EventRsvpUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermDateUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleItemUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutScheduleItemsNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: WeeklyMessageHeartUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCategoryUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    articles?: KnowledgeArticleUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    articles?: KnowledgeArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PulseSurveyUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PulseResponseUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PulseResponseUncheckedUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    children?: FileFolderUpdateManyWithoutParentNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FileFolderUpdateOneWithoutFilesNestedInput
  }

  export type SchoolFileUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateManyParentInput = {
    id?: string
    name: string
    classId: string
  }

  export type MessageAcknowledgmentCreateManyUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type SurveyResponseCreateManyUserInput = {
    id?: string
    surveyId: string
    response: string
    createdAt?: Date | string
  }

  export type EventRsvpCreateManyUserInput = {
    id?: string
    eventId: string
    status: string
    createdAt?: Date | string
  }

  export type PulseResponseCreateManyUserInput = {
    id?: string
    pulseId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartCreateManyUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type ChildUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageAcknowledgmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAcknowledgmentsNestedInput
  }

  export type MessageAcknowledgmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRsvpsNestedInput
  }

  export type EventRsvpUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pulse?: PulseSurveyUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type PulseResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: WeeklyMessageUpdateOneRequiredWithoutHeartsNestedInput
  }

  export type WeeklyMessageHeartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateManyClassInput = {
    id?: string
    name: string
    parentId: string
  }

  export type MessageCreateManyClassInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    createdAt?: Date | string
  }

  export type SurveyCreateManyClassInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    active?: boolean
    targetClass: string
    schoolId: string
    createdAt?: Date | string
  }

  export type EventCreateManyClassInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
  }

  export type ScheduleItemCreateManyClassInput = {
    id?: string
    targetClass: string
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ChildUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: UserUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSurveysNestedInput
    responses?: SurveyResponseUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: EventRsvpUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: EventRsvpUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutScheduleItemsNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentCreateManyMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageAcksNestedInput
  }

  export type MessageAcknowledgmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseCreateManySurveyInput = {
    id?: string
    userId: string
    response: string
    createdAt?: Date | string
  }

  export type SurveyResponseUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSurveyResponsesNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUncheckedUpdateManyWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpCreateManyEventInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventRsvpsNestedInput
  }

  export type EventRsvpUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartCreateManyMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWeeklyHeartsNestedInput
  }

  export type WeeklyMessageHeartUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleCreateManyCategoryInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseCreateManyPulseInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseUpdateWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPulseResponsesNestedInput
  }

  export type PulseResponseUncheckedUpdateWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUncheckedUpdateManyWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderCreateManyParentInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
  }

  export type SchoolFileCreateManyFolderInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileFolderUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUpdateManyWithoutParentNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFilesNestedInput
  }

  export type SchoolFileUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassCountOutputTypeDefaultArgs instead
     */
    export type ClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyCountOutputTypeDefaultArgs instead
     */
    export type SurveyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyMessageCountOutputTypeDefaultArgs instead
     */
    export type WeeklyMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeCategoryCountOutputTypeDefaultArgs instead
     */
    export type KnowledgeCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PulseSurveyCountOutputTypeDefaultArgs instead
     */
    export type PulseSurveyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PulseSurveyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileFolderCountOutputTypeDefaultArgs instead
     */
    export type FileFolderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileFolderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolDefaultArgs instead
     */
    export type SchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChildDefaultArgs instead
     */
    export type ChildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassDefaultArgs instead
     */
    export type ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageAcknowledgmentDefaultArgs instead
     */
    export type MessageAcknowledgmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageAcknowledgmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyDefaultArgs instead
     */
    export type SurveyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SurveyResponseDefaultArgs instead
     */
    export type SurveyResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SurveyResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventRsvpDefaultArgs instead
     */
    export type EventRsvpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventRsvpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TermDateDefaultArgs instead
     */
    export type TermDateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TermDateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleItemDefaultArgs instead
     */
    export type ScheduleItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyMessageDefaultArgs instead
     */
    export type WeeklyMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyMessageHeartDefaultArgs instead
     */
    export type WeeklyMessageHeartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyMessageHeartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeCategoryDefaultArgs instead
     */
    export type KnowledgeCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeArticleDefaultArgs instead
     */
    export type KnowledgeArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PulseSurveyDefaultArgs instead
     */
    export type PulseSurveyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PulseSurveyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PulseResponseDefaultArgs instead
     */
    export type PulseResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PulseResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyDefaultArgs instead
     */
    export type PolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileFolderDefaultArgs instead
     */
    export type FileFolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileFolderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolFileDefaultArgs instead
     */
    export type SchoolFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolFileDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}