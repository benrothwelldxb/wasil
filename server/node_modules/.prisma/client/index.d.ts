
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Child
 * 
 */
export type Child = $Result.DefaultSelection<Prisma.$ChildPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model ParentStudentLink
 * 
 */
export type ParentStudentLink = $Result.DefaultSelection<Prisma.$ParentStudentLinkPayload>
/**
 * Model StudentInvitationLink
 * 
 */
export type StudentInvitationLink = $Result.DefaultSelection<Prisma.$StudentInvitationLinkPayload>
/**
 * Model YearGroup
 * 
 */
export type YearGroup = $Result.DefaultSelection<Prisma.$YearGroupPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model StaffClassAssignment
 * 
 */
export type StaffClassAssignment = $Result.DefaultSelection<Prisma.$StaffClassAssignmentPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageAcknowledgment
 * 
 */
export type MessageAcknowledgment = $Result.DefaultSelection<Prisma.$MessageAcknowledgmentPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventRsvp
 * 
 */
export type EventRsvp = $Result.DefaultSelection<Prisma.$EventRsvpPayload>
/**
 * Model TermDate
 * 
 */
export type TermDate = $Result.DefaultSelection<Prisma.$TermDatePayload>
/**
 * Model ScheduleItem
 * 
 */
export type ScheduleItem = $Result.DefaultSelection<Prisma.$ScheduleItemPayload>
/**
 * Model WeeklyMessage
 * 
 */
export type WeeklyMessage = $Result.DefaultSelection<Prisma.$WeeklyMessagePayload>
/**
 * Model WeeklyMessageHeart
 * 
 */
export type WeeklyMessageHeart = $Result.DefaultSelection<Prisma.$WeeklyMessageHeartPayload>
/**
 * Model KnowledgeCategory
 * 
 */
export type KnowledgeCategory = $Result.DefaultSelection<Prisma.$KnowledgeCategoryPayload>
/**
 * Model KnowledgeArticle
 * 
 */
export type KnowledgeArticle = $Result.DefaultSelection<Prisma.$KnowledgeArticlePayload>
/**
 * Model PulseSurvey
 * 
 */
export type PulseSurvey = $Result.DefaultSelection<Prisma.$PulseSurveyPayload>
/**
 * Model PulseResponse
 * 
 */
export type PulseResponse = $Result.DefaultSelection<Prisma.$PulseResponsePayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model FileFolder
 * 
 */
export type FileFolder = $Result.DefaultSelection<Prisma.$FileFolderPayload>
/**
 * Model SchoolFile
 * 
 */
export type SchoolFile = $Result.DefaultSelection<Prisma.$SchoolFilePayload>
/**
 * Model Form
 * 
 */
export type Form = $Result.DefaultSelection<Prisma.$FormPayload>
/**
 * Model FormResponse
 * 
 */
export type FormResponse = $Result.DefaultSelection<Prisma.$FormResponsePayload>
/**
 * Model ParentInvitation
 * 
 */
export type ParentInvitation = $Result.DefaultSelection<Prisma.$ParentInvitationPayload>
/**
 * Model ChildInvitationLink
 * 
 */
export type ChildInvitationLink = $Result.DefaultSelection<Prisma.$ChildInvitationLinkPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model DeviceToken
 * 
 */
export type DeviceToken = $Result.DefaultSelection<Prisma.$DeviceTokenPayload>
/**
 * Model MagicLinkToken
 * 
 */
export type MagicLinkToken = $Result.DefaultSelection<Prisma.$MagicLinkTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  PARENT: 'PARENT',
  STAFF: 'STAFF',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AuditResourceType: {
  MESSAGE: 'MESSAGE',
  SURVEY: 'SURVEY',
  EVENT: 'EVENT',
  WEEKLY_MESSAGE: 'WEEKLY_MESSAGE',
  TERM_DATE: 'TERM_DATE',
  PULSE_SURVEY: 'PULSE_SURVEY',
  YEAR_GROUP: 'YEAR_GROUP',
  CLASS: 'CLASS',
  STAFF: 'STAFF',
  STUDENT: 'STUDENT',
  POLICY: 'POLICY',
  FILE: 'FILE',
  FOLDER: 'FOLDER',
  SCHEDULE_ITEM: 'SCHEDULE_ITEM',
  KNOWLEDGE_CATEGORY: 'KNOWLEDGE_CATEGORY',
  KNOWLEDGE_ARTICLE: 'KNOWLEDGE_ARTICLE',
  SCHOOL: 'SCHOOL',
  FORM: 'FORM',
  PARENT_INVITATION: 'PARENT_INVITATION'
};

export type AuditResourceType = (typeof AuditResourceType)[keyof typeof AuditResourceType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type AuditResourceType = $Enums.AuditResourceType

export const AuditResourceType: typeof $Enums.AuditResourceType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Schools
 * const schools = await prisma.school.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Schools
   * const schools = await prisma.school.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.child`: Exposes CRUD operations for the **Child** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Children
    * const children = await prisma.child.findMany()
    * ```
    */
  get child(): Prisma.ChildDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.parentStudentLink`: Exposes CRUD operations for the **ParentStudentLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentStudentLinks
    * const parentStudentLinks = await prisma.parentStudentLink.findMany()
    * ```
    */
  get parentStudentLink(): Prisma.ParentStudentLinkDelegate<ExtArgs>;

  /**
   * `prisma.studentInvitationLink`: Exposes CRUD operations for the **StudentInvitationLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentInvitationLinks
    * const studentInvitationLinks = await prisma.studentInvitationLink.findMany()
    * ```
    */
  get studentInvitationLink(): Prisma.StudentInvitationLinkDelegate<ExtArgs>;

  /**
   * `prisma.yearGroup`: Exposes CRUD operations for the **YearGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearGroups
    * const yearGroups = await prisma.yearGroup.findMany()
    * ```
    */
  get yearGroup(): Prisma.YearGroupDelegate<ExtArgs>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs>;

  /**
   * `prisma.staffClassAssignment`: Exposes CRUD operations for the **StaffClassAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffClassAssignments
    * const staffClassAssignments = await prisma.staffClassAssignment.findMany()
    * ```
    */
  get staffClassAssignment(): Prisma.StaffClassAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.messageAcknowledgment`: Exposes CRUD operations for the **MessageAcknowledgment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAcknowledgments
    * const messageAcknowledgments = await prisma.messageAcknowledgment.findMany()
    * ```
    */
  get messageAcknowledgment(): Prisma.MessageAcknowledgmentDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.eventRsvp`: Exposes CRUD operations for the **EventRsvp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventRsvps
    * const eventRsvps = await prisma.eventRsvp.findMany()
    * ```
    */
  get eventRsvp(): Prisma.EventRsvpDelegate<ExtArgs>;

  /**
   * `prisma.termDate`: Exposes CRUD operations for the **TermDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TermDates
    * const termDates = await prisma.termDate.findMany()
    * ```
    */
  get termDate(): Prisma.TermDateDelegate<ExtArgs>;

  /**
   * `prisma.scheduleItem`: Exposes CRUD operations for the **ScheduleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleItems
    * const scheduleItems = await prisma.scheduleItem.findMany()
    * ```
    */
  get scheduleItem(): Prisma.ScheduleItemDelegate<ExtArgs>;

  /**
   * `prisma.weeklyMessage`: Exposes CRUD operations for the **WeeklyMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyMessages
    * const weeklyMessages = await prisma.weeklyMessage.findMany()
    * ```
    */
  get weeklyMessage(): Prisma.WeeklyMessageDelegate<ExtArgs>;

  /**
   * `prisma.weeklyMessageHeart`: Exposes CRUD operations for the **WeeklyMessageHeart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyMessageHearts
    * const weeklyMessageHearts = await prisma.weeklyMessageHeart.findMany()
    * ```
    */
  get weeklyMessageHeart(): Prisma.WeeklyMessageHeartDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeCategory`: Exposes CRUD operations for the **KnowledgeCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeCategories
    * const knowledgeCategories = await prisma.knowledgeCategory.findMany()
    * ```
    */
  get knowledgeCategory(): Prisma.KnowledgeCategoryDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeArticle`: Exposes CRUD operations for the **KnowledgeArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeArticles
    * const knowledgeArticles = await prisma.knowledgeArticle.findMany()
    * ```
    */
  get knowledgeArticle(): Prisma.KnowledgeArticleDelegate<ExtArgs>;

  /**
   * `prisma.pulseSurvey`: Exposes CRUD operations for the **PulseSurvey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PulseSurveys
    * const pulseSurveys = await prisma.pulseSurvey.findMany()
    * ```
    */
  get pulseSurvey(): Prisma.PulseSurveyDelegate<ExtArgs>;

  /**
   * `prisma.pulseResponse`: Exposes CRUD operations for the **PulseResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PulseResponses
    * const pulseResponses = await prisma.pulseResponse.findMany()
    * ```
    */
  get pulseResponse(): Prisma.PulseResponseDelegate<ExtArgs>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs>;

  /**
   * `prisma.fileFolder`: Exposes CRUD operations for the **FileFolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileFolders
    * const fileFolders = await prisma.fileFolder.findMany()
    * ```
    */
  get fileFolder(): Prisma.FileFolderDelegate<ExtArgs>;

  /**
   * `prisma.schoolFile`: Exposes CRUD operations for the **SchoolFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolFiles
    * const schoolFiles = await prisma.schoolFile.findMany()
    * ```
    */
  get schoolFile(): Prisma.SchoolFileDelegate<ExtArgs>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<ExtArgs>;

  /**
   * `prisma.formResponse`: Exposes CRUD operations for the **FormResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormResponses
    * const formResponses = await prisma.formResponse.findMany()
    * ```
    */
  get formResponse(): Prisma.FormResponseDelegate<ExtArgs>;

  /**
   * `prisma.parentInvitation`: Exposes CRUD operations for the **ParentInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentInvitations
    * const parentInvitations = await prisma.parentInvitation.findMany()
    * ```
    */
  get parentInvitation(): Prisma.ParentInvitationDelegate<ExtArgs>;

  /**
   * `prisma.childInvitationLink`: Exposes CRUD operations for the **ChildInvitationLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChildInvitationLinks
    * const childInvitationLinks = await prisma.childInvitationLink.findMany()
    * ```
    */
  get childInvitationLink(): Prisma.ChildInvitationLinkDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.deviceToken`: Exposes CRUD operations for the **DeviceToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTokens
    * const deviceTokens = await prisma.deviceToken.findMany()
    * ```
    */
  get deviceToken(): Prisma.DeviceTokenDelegate<ExtArgs>;

  /**
   * `prisma.magicLinkToken`: Exposes CRUD operations for the **MagicLinkToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicLinkTokens
    * const magicLinkTokens = await prisma.magicLinkToken.findMany()
    * ```
    */
  get magicLinkToken(): Prisma.MagicLinkTokenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    School: 'School',
    User: 'User',
    RefreshToken: 'RefreshToken',
    Child: 'Child',
    Student: 'Student',
    ParentStudentLink: 'ParentStudentLink',
    StudentInvitationLink: 'StudentInvitationLink',
    YearGroup: 'YearGroup',
    Class: 'Class',
    StaffClassAssignment: 'StaffClassAssignment',
    Message: 'Message',
    MessageAcknowledgment: 'MessageAcknowledgment',
    Event: 'Event',
    EventRsvp: 'EventRsvp',
    TermDate: 'TermDate',
    ScheduleItem: 'ScheduleItem',
    WeeklyMessage: 'WeeklyMessage',
    WeeklyMessageHeart: 'WeeklyMessageHeart',
    KnowledgeCategory: 'KnowledgeCategory',
    KnowledgeArticle: 'KnowledgeArticle',
    PulseSurvey: 'PulseSurvey',
    PulseResponse: 'PulseResponse',
    Policy: 'Policy',
    FileFolder: 'FileFolder',
    SchoolFile: 'SchoolFile',
    Form: 'Form',
    FormResponse: 'FormResponse',
    ParentInvitation: 'ParentInvitation',
    ChildInvitationLink: 'ChildInvitationLink',
    AuditLog: 'AuditLog',
    Notification: 'Notification',
    DeviceToken: 'DeviceToken',
    MagicLinkToken: 'MagicLinkToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "school" | "user" | "refreshToken" | "child" | "student" | "parentStudentLink" | "studentInvitationLink" | "yearGroup" | "class" | "staffClassAssignment" | "message" | "messageAcknowledgment" | "event" | "eventRsvp" | "termDate" | "scheduleItem" | "weeklyMessage" | "weeklyMessageHeart" | "knowledgeCategory" | "knowledgeArticle" | "pulseSurvey" | "pulseResponse" | "policy" | "fileFolder" | "schoolFile" | "form" | "formResponse" | "parentInvitation" | "childInvitationLink" | "auditLog" | "notification" | "deviceToken" | "magicLinkToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Child: {
        payload: Prisma.$ChildPayload<ExtArgs>
        fields: Prisma.ChildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findFirst: {
            args: Prisma.ChildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findMany: {
            args: Prisma.ChildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          create: {
            args: Prisma.ChildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          createMany: {
            args: Prisma.ChildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          delete: {
            args: Prisma.ChildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          update: {
            args: Prisma.ChildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          deleteMany: {
            args: Prisma.ChildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          aggregate: {
            args: Prisma.ChildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChild>
          }
          groupBy: {
            args: Prisma.ChildGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChildGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChildCountArgs<ExtArgs>
            result: $Utils.Optional<ChildCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      ParentStudentLink: {
        payload: Prisma.$ParentStudentLinkPayload<ExtArgs>
        fields: Prisma.ParentStudentLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentStudentLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentStudentLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>
          }
          findFirst: {
            args: Prisma.ParentStudentLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentStudentLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>
          }
          findMany: {
            args: Prisma.ParentStudentLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>[]
          }
          create: {
            args: Prisma.ParentStudentLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>
          }
          createMany: {
            args: Prisma.ParentStudentLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentStudentLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>[]
          }
          delete: {
            args: Prisma.ParentStudentLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>
          }
          update: {
            args: Prisma.ParentStudentLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>
          }
          deleteMany: {
            args: Prisma.ParentStudentLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentStudentLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentStudentLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentStudentLinkPayload>
          }
          aggregate: {
            args: Prisma.ParentStudentLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParentStudentLink>
          }
          groupBy: {
            args: Prisma.ParentStudentLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentStudentLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentStudentLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ParentStudentLinkCountAggregateOutputType> | number
          }
        }
      }
      StudentInvitationLink: {
        payload: Prisma.$StudentInvitationLinkPayload<ExtArgs>
        fields: Prisma.StudentInvitationLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentInvitationLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentInvitationLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>
          }
          findFirst: {
            args: Prisma.StudentInvitationLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentInvitationLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>
          }
          findMany: {
            args: Prisma.StudentInvitationLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>[]
          }
          create: {
            args: Prisma.StudentInvitationLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>
          }
          createMany: {
            args: Prisma.StudentInvitationLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentInvitationLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>[]
          }
          delete: {
            args: Prisma.StudentInvitationLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>
          }
          update: {
            args: Prisma.StudentInvitationLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>
          }
          deleteMany: {
            args: Prisma.StudentInvitationLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentInvitationLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentInvitationLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentInvitationLinkPayload>
          }
          aggregate: {
            args: Prisma.StudentInvitationLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentInvitationLink>
          }
          groupBy: {
            args: Prisma.StudentInvitationLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentInvitationLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentInvitationLinkCountArgs<ExtArgs>
            result: $Utils.Optional<StudentInvitationLinkCountAggregateOutputType> | number
          }
        }
      }
      YearGroup: {
        payload: Prisma.$YearGroupPayload<ExtArgs>
        fields: Prisma.YearGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>
          }
          findFirst: {
            args: Prisma.YearGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>
          }
          findMany: {
            args: Prisma.YearGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>[]
          }
          create: {
            args: Prisma.YearGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>
          }
          createMany: {
            args: Prisma.YearGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>[]
          }
          delete: {
            args: Prisma.YearGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>
          }
          update: {
            args: Prisma.YearGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>
          }
          deleteMany: {
            args: Prisma.YearGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.YearGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearGroupPayload>
          }
          aggregate: {
            args: Prisma.YearGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearGroup>
          }
          groupBy: {
            args: Prisma.YearGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearGroupCountArgs<ExtArgs>
            result: $Utils.Optional<YearGroupCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      StaffClassAssignment: {
        payload: Prisma.$StaffClassAssignmentPayload<ExtArgs>
        fields: Prisma.StaffClassAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffClassAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffClassAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>
          }
          findFirst: {
            args: Prisma.StaffClassAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffClassAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>
          }
          findMany: {
            args: Prisma.StaffClassAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>[]
          }
          create: {
            args: Prisma.StaffClassAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>
          }
          createMany: {
            args: Prisma.StaffClassAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffClassAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>[]
          }
          delete: {
            args: Prisma.StaffClassAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>
          }
          update: {
            args: Prisma.StaffClassAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.StaffClassAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffClassAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StaffClassAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffClassAssignmentPayload>
          }
          aggregate: {
            args: Prisma.StaffClassAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffClassAssignment>
          }
          groupBy: {
            args: Prisma.StaffClassAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffClassAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffClassAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<StaffClassAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageAcknowledgment: {
        payload: Prisma.$MessageAcknowledgmentPayload<ExtArgs>
        fields: Prisma.MessageAcknowledgmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAcknowledgmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAcknowledgmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAcknowledgmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAcknowledgmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          findMany: {
            args: Prisma.MessageAcknowledgmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>[]
          }
          create: {
            args: Prisma.MessageAcknowledgmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          createMany: {
            args: Prisma.MessageAcknowledgmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageAcknowledgmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>[]
          }
          delete: {
            args: Prisma.MessageAcknowledgmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          update: {
            args: Prisma.MessageAcknowledgmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAcknowledgmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAcknowledgmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageAcknowledgmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAcknowledgmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAcknowledgmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAcknowledgment>
          }
          groupBy: {
            args: Prisma.MessageAcknowledgmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAcknowledgmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAcknowledgmentCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAcknowledgmentCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventRsvp: {
        payload: Prisma.$EventRsvpPayload<ExtArgs>
        fields: Prisma.EventRsvpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventRsvpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventRsvpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          findFirst: {
            args: Prisma.EventRsvpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventRsvpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          findMany: {
            args: Prisma.EventRsvpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>[]
          }
          create: {
            args: Prisma.EventRsvpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          createMany: {
            args: Prisma.EventRsvpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventRsvpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>[]
          }
          delete: {
            args: Prisma.EventRsvpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          update: {
            args: Prisma.EventRsvpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          deleteMany: {
            args: Prisma.EventRsvpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventRsvpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventRsvpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRsvpPayload>
          }
          aggregate: {
            args: Prisma.EventRsvpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventRsvp>
          }
          groupBy: {
            args: Prisma.EventRsvpGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventRsvpGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventRsvpCountArgs<ExtArgs>
            result: $Utils.Optional<EventRsvpCountAggregateOutputType> | number
          }
        }
      }
      TermDate: {
        payload: Prisma.$TermDatePayload<ExtArgs>
        fields: Prisma.TermDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          findFirst: {
            args: Prisma.TermDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          findMany: {
            args: Prisma.TermDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>[]
          }
          create: {
            args: Prisma.TermDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          createMany: {
            args: Prisma.TermDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TermDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>[]
          }
          delete: {
            args: Prisma.TermDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          update: {
            args: Prisma.TermDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          deleteMany: {
            args: Prisma.TermDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TermDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermDatePayload>
          }
          aggregate: {
            args: Prisma.TermDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermDate>
          }
          groupBy: {
            args: Prisma.TermDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermDateCountArgs<ExtArgs>
            result: $Utils.Optional<TermDateCountAggregateOutputType> | number
          }
        }
      }
      ScheduleItem: {
        payload: Prisma.$ScheduleItemPayload<ExtArgs>
        fields: Prisma.ScheduleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          findFirst: {
            args: Prisma.ScheduleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          findMany: {
            args: Prisma.ScheduleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>[]
          }
          create: {
            args: Prisma.ScheduleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          createMany: {
            args: Prisma.ScheduleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>[]
          }
          delete: {
            args: Prisma.ScheduleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          update: {
            args: Prisma.ScheduleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          aggregate: {
            args: Prisma.ScheduleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleItem>
          }
          groupBy: {
            args: Prisma.ScheduleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleItemCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleItemCountAggregateOutputType> | number
          }
        }
      }
      WeeklyMessage: {
        payload: Prisma.$WeeklyMessagePayload<ExtArgs>
        fields: Prisma.WeeklyMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          findFirst: {
            args: Prisma.WeeklyMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          findMany: {
            args: Prisma.WeeklyMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>[]
          }
          create: {
            args: Prisma.WeeklyMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          createMany: {
            args: Prisma.WeeklyMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>[]
          }
          delete: {
            args: Prisma.WeeklyMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          update: {
            args: Prisma.WeeklyMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          deleteMany: {
            args: Prisma.WeeklyMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeeklyMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessagePayload>
          }
          aggregate: {
            args: Prisma.WeeklyMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyMessage>
          }
          groupBy: {
            args: Prisma.WeeklyMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyMessageCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageCountAggregateOutputType> | number
          }
        }
      }
      WeeklyMessageHeart: {
        payload: Prisma.$WeeklyMessageHeartPayload<ExtArgs>
        fields: Prisma.WeeklyMessageHeartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyMessageHeartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyMessageHeartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          findFirst: {
            args: Prisma.WeeklyMessageHeartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyMessageHeartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          findMany: {
            args: Prisma.WeeklyMessageHeartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>[]
          }
          create: {
            args: Prisma.WeeklyMessageHeartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          createMany: {
            args: Prisma.WeeklyMessageHeartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyMessageHeartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>[]
          }
          delete: {
            args: Prisma.WeeklyMessageHeartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          update: {
            args: Prisma.WeeklyMessageHeartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          deleteMany: {
            args: Prisma.WeeklyMessageHeartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyMessageHeartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeeklyMessageHeartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyMessageHeartPayload>
          }
          aggregate: {
            args: Prisma.WeeklyMessageHeartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyMessageHeart>
          }
          groupBy: {
            args: Prisma.WeeklyMessageHeartGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageHeartGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyMessageHeartCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyMessageHeartCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeCategory: {
        payload: Prisma.$KnowledgeCategoryPayload<ExtArgs>
        fields: Prisma.KnowledgeCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          findMany: {
            args: Prisma.KnowledgeCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>[]
          }
          create: {
            args: Prisma.KnowledgeCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          createMany: {
            args: Prisma.KnowledgeCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          update: {
            args: Prisma.KnowledgeCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeCategoryPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeCategory>
          }
          groupBy: {
            args: Prisma.KnowledgeCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeCategoryCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeArticle: {
        payload: Prisma.$KnowledgeArticlePayload<ExtArgs>
        fields: Prisma.KnowledgeArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          findMany: {
            args: Prisma.KnowledgeArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
          }
          create: {
            args: Prisma.KnowledgeArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          createMany: {
            args: Prisma.KnowledgeArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          update: {
            args: Prisma.KnowledgeArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeArticle>
          }
          groupBy: {
            args: Prisma.KnowledgeArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeArticleCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeArticleCountAggregateOutputType> | number
          }
        }
      }
      PulseSurvey: {
        payload: Prisma.$PulseSurveyPayload<ExtArgs>
        fields: Prisma.PulseSurveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PulseSurveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PulseSurveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          findFirst: {
            args: Prisma.PulseSurveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PulseSurveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          findMany: {
            args: Prisma.PulseSurveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>[]
          }
          create: {
            args: Prisma.PulseSurveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          createMany: {
            args: Prisma.PulseSurveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PulseSurveyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>[]
          }
          delete: {
            args: Prisma.PulseSurveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          update: {
            args: Prisma.PulseSurveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          deleteMany: {
            args: Prisma.PulseSurveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PulseSurveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PulseSurveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseSurveyPayload>
          }
          aggregate: {
            args: Prisma.PulseSurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePulseSurvey>
          }
          groupBy: {
            args: Prisma.PulseSurveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PulseSurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PulseSurveyCountArgs<ExtArgs>
            result: $Utils.Optional<PulseSurveyCountAggregateOutputType> | number
          }
        }
      }
      PulseResponse: {
        payload: Prisma.$PulseResponsePayload<ExtArgs>
        fields: Prisma.PulseResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PulseResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PulseResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          findFirst: {
            args: Prisma.PulseResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PulseResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          findMany: {
            args: Prisma.PulseResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>[]
          }
          create: {
            args: Prisma.PulseResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          createMany: {
            args: Prisma.PulseResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PulseResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>[]
          }
          delete: {
            args: Prisma.PulseResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          update: {
            args: Prisma.PulseResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          deleteMany: {
            args: Prisma.PulseResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PulseResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PulseResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PulseResponsePayload>
          }
          aggregate: {
            args: Prisma.PulseResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePulseResponse>
          }
          groupBy: {
            args: Prisma.PulseResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PulseResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PulseResponseCountArgs<ExtArgs>
            result: $Utils.Optional<PulseResponseCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      FileFolder: {
        payload: Prisma.$FileFolderPayload<ExtArgs>
        fields: Prisma.FileFolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          findFirst: {
            args: Prisma.FileFolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          findMany: {
            args: Prisma.FileFolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>[]
          }
          create: {
            args: Prisma.FileFolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          createMany: {
            args: Prisma.FileFolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileFolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>[]
          }
          delete: {
            args: Prisma.FileFolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          update: {
            args: Prisma.FileFolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          deleteMany: {
            args: Prisma.FileFolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileFolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileFolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileFolderPayload>
          }
          aggregate: {
            args: Prisma.FileFolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileFolder>
          }
          groupBy: {
            args: Prisma.FileFolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileFolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileFolderCountArgs<ExtArgs>
            result: $Utils.Optional<FileFolderCountAggregateOutputType> | number
          }
        }
      }
      SchoolFile: {
        payload: Prisma.$SchoolFilePayload<ExtArgs>
        fields: Prisma.SchoolFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          findFirst: {
            args: Prisma.SchoolFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          findMany: {
            args: Prisma.SchoolFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>[]
          }
          create: {
            args: Prisma.SchoolFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          createMany: {
            args: Prisma.SchoolFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>[]
          }
          delete: {
            args: Prisma.SchoolFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          update: {
            args: Prisma.SchoolFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          deleteMany: {
            args: Prisma.SchoolFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolFilePayload>
          }
          aggregate: {
            args: Prisma.SchoolFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolFile>
          }
          groupBy: {
            args: Prisma.SchoolFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolFileCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolFileCountAggregateOutputType> | number
          }
        }
      }
      Form: {
        payload: Prisma.$FormPayload<ExtArgs>
        fields: Prisma.FormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findFirst: {
            args: Prisma.FormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findMany: {
            args: Prisma.FormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          create: {
            args: Prisma.FormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          createMany: {
            args: Prisma.FormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          delete: {
            args: Prisma.FormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          update: {
            args: Prisma.FormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          deleteMany: {
            args: Prisma.FormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.FormGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormCountArgs<ExtArgs>
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
      FormResponse: {
        payload: Prisma.$FormResponsePayload<ExtArgs>
        fields: Prisma.FormResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          findFirst: {
            args: Prisma.FormResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          findMany: {
            args: Prisma.FormResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
          }
          create: {
            args: Prisma.FormResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          createMany: {
            args: Prisma.FormResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
          }
          delete: {
            args: Prisma.FormResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          update: {
            args: Prisma.FormResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          deleteMany: {
            args: Prisma.FormResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FormResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          aggregate: {
            args: Prisma.FormResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormResponse>
          }
          groupBy: {
            args: Prisma.FormResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormResponseCountArgs<ExtArgs>
            result: $Utils.Optional<FormResponseCountAggregateOutputType> | number
          }
        }
      }
      ParentInvitation: {
        payload: Prisma.$ParentInvitationPayload<ExtArgs>
        fields: Prisma.ParentInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>
          }
          findFirst: {
            args: Prisma.ParentInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>
          }
          findMany: {
            args: Prisma.ParentInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>[]
          }
          create: {
            args: Prisma.ParentInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>
          }
          createMany: {
            args: Prisma.ParentInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>[]
          }
          delete: {
            args: Prisma.ParentInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>
          }
          update: {
            args: Prisma.ParentInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>
          }
          deleteMany: {
            args: Prisma.ParentInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentInvitationPayload>
          }
          aggregate: {
            args: Prisma.ParentInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParentInvitation>
          }
          groupBy: {
            args: Prisma.ParentInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<ParentInvitationCountAggregateOutputType> | number
          }
        }
      }
      ChildInvitationLink: {
        payload: Prisma.$ChildInvitationLinkPayload<ExtArgs>
        fields: Prisma.ChildInvitationLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChildInvitationLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChildInvitationLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>
          }
          findFirst: {
            args: Prisma.ChildInvitationLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChildInvitationLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>
          }
          findMany: {
            args: Prisma.ChildInvitationLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>[]
          }
          create: {
            args: Prisma.ChildInvitationLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>
          }
          createMany: {
            args: Prisma.ChildInvitationLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChildInvitationLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>[]
          }
          delete: {
            args: Prisma.ChildInvitationLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>
          }
          update: {
            args: Prisma.ChildInvitationLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>
          }
          deleteMany: {
            args: Prisma.ChildInvitationLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChildInvitationLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChildInvitationLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildInvitationLinkPayload>
          }
          aggregate: {
            args: Prisma.ChildInvitationLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChildInvitationLink>
          }
          groupBy: {
            args: Prisma.ChildInvitationLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChildInvitationLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChildInvitationLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ChildInvitationLinkCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      DeviceToken: {
        payload: Prisma.$DeviceTokenPayload<ExtArgs>
        fields: Prisma.DeviceTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findFirst: {
            args: Prisma.DeviceTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findMany: {
            args: Prisma.DeviceTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          create: {
            args: Prisma.DeviceTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          createMany: {
            args: Prisma.DeviceTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          delete: {
            args: Prisma.DeviceTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          update: {
            args: Prisma.DeviceTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          aggregate: {
            args: Prisma.DeviceTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceToken>
          }
          groupBy: {
            args: Prisma.DeviceTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTokenCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenCountAggregateOutputType> | number
          }
        }
      }
      MagicLinkToken: {
        payload: Prisma.$MagicLinkTokenPayload<ExtArgs>
        fields: Prisma.MagicLinkTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicLinkTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicLinkTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>
          }
          findFirst: {
            args: Prisma.MagicLinkTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicLinkTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>
          }
          findMany: {
            args: Prisma.MagicLinkTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>[]
          }
          create: {
            args: Prisma.MagicLinkTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>
          }
          createMany: {
            args: Prisma.MagicLinkTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicLinkTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>[]
          }
          delete: {
            args: Prisma.MagicLinkTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>
          }
          update: {
            args: Prisma.MagicLinkTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>
          }
          deleteMany: {
            args: Prisma.MagicLinkTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicLinkTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MagicLinkTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicLinkTokenPayload>
          }
          aggregate: {
            args: Prisma.MagicLinkTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicLinkToken>
          }
          groupBy: {
            args: Prisma.MagicLinkTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicLinkTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicLinkTokenCountArgs<ExtArgs>
            result: $Utils.Optional<MagicLinkTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
    yearGroups: number
    classes: number
    students: number
    messages: number
    forms: number
    events: number
    termDates: number
    scheduleItems: number
    weeklyMessages: number
    knowledgeCategories: number
    pulseSurveys: number
    policies: number
    folders: number
    files: number
    auditLogs: number
    notifications: number
    invitations: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    yearGroups?: boolean | SchoolCountOutputTypeCountYearGroupsArgs
    classes?: boolean | SchoolCountOutputTypeCountClassesArgs
    students?: boolean | SchoolCountOutputTypeCountStudentsArgs
    messages?: boolean | SchoolCountOutputTypeCountMessagesArgs
    forms?: boolean | SchoolCountOutputTypeCountFormsArgs
    events?: boolean | SchoolCountOutputTypeCountEventsArgs
    termDates?: boolean | SchoolCountOutputTypeCountTermDatesArgs
    scheduleItems?: boolean | SchoolCountOutputTypeCountScheduleItemsArgs
    weeklyMessages?: boolean | SchoolCountOutputTypeCountWeeklyMessagesArgs
    knowledgeCategories?: boolean | SchoolCountOutputTypeCountKnowledgeCategoriesArgs
    pulseSurveys?: boolean | SchoolCountOutputTypeCountPulseSurveysArgs
    policies?: boolean | SchoolCountOutputTypeCountPoliciesArgs
    folders?: boolean | SchoolCountOutputTypeCountFoldersArgs
    files?: boolean | SchoolCountOutputTypeCountFilesArgs
    auditLogs?: boolean | SchoolCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | SchoolCountOutputTypeCountNotificationsArgs
    invitations?: boolean | SchoolCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountYearGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearGroupWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTermDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermDateWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountScheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountWeeklyMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountKnowledgeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeCategoryWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountPulseSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseSurveyWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolFileWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentInvitationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    children: number
    studentLinks: number
    assignedClasses: number
    sentMessages: number
    messageAcks: number
    formResponses: number
    eventRsvps: number
    pulseResponses: number
    weeklyHearts: number
    refreshTokens: number
    auditLogs: number
    notifications: number
    deviceTokens: number
    createdInvitations: number
    redeemedInvitations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | UserCountOutputTypeCountChildrenArgs
    studentLinks?: boolean | UserCountOutputTypeCountStudentLinksArgs
    assignedClasses?: boolean | UserCountOutputTypeCountAssignedClassesArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    messageAcks?: boolean | UserCountOutputTypeCountMessageAcksArgs
    formResponses?: boolean | UserCountOutputTypeCountFormResponsesArgs
    eventRsvps?: boolean | UserCountOutputTypeCountEventRsvpsArgs
    pulseResponses?: boolean | UserCountOutputTypeCountPulseResponsesArgs
    weeklyHearts?: boolean | UserCountOutputTypeCountWeeklyHeartsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    deviceTokens?: boolean | UserCountOutputTypeCountDeviceTokensArgs
    createdInvitations?: boolean | UserCountOutputTypeCountCreatedInvitationsArgs
    redeemedInvitations?: boolean | UserCountOutputTypeCountRedeemedInvitationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentStudentLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffClassAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageAcksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAcknowledgmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFormResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRsvpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPulseResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWeeklyHeartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageHeartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRedeemedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentInvitationWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    parentLinks: number
    invitationLinks: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentLinks?: boolean | StudentCountOutputTypeCountParentLinksArgs
    invitationLinks?: boolean | StudentCountOutputTypeCountInvitationLinksArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentStudentLinkWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountInvitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentInvitationLinkWhereInput
  }


  /**
   * Count Type YearGroupCountOutputType
   */

  export type YearGroupCountOutputType = {
    classes: number
    messages: number
    events: number
    scheduleItems: number
  }

  export type YearGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | YearGroupCountOutputTypeCountClassesArgs
    messages?: boolean | YearGroupCountOutputTypeCountMessagesArgs
    events?: boolean | YearGroupCountOutputTypeCountEventsArgs
    scheduleItems?: boolean | YearGroupCountOutputTypeCountScheduleItemsArgs
  }

  // Custom InputTypes
  /**
   * YearGroupCountOutputType without action
   */
  export type YearGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroupCountOutputType
     */
    select?: YearGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearGroupCountOutputType without action
   */
  export type YearGroupCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * YearGroupCountOutputType without action
   */
  export type YearGroupCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * YearGroupCountOutputType without action
   */
  export type YearGroupCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * YearGroupCountOutputType without action
   */
  export type YearGroupCountOutputTypeCountScheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    children: number
    students: number
    messages: number
    events: number
    scheduleItems: number
    assignedStaff: number
    childInvitationLinks: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ClassCountOutputTypeCountChildrenArgs
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
    messages?: boolean | ClassCountOutputTypeCountMessagesArgs
    events?: boolean | ClassCountOutputTypeCountEventsArgs
    scheduleItems?: boolean | ClassCountOutputTypeCountScheduleItemsArgs
    assignedStaff?: boolean | ClassCountOutputTypeCountAssignedStaffArgs
    childInvitationLinks?: boolean | ClassCountOutputTypeCountChildInvitationLinksArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountScheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAssignedStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffClassAssignmentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountChildInvitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildInvitationLinkWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    acknowledgments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acknowledgments?: boolean | MessageCountOutputTypeCountAcknowledgmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAcknowledgmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAcknowledgmentWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    rsvps: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rsvps?: boolean | EventCountOutputTypeCountRsvpsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRsvpWhereInput
  }


  /**
   * Count Type WeeklyMessageCountOutputType
   */

  export type WeeklyMessageCountOutputType = {
    hearts: number
  }

  export type WeeklyMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hearts?: boolean | WeeklyMessageCountOutputTypeCountHeartsArgs
  }

  // Custom InputTypes
  /**
   * WeeklyMessageCountOutputType without action
   */
  export type WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageCountOutputType
     */
    select?: WeeklyMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeeklyMessageCountOutputType without action
   */
  export type WeeklyMessageCountOutputTypeCountHeartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageHeartWhereInput
  }


  /**
   * Count Type KnowledgeCategoryCountOutputType
   */

  export type KnowledgeCategoryCountOutputType = {
    articles: number
  }

  export type KnowledgeCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | KnowledgeCategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeCategoryCountOutputType without action
   */
  export type KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategoryCountOutputType
     */
    select?: KnowledgeCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeCategoryCountOutputType without action
   */
  export type KnowledgeCategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeArticleWhereInput
  }


  /**
   * Count Type PulseSurveyCountOutputType
   */

  export type PulseSurveyCountOutputType = {
    responses: number
  }

  export type PulseSurveyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | PulseSurveyCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * PulseSurveyCountOutputType without action
   */
  export type PulseSurveyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurveyCountOutputType
     */
    select?: PulseSurveyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PulseSurveyCountOutputType without action
   */
  export type PulseSurveyCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseResponseWhereInput
  }


  /**
   * Count Type FileFolderCountOutputType
   */

  export type FileFolderCountOutputType = {
    children: number
    files: number
  }

  export type FileFolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FileFolderCountOutputTypeCountChildrenArgs
    files?: boolean | FileFolderCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolderCountOutputType
     */
    select?: FileFolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
  }

  /**
   * FileFolderCountOutputType without action
   */
  export type FileFolderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolFileWhereInput
  }


  /**
   * Count Type FormCountOutputType
   */

  export type FormCountOutputType = {
    responses: number
  }

  export type FormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | FormCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     */
    select?: FormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
  }


  /**
   * Count Type ParentInvitationCountOutputType
   */

  export type ParentInvitationCountOutputType = {
    childLinks: number
    studentLinks: number
  }

  export type ParentInvitationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childLinks?: boolean | ParentInvitationCountOutputTypeCountChildLinksArgs
    studentLinks?: boolean | ParentInvitationCountOutputTypeCountStudentLinksArgs
  }

  // Custom InputTypes
  /**
   * ParentInvitationCountOutputType without action
   */
  export type ParentInvitationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitationCountOutputType
     */
    select?: ParentInvitationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentInvitationCountOutputType without action
   */
  export type ParentInvitationCountOutputTypeCountChildLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildInvitationLinkWhereInput
  }

  /**
   * ParentInvitationCountOutputType without action
   */
  export type ParentInvitationCountOutputTypeCountStudentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentInvitationLinkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    city: string | null
    academicYear: string | null
    brandColor: string | null
    accentColor: string | null
    tagline: string | null
    logoUrl: string | null
    logoIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    city: string | null
    academicYear: string | null
    brandColor: string | null
    accentColor: string | null
    tagline: string | null
    logoUrl: string | null
    logoIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    city: number
    academicYear: number
    brandColor: number
    accentColor: number
    tagline: number
    logoUrl: number
    logoIconUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    city?: true
    academicYear?: true
    brandColor?: true
    accentColor?: true
    tagline?: true
    logoUrl?: true
    logoIconUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    city?: true
    academicYear?: true
    brandColor?: true
    accentColor?: true
    tagline?: true
    logoUrl?: true
    logoIconUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    city?: true
    academicYear?: true
    brandColor?: true
    accentColor?: true
    tagline?: true
    logoUrl?: true
    logoIconUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    shortName: string
    city: string
    academicYear: string
    brandColor: string
    accentColor: string
    tagline: string | null
    logoUrl: string | null
    logoIconUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    city?: boolean
    academicYear?: boolean
    brandColor?: boolean
    accentColor?: boolean
    tagline?: boolean
    logoUrl?: boolean
    logoIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | School$usersArgs<ExtArgs>
    yearGroups?: boolean | School$yearGroupsArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    students?: boolean | School$studentsArgs<ExtArgs>
    messages?: boolean | School$messagesArgs<ExtArgs>
    forms?: boolean | School$formsArgs<ExtArgs>
    events?: boolean | School$eventsArgs<ExtArgs>
    termDates?: boolean | School$termDatesArgs<ExtArgs>
    scheduleItems?: boolean | School$scheduleItemsArgs<ExtArgs>
    weeklyMessages?: boolean | School$weeklyMessagesArgs<ExtArgs>
    knowledgeCategories?: boolean | School$knowledgeCategoriesArgs<ExtArgs>
    pulseSurveys?: boolean | School$pulseSurveysArgs<ExtArgs>
    policies?: boolean | School$policiesArgs<ExtArgs>
    folders?: boolean | School$foldersArgs<ExtArgs>
    files?: boolean | School$filesArgs<ExtArgs>
    auditLogs?: boolean | School$auditLogsArgs<ExtArgs>
    notifications?: boolean | School$notificationsArgs<ExtArgs>
    invitations?: boolean | School$invitationsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    city?: boolean
    academicYear?: boolean
    brandColor?: boolean
    accentColor?: boolean
    tagline?: boolean
    logoUrl?: boolean
    logoIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    city?: boolean
    academicYear?: boolean
    brandColor?: boolean
    accentColor?: boolean
    tagline?: boolean
    logoUrl?: boolean
    logoIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | School$usersArgs<ExtArgs>
    yearGroups?: boolean | School$yearGroupsArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    students?: boolean | School$studentsArgs<ExtArgs>
    messages?: boolean | School$messagesArgs<ExtArgs>
    forms?: boolean | School$formsArgs<ExtArgs>
    events?: boolean | School$eventsArgs<ExtArgs>
    termDates?: boolean | School$termDatesArgs<ExtArgs>
    scheduleItems?: boolean | School$scheduleItemsArgs<ExtArgs>
    weeklyMessages?: boolean | School$weeklyMessagesArgs<ExtArgs>
    knowledgeCategories?: boolean | School$knowledgeCategoriesArgs<ExtArgs>
    pulseSurveys?: boolean | School$pulseSurveysArgs<ExtArgs>
    policies?: boolean | School$policiesArgs<ExtArgs>
    folders?: boolean | School$foldersArgs<ExtArgs>
    files?: boolean | School$filesArgs<ExtArgs>
    auditLogs?: boolean | School$auditLogsArgs<ExtArgs>
    notifications?: boolean | School$notificationsArgs<ExtArgs>
    invitations?: boolean | School$invitationsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      yearGroups: Prisma.$YearGroupPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      forms: Prisma.$FormPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      termDates: Prisma.$TermDatePayload<ExtArgs>[]
      scheduleItems: Prisma.$ScheduleItemPayload<ExtArgs>[]
      weeklyMessages: Prisma.$WeeklyMessagePayload<ExtArgs>[]
      knowledgeCategories: Prisma.$KnowledgeCategoryPayload<ExtArgs>[]
      pulseSurveys: Prisma.$PulseSurveyPayload<ExtArgs>[]
      policies: Prisma.$PolicyPayload<ExtArgs>[]
      folders: Prisma.$FileFolderPayload<ExtArgs>[]
      files: Prisma.$SchoolFilePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      invitations: Prisma.$ParentInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      shortName: string
      city: string
      academicYear: string
      brandColor: string
      accentColor: string
      tagline: string | null
      logoUrl: string | null
      logoIconUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    yearGroups<T extends School$yearGroupsArgs<ExtArgs> = {}>(args?: Subset<T, School$yearGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends School$classesArgs<ExtArgs> = {}>(args?: Subset<T, School$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends School$studentsArgs<ExtArgs> = {}>(args?: Subset<T, School$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends School$messagesArgs<ExtArgs> = {}>(args?: Subset<T, School$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    forms<T extends School$formsArgs<ExtArgs> = {}>(args?: Subset<T, School$formsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends School$eventsArgs<ExtArgs> = {}>(args?: Subset<T, School$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    termDates<T extends School$termDatesArgs<ExtArgs> = {}>(args?: Subset<T, School$termDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findMany"> | Null>
    scheduleItems<T extends School$scheduleItemsArgs<ExtArgs> = {}>(args?: Subset<T, School$scheduleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany"> | Null>
    weeklyMessages<T extends School$weeklyMessagesArgs<ExtArgs> = {}>(args?: Subset<T, School$weeklyMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findMany"> | Null>
    knowledgeCategories<T extends School$knowledgeCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, School$knowledgeCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    pulseSurveys<T extends School$pulseSurveysArgs<ExtArgs> = {}>(args?: Subset<T, School$pulseSurveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findMany"> | Null>
    policies<T extends School$policiesArgs<ExtArgs> = {}>(args?: Subset<T, School$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany"> | Null>
    folders<T extends School$foldersArgs<ExtArgs> = {}>(args?: Subset<T, School$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends School$filesArgs<ExtArgs> = {}>(args?: Subset<T, School$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends School$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, School$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends School$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, School$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends School$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, School$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly shortName: FieldRef<"School", 'String'>
    readonly city: FieldRef<"School", 'String'>
    readonly academicYear: FieldRef<"School", 'String'>
    readonly brandColor: FieldRef<"School", 'String'>
    readonly accentColor: FieldRef<"School", 'String'>
    readonly tagline: FieldRef<"School", 'String'>
    readonly logoUrl: FieldRef<"School", 'String'>
    readonly logoIconUrl: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.yearGroups
   */
  export type School$yearGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    where?: YearGroupWhereInput
    orderBy?: YearGroupOrderByWithRelationInput | YearGroupOrderByWithRelationInput[]
    cursor?: YearGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearGroupScalarFieldEnum | YearGroupScalarFieldEnum[]
  }

  /**
   * School.classes
   */
  export type School$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * School.students
   */
  export type School$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * School.messages
   */
  export type School$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * School.forms
   */
  export type School$formsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    cursor?: FormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * School.events
   */
  export type School$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * School.termDates
   */
  export type School$termDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    where?: TermDateWhereInput
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    cursor?: TermDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * School.scheduleItems
   */
  export type School$scheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * School.weeklyMessages
   */
  export type School$weeklyMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    where?: WeeklyMessageWhereInput
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    cursor?: WeeklyMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * School.knowledgeCategories
   */
  export type School$knowledgeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    where?: KnowledgeCategoryWhereInput
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    cursor?: KnowledgeCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * School.pulseSurveys
   */
  export type School$pulseSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    where?: PulseSurveyWhereInput
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    cursor?: PulseSurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * School.policies
   */
  export type School$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * School.folders
   */
  export type School$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    cursor?: FileFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * School.files
   */
  export type School$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    where?: SchoolFileWhereInput
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    cursor?: SchoolFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * School.auditLogs
   */
  export type School$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * School.notifications
   */
  export type School$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * School.invitations
   */
  export type School$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    where?: ParentInvitationWhereInput
    orderBy?: ParentInvitationOrderByWithRelationInput | ParentInvitationOrderByWithRelationInput[]
    cursor?: ParentInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentInvitationScalarFieldEnum | ParentInvitationScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    schoolId: string | null
    googleId: string | null
    microsoftId: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    schoolId: string | null
    googleId: string | null
    microsoftId: string | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    schoolId: number
    googleId: number
    microsoftId: number
    avatarUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    schoolId?: true
    googleId?: true
    microsoftId?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    schoolId?: true
    googleId?: true
    microsoftId?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    schoolId?: true
    googleId?: true
    microsoftId?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: $Enums.Role
    schoolId: string
    googleId: string | null
    microsoftId: string | null
    avatarUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    schoolId?: boolean
    googleId?: boolean
    microsoftId?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    children?: boolean | User$childrenArgs<ExtArgs>
    studentLinks?: boolean | User$studentLinksArgs<ExtArgs>
    assignedClasses?: boolean | User$assignedClassesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    messageAcks?: boolean | User$messageAcksArgs<ExtArgs>
    formResponses?: boolean | User$formResponsesArgs<ExtArgs>
    eventRsvps?: boolean | User$eventRsvpsArgs<ExtArgs>
    pulseResponses?: boolean | User$pulseResponsesArgs<ExtArgs>
    weeklyHearts?: boolean | User$weeklyHeartsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    createdInvitations?: boolean | User$createdInvitationsArgs<ExtArgs>
    redeemedInvitations?: boolean | User$redeemedInvitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    schoolId?: boolean
    googleId?: boolean
    microsoftId?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    schoolId?: boolean
    googleId?: boolean
    microsoftId?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    children?: boolean | User$childrenArgs<ExtArgs>
    studentLinks?: boolean | User$studentLinksArgs<ExtArgs>
    assignedClasses?: boolean | User$assignedClassesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    messageAcks?: boolean | User$messageAcksArgs<ExtArgs>
    formResponses?: boolean | User$formResponsesArgs<ExtArgs>
    eventRsvps?: boolean | User$eventRsvpsArgs<ExtArgs>
    pulseResponses?: boolean | User$pulseResponsesArgs<ExtArgs>
    weeklyHearts?: boolean | User$weeklyHeartsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    createdInvitations?: boolean | User$createdInvitationsArgs<ExtArgs>
    redeemedInvitations?: boolean | User$redeemedInvitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      children: Prisma.$ChildPayload<ExtArgs>[]
      studentLinks: Prisma.$ParentStudentLinkPayload<ExtArgs>[]
      assignedClasses: Prisma.$StaffClassAssignmentPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      messageAcks: Prisma.$MessageAcknowledgmentPayload<ExtArgs>[]
      formResponses: Prisma.$FormResponsePayload<ExtArgs>[]
      eventRsvps: Prisma.$EventRsvpPayload<ExtArgs>[]
      pulseResponses: Prisma.$PulseResponsePayload<ExtArgs>[]
      weeklyHearts: Prisma.$WeeklyMessageHeartPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      deviceTokens: Prisma.$DeviceTokenPayload<ExtArgs>[]
      createdInvitations: Prisma.$ParentInvitationPayload<ExtArgs>[]
      redeemedInvitations: Prisma.$ParentInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: $Enums.Role
      schoolId: string
      googleId: string | null
      microsoftId: string | null
      avatarUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    children<T extends User$childrenArgs<ExtArgs> = {}>(args?: Subset<T, User$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany"> | Null>
    studentLinks<T extends User$studentLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$studentLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "findMany"> | Null>
    assignedClasses<T extends User$assignedClassesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    messageAcks<T extends User$messageAcksArgs<ExtArgs> = {}>(args?: Subset<T, User$messageAcksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findMany"> | Null>
    formResponses<T extends User$formResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$formResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findMany"> | Null>
    eventRsvps<T extends User$eventRsvpsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventRsvpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findMany"> | Null>
    pulseResponses<T extends User$pulseResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$pulseResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findMany"> | Null>
    weeklyHearts<T extends User$weeklyHeartsArgs<ExtArgs> = {}>(args?: Subset<T, User$weeklyHeartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findMany"> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    deviceTokens<T extends User$deviceTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany"> | Null>
    createdInvitations<T extends User$createdInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    redeemedInvitations<T extends User$redeemedInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$redeemedInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly microsoftId: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.children
   */
  export type User$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    cursor?: ChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * User.studentLinks
   */
  export type User$studentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    where?: ParentStudentLinkWhereInput
    orderBy?: ParentStudentLinkOrderByWithRelationInput | ParentStudentLinkOrderByWithRelationInput[]
    cursor?: ParentStudentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentStudentLinkScalarFieldEnum | ParentStudentLinkScalarFieldEnum[]
  }

  /**
   * User.assignedClasses
   */
  export type User$assignedClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    where?: StaffClassAssignmentWhereInput
    orderBy?: StaffClassAssignmentOrderByWithRelationInput | StaffClassAssignmentOrderByWithRelationInput[]
    cursor?: StaffClassAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffClassAssignmentScalarFieldEnum | StaffClassAssignmentScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.messageAcks
   */
  export type User$messageAcksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    where?: MessageAcknowledgmentWhereInput
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    cursor?: MessageAcknowledgmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * User.formResponses
   */
  export type User$formResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    cursor?: FormResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * User.eventRsvps
   */
  export type User$eventRsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    where?: EventRsvpWhereInput
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    cursor?: EventRsvpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * User.pulseResponses
   */
  export type User$pulseResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    where?: PulseResponseWhereInput
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    cursor?: PulseResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * User.weeklyHearts
   */
  export type User$weeklyHeartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    where?: WeeklyMessageHeartWhereInput
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    cursor?: WeeklyMessageHeartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.deviceTokens
   */
  export type User$deviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    cursor?: DeviceTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * User.createdInvitations
   */
  export type User$createdInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    where?: ParentInvitationWhereInput
    orderBy?: ParentInvitationOrderByWithRelationInput | ParentInvitationOrderByWithRelationInput[]
    cursor?: ParentInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentInvitationScalarFieldEnum | ParentInvitationScalarFieldEnum[]
  }

  /**
   * User.redeemedInvitations
   */
  export type User$redeemedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    where?: ParentInvitationWhereInput
    orderBy?: ParentInvitationOrderByWithRelationInput | ParentInvitationOrderByWithRelationInput[]
    cursor?: ParentInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentInvitationScalarFieldEnum | ParentInvitationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Child
   */

  export type AggregateChild = {
    _count: ChildCountAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  export type ChildMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    classId: string | null
  }

  export type ChildMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    classId: string | null
  }

  export type ChildCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    classId: number
    _all: number
  }


  export type ChildMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    classId?: true
  }

  export type ChildMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    classId?: true
  }

  export type ChildCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    classId?: true
    _all?: true
  }

  export type ChildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Child to aggregate.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Children
    **/
    _count?: true | ChildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildMaxAggregateInputType
  }

  export type GetChildAggregateType<T extends ChildAggregateArgs> = {
        [P in keyof T & keyof AggregateChild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChild[P]>
      : GetScalarType<T[P], AggregateChild[P]>
  }




  export type ChildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithAggregationInput | ChildOrderByWithAggregationInput[]
    by: ChildScalarFieldEnum[] | ChildScalarFieldEnum
    having?: ChildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildCountAggregateInputType | true
    _min?: ChildMinAggregateInputType
    _max?: ChildMaxAggregateInputType
  }

  export type ChildGroupByOutputType = {
    id: string
    name: string
    parentId: string
    classId: string
    _count: ChildCountAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  type GetChildGroupByPayload<T extends ChildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildGroupByOutputType[P]>
            : GetScalarType<T[P], ChildGroupByOutputType[P]>
        }
      >
    >


  export type ChildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    classId?: boolean
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    classId?: boolean
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    classId?: boolean
  }

  export type ChildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ChildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ChildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Child"
    objects: {
      parent: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      parentId: string
      classId: string
    }, ExtArgs["result"]["child"]>
    composites: {}
  }

  type ChildGetPayload<S extends boolean | null | undefined | ChildDefaultArgs> = $Result.GetResult<Prisma.$ChildPayload, S>

  type ChildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChildFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChildCountAggregateInputType | true
    }

  export interface ChildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Child'], meta: { name: 'Child' } }
    /**
     * Find zero or one Child that matches the filter.
     * @param {ChildFindUniqueArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChildFindUniqueArgs>(args: SelectSubset<T, ChildFindUniqueArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Child that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChildFindUniqueOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChildFindUniqueOrThrowArgs>(args: SelectSubset<T, ChildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Child that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChildFindFirstArgs>(args?: SelectSubset<T, ChildFindFirstArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Child that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChildFindFirstOrThrowArgs>(args?: SelectSubset<T, ChildFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Children that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Children
     * const children = await prisma.child.findMany()
     * 
     * // Get first 10 Children
     * const children = await prisma.child.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childWithIdOnly = await prisma.child.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChildFindManyArgs>(args?: SelectSubset<T, ChildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Child.
     * @param {ChildCreateArgs} args - Arguments to create a Child.
     * @example
     * // Create one Child
     * const Child = await prisma.child.create({
     *   data: {
     *     // ... data to create a Child
     *   }
     * })
     * 
     */
    create<T extends ChildCreateArgs>(args: SelectSubset<T, ChildCreateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Children.
     * @param {ChildCreateManyArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChildCreateManyArgs>(args?: SelectSubset<T, ChildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Children and returns the data saved in the database.
     * @param {ChildCreateManyAndReturnArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Children and only return the `id`
     * const childWithIdOnly = await prisma.child.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChildCreateManyAndReturnArgs>(args?: SelectSubset<T, ChildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Child.
     * @param {ChildDeleteArgs} args - Arguments to delete one Child.
     * @example
     * // Delete one Child
     * const Child = await prisma.child.delete({
     *   where: {
     *     // ... filter to delete one Child
     *   }
     * })
     * 
     */
    delete<T extends ChildDeleteArgs>(args: SelectSubset<T, ChildDeleteArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Child.
     * @param {ChildUpdateArgs} args - Arguments to update one Child.
     * @example
     * // Update one Child
     * const child = await prisma.child.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChildUpdateArgs>(args: SelectSubset<T, ChildUpdateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Children.
     * @param {ChildDeleteManyArgs} args - Arguments to filter Children to delete.
     * @example
     * // Delete a few Children
     * const { count } = await prisma.child.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChildDeleteManyArgs>(args?: SelectSubset<T, ChildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Children
     * const child = await prisma.child.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChildUpdateManyArgs>(args: SelectSubset<T, ChildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Child.
     * @param {ChildUpsertArgs} args - Arguments to update or create a Child.
     * @example
     * // Update or create a Child
     * const child = await prisma.child.upsert({
     *   create: {
     *     // ... data to create a Child
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Child we want to update
     *   }
     * })
     */
    upsert<T extends ChildUpsertArgs>(args: SelectSubset<T, ChildUpsertArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildCountArgs} args - Arguments to filter Children to count.
     * @example
     * // Count the number of Children
     * const count = await prisma.child.count({
     *   where: {
     *     // ... the filter for the Children we want to count
     *   }
     * })
    **/
    count<T extends ChildCountArgs>(
      args?: Subset<T, ChildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildAggregateArgs>(args: Subset<T, ChildAggregateArgs>): Prisma.PrismaPromise<GetChildAggregateType<T>>

    /**
     * Group by Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildGroupByArgs['orderBy'] }
        : { orderBy?: ChildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Child model
   */
  readonly fields: ChildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Child.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Child model
   */ 
  interface ChildFieldRefs {
    readonly id: FieldRef<"Child", 'String'>
    readonly name: FieldRef<"Child", 'String'>
    readonly parentId: FieldRef<"Child", 'String'>
    readonly classId: FieldRef<"Child", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Child findUnique
   */
  export type ChildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findUniqueOrThrow
   */
  export type ChildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findFirst
   */
  export type ChildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findFirstOrThrow
   */
  export type ChildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findMany
   */
  export type ChildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Children to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child create
   */
  export type ChildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to create a Child.
     */
    data: XOR<ChildCreateInput, ChildUncheckedCreateInput>
  }

  /**
   * Child createMany
   */
  export type ChildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Child createManyAndReturn
   */
  export type ChildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Child update
   */
  export type ChildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to update a Child.
     */
    data: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
    /**
     * Choose, which Child to update.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child updateMany
   */
  export type ChildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Children.
     */
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyInput>
    /**
     * Filter which Children to update
     */
    where?: ChildWhereInput
  }

  /**
   * Child upsert
   */
  export type ChildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The filter to search for the Child to update in case it exists.
     */
    where: ChildWhereUniqueInput
    /**
     * In case the Child found by the `where` argument doesn't exist, create a new Child with this data.
     */
    create: XOR<ChildCreateInput, ChildUncheckedCreateInput>
    /**
     * In case the Child was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
  }

  /**
   * Child delete
   */
  export type ChildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter which Child to delete.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child deleteMany
   */
  export type ChildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Children to delete
     */
    where?: ChildWhereInput
  }

  /**
   * Child without action
   */
  export type ChildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    externalId: string | null
    schoolId: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    externalId: string | null
    schoolId: string | null
    classId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    externalId: number
    schoolId: number
    classId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    externalId?: true
    schoolId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    externalId?: true
    schoolId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    externalId?: true
    schoolId?: true
    classId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    externalId: string | null
    schoolId: string
    classId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    externalId?: boolean
    schoolId?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    parentLinks?: boolean | Student$parentLinksArgs<ExtArgs>
    invitationLinks?: boolean | Student$invitationLinksArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    externalId?: boolean
    schoolId?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    externalId?: boolean
    schoolId?: boolean
    classId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    parentLinks?: boolean | Student$parentLinksArgs<ExtArgs>
    invitationLinks?: boolean | Student$invitationLinksArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      parentLinks: Prisma.$ParentStudentLinkPayload<ExtArgs>[]
      invitationLinks: Prisma.$StudentInvitationLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      externalId: string | null
      schoolId: string
      classId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parentLinks<T extends Student$parentLinksArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "findMany"> | Null>
    invitationLinks<T extends Student$invitationLinksArgs<ExtArgs> = {}>(args?: Subset<T, Student$invitationLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly externalId: FieldRef<"Student", 'String'>
    readonly schoolId: FieldRef<"Student", 'String'>
    readonly classId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.parentLinks
   */
  export type Student$parentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    where?: ParentStudentLinkWhereInput
    orderBy?: ParentStudentLinkOrderByWithRelationInput | ParentStudentLinkOrderByWithRelationInput[]
    cursor?: ParentStudentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentStudentLinkScalarFieldEnum | ParentStudentLinkScalarFieldEnum[]
  }

  /**
   * Student.invitationLinks
   */
  export type Student$invitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    where?: StudentInvitationLinkWhereInput
    orderBy?: StudentInvitationLinkOrderByWithRelationInput | StudentInvitationLinkOrderByWithRelationInput[]
    cursor?: StudentInvitationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentInvitationLinkScalarFieldEnum | StudentInvitationLinkScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model ParentStudentLink
   */

  export type AggregateParentStudentLink = {
    _count: ParentStudentLinkCountAggregateOutputType | null
    _min: ParentStudentLinkMinAggregateOutputType | null
    _max: ParentStudentLinkMaxAggregateOutputType | null
  }

  export type ParentStudentLinkMinAggregateOutputType = {
    id: string | null
    userId: string | null
    studentId: string | null
    createdAt: Date | null
  }

  export type ParentStudentLinkMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    studentId: string | null
    createdAt: Date | null
  }

  export type ParentStudentLinkCountAggregateOutputType = {
    id: number
    userId: number
    studentId: number
    createdAt: number
    _all: number
  }


  export type ParentStudentLinkMinAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    createdAt?: true
  }

  export type ParentStudentLinkMaxAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    createdAt?: true
  }

  export type ParentStudentLinkCountAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    createdAt?: true
    _all?: true
  }

  export type ParentStudentLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentStudentLink to aggregate.
     */
    where?: ParentStudentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudentLinks to fetch.
     */
    orderBy?: ParentStudentLinkOrderByWithRelationInput | ParentStudentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentStudentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentStudentLinks
    **/
    _count?: true | ParentStudentLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentStudentLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentStudentLinkMaxAggregateInputType
  }

  export type GetParentStudentLinkAggregateType<T extends ParentStudentLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateParentStudentLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentStudentLink[P]>
      : GetScalarType<T[P], AggregateParentStudentLink[P]>
  }




  export type ParentStudentLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentStudentLinkWhereInput
    orderBy?: ParentStudentLinkOrderByWithAggregationInput | ParentStudentLinkOrderByWithAggregationInput[]
    by: ParentStudentLinkScalarFieldEnum[] | ParentStudentLinkScalarFieldEnum
    having?: ParentStudentLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentStudentLinkCountAggregateInputType | true
    _min?: ParentStudentLinkMinAggregateInputType
    _max?: ParentStudentLinkMaxAggregateInputType
  }

  export type ParentStudentLinkGroupByOutputType = {
    id: string
    userId: string
    studentId: string
    createdAt: Date
    _count: ParentStudentLinkCountAggregateOutputType | null
    _min: ParentStudentLinkMinAggregateOutputType | null
    _max: ParentStudentLinkMaxAggregateOutputType | null
  }

  type GetParentStudentLinkGroupByPayload<T extends ParentStudentLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentStudentLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentStudentLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentStudentLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ParentStudentLinkGroupByOutputType[P]>
        }
      >
    >


  export type ParentStudentLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentStudentLink"]>

  export type ParentStudentLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentStudentLink"]>

  export type ParentStudentLinkSelectScalar = {
    id?: boolean
    userId?: boolean
    studentId?: boolean
    createdAt?: boolean
  }

  export type ParentStudentLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type ParentStudentLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $ParentStudentLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParentStudentLink"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      studentId: string
      createdAt: Date
    }, ExtArgs["result"]["parentStudentLink"]>
    composites: {}
  }

  type ParentStudentLinkGetPayload<S extends boolean | null | undefined | ParentStudentLinkDefaultArgs> = $Result.GetResult<Prisma.$ParentStudentLinkPayload, S>

  type ParentStudentLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentStudentLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentStudentLinkCountAggregateInputType | true
    }

  export interface ParentStudentLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParentStudentLink'], meta: { name: 'ParentStudentLink' } }
    /**
     * Find zero or one ParentStudentLink that matches the filter.
     * @param {ParentStudentLinkFindUniqueArgs} args - Arguments to find a ParentStudentLink
     * @example
     * // Get one ParentStudentLink
     * const parentStudentLink = await prisma.parentStudentLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentStudentLinkFindUniqueArgs>(args: SelectSubset<T, ParentStudentLinkFindUniqueArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParentStudentLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParentStudentLinkFindUniqueOrThrowArgs} args - Arguments to find a ParentStudentLink
     * @example
     * // Get one ParentStudentLink
     * const parentStudentLink = await prisma.parentStudentLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentStudentLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentStudentLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParentStudentLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentLinkFindFirstArgs} args - Arguments to find a ParentStudentLink
     * @example
     * // Get one ParentStudentLink
     * const parentStudentLink = await prisma.parentStudentLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentStudentLinkFindFirstArgs>(args?: SelectSubset<T, ParentStudentLinkFindFirstArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParentStudentLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentLinkFindFirstOrThrowArgs} args - Arguments to find a ParentStudentLink
     * @example
     * // Get one ParentStudentLink
     * const parentStudentLink = await prisma.parentStudentLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentStudentLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentStudentLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParentStudentLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentStudentLinks
     * const parentStudentLinks = await prisma.parentStudentLink.findMany()
     * 
     * // Get first 10 ParentStudentLinks
     * const parentStudentLinks = await prisma.parentStudentLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentStudentLinkWithIdOnly = await prisma.parentStudentLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentStudentLinkFindManyArgs>(args?: SelectSubset<T, ParentStudentLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParentStudentLink.
     * @param {ParentStudentLinkCreateArgs} args - Arguments to create a ParentStudentLink.
     * @example
     * // Create one ParentStudentLink
     * const ParentStudentLink = await prisma.parentStudentLink.create({
     *   data: {
     *     // ... data to create a ParentStudentLink
     *   }
     * })
     * 
     */
    create<T extends ParentStudentLinkCreateArgs>(args: SelectSubset<T, ParentStudentLinkCreateArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParentStudentLinks.
     * @param {ParentStudentLinkCreateManyArgs} args - Arguments to create many ParentStudentLinks.
     * @example
     * // Create many ParentStudentLinks
     * const parentStudentLink = await prisma.parentStudentLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentStudentLinkCreateManyArgs>(args?: SelectSubset<T, ParentStudentLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParentStudentLinks and returns the data saved in the database.
     * @param {ParentStudentLinkCreateManyAndReturnArgs} args - Arguments to create many ParentStudentLinks.
     * @example
     * // Create many ParentStudentLinks
     * const parentStudentLink = await prisma.parentStudentLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParentStudentLinks and only return the `id`
     * const parentStudentLinkWithIdOnly = await prisma.parentStudentLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentStudentLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentStudentLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParentStudentLink.
     * @param {ParentStudentLinkDeleteArgs} args - Arguments to delete one ParentStudentLink.
     * @example
     * // Delete one ParentStudentLink
     * const ParentStudentLink = await prisma.parentStudentLink.delete({
     *   where: {
     *     // ... filter to delete one ParentStudentLink
     *   }
     * })
     * 
     */
    delete<T extends ParentStudentLinkDeleteArgs>(args: SelectSubset<T, ParentStudentLinkDeleteArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParentStudentLink.
     * @param {ParentStudentLinkUpdateArgs} args - Arguments to update one ParentStudentLink.
     * @example
     * // Update one ParentStudentLink
     * const parentStudentLink = await prisma.parentStudentLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentStudentLinkUpdateArgs>(args: SelectSubset<T, ParentStudentLinkUpdateArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParentStudentLinks.
     * @param {ParentStudentLinkDeleteManyArgs} args - Arguments to filter ParentStudentLinks to delete.
     * @example
     * // Delete a few ParentStudentLinks
     * const { count } = await prisma.parentStudentLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentStudentLinkDeleteManyArgs>(args?: SelectSubset<T, ParentStudentLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentStudentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentStudentLinks
     * const parentStudentLink = await prisma.parentStudentLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentStudentLinkUpdateManyArgs>(args: SelectSubset<T, ParentStudentLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParentStudentLink.
     * @param {ParentStudentLinkUpsertArgs} args - Arguments to update or create a ParentStudentLink.
     * @example
     * // Update or create a ParentStudentLink
     * const parentStudentLink = await prisma.parentStudentLink.upsert({
     *   create: {
     *     // ... data to create a ParentStudentLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentStudentLink we want to update
     *   }
     * })
     */
    upsert<T extends ParentStudentLinkUpsertArgs>(args: SelectSubset<T, ParentStudentLinkUpsertArgs<ExtArgs>>): Prisma__ParentStudentLinkClient<$Result.GetResult<Prisma.$ParentStudentLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParentStudentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentLinkCountArgs} args - Arguments to filter ParentStudentLinks to count.
     * @example
     * // Count the number of ParentStudentLinks
     * const count = await prisma.parentStudentLink.count({
     *   where: {
     *     // ... the filter for the ParentStudentLinks we want to count
     *   }
     * })
    **/
    count<T extends ParentStudentLinkCountArgs>(
      args?: Subset<T, ParentStudentLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentStudentLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentStudentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentStudentLinkAggregateArgs>(args: Subset<T, ParentStudentLinkAggregateArgs>): Prisma.PrismaPromise<GetParentStudentLinkAggregateType<T>>

    /**
     * Group by ParentStudentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentStudentLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentStudentLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentStudentLinkGroupByArgs['orderBy'] }
        : { orderBy?: ParentStudentLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentStudentLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentStudentLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParentStudentLink model
   */
  readonly fields: ParentStudentLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentStudentLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentStudentLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParentStudentLink model
   */ 
  interface ParentStudentLinkFieldRefs {
    readonly id: FieldRef<"ParentStudentLink", 'String'>
    readonly userId: FieldRef<"ParentStudentLink", 'String'>
    readonly studentId: FieldRef<"ParentStudentLink", 'String'>
    readonly createdAt: FieldRef<"ParentStudentLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParentStudentLink findUnique
   */
  export type ParentStudentLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudentLink to fetch.
     */
    where: ParentStudentLinkWhereUniqueInput
  }

  /**
   * ParentStudentLink findUniqueOrThrow
   */
  export type ParentStudentLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudentLink to fetch.
     */
    where: ParentStudentLinkWhereUniqueInput
  }

  /**
   * ParentStudentLink findFirst
   */
  export type ParentStudentLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudentLink to fetch.
     */
    where?: ParentStudentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudentLinks to fetch.
     */
    orderBy?: ParentStudentLinkOrderByWithRelationInput | ParentStudentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentStudentLinks.
     */
    cursor?: ParentStudentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentStudentLinks.
     */
    distinct?: ParentStudentLinkScalarFieldEnum | ParentStudentLinkScalarFieldEnum[]
  }

  /**
   * ParentStudentLink findFirstOrThrow
   */
  export type ParentStudentLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudentLink to fetch.
     */
    where?: ParentStudentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudentLinks to fetch.
     */
    orderBy?: ParentStudentLinkOrderByWithRelationInput | ParentStudentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentStudentLinks.
     */
    cursor?: ParentStudentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentStudentLinks.
     */
    distinct?: ParentStudentLinkScalarFieldEnum | ParentStudentLinkScalarFieldEnum[]
  }

  /**
   * ParentStudentLink findMany
   */
  export type ParentStudentLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * Filter, which ParentStudentLinks to fetch.
     */
    where?: ParentStudentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentStudentLinks to fetch.
     */
    orderBy?: ParentStudentLinkOrderByWithRelationInput | ParentStudentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentStudentLinks.
     */
    cursor?: ParentStudentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentStudentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentStudentLinks.
     */
    skip?: number
    distinct?: ParentStudentLinkScalarFieldEnum | ParentStudentLinkScalarFieldEnum[]
  }

  /**
   * ParentStudentLink create
   */
  export type ParentStudentLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ParentStudentLink.
     */
    data: XOR<ParentStudentLinkCreateInput, ParentStudentLinkUncheckedCreateInput>
  }

  /**
   * ParentStudentLink createMany
   */
  export type ParentStudentLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParentStudentLinks.
     */
    data: ParentStudentLinkCreateManyInput | ParentStudentLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParentStudentLink createManyAndReturn
   */
  export type ParentStudentLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParentStudentLinks.
     */
    data: ParentStudentLinkCreateManyInput | ParentStudentLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParentStudentLink update
   */
  export type ParentStudentLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ParentStudentLink.
     */
    data: XOR<ParentStudentLinkUpdateInput, ParentStudentLinkUncheckedUpdateInput>
    /**
     * Choose, which ParentStudentLink to update.
     */
    where: ParentStudentLinkWhereUniqueInput
  }

  /**
   * ParentStudentLink updateMany
   */
  export type ParentStudentLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParentStudentLinks.
     */
    data: XOR<ParentStudentLinkUpdateManyMutationInput, ParentStudentLinkUncheckedUpdateManyInput>
    /**
     * Filter which ParentStudentLinks to update
     */
    where?: ParentStudentLinkWhereInput
  }

  /**
   * ParentStudentLink upsert
   */
  export type ParentStudentLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ParentStudentLink to update in case it exists.
     */
    where: ParentStudentLinkWhereUniqueInput
    /**
     * In case the ParentStudentLink found by the `where` argument doesn't exist, create a new ParentStudentLink with this data.
     */
    create: XOR<ParentStudentLinkCreateInput, ParentStudentLinkUncheckedCreateInput>
    /**
     * In case the ParentStudentLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentStudentLinkUpdateInput, ParentStudentLinkUncheckedUpdateInput>
  }

  /**
   * ParentStudentLink delete
   */
  export type ParentStudentLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
    /**
     * Filter which ParentStudentLink to delete.
     */
    where: ParentStudentLinkWhereUniqueInput
  }

  /**
   * ParentStudentLink deleteMany
   */
  export type ParentStudentLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentStudentLinks to delete
     */
    where?: ParentStudentLinkWhereInput
  }

  /**
   * ParentStudentLink without action
   */
  export type ParentStudentLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentStudentLink
     */
    select?: ParentStudentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentStudentLinkInclude<ExtArgs> | null
  }


  /**
   * Model StudentInvitationLink
   */

  export type AggregateStudentInvitationLink = {
    _count: StudentInvitationLinkCountAggregateOutputType | null
    _min: StudentInvitationLinkMinAggregateOutputType | null
    _max: StudentInvitationLinkMaxAggregateOutputType | null
  }

  export type StudentInvitationLinkMinAggregateOutputType = {
    id: string | null
    invitationId: string | null
    studentId: string | null
  }

  export type StudentInvitationLinkMaxAggregateOutputType = {
    id: string | null
    invitationId: string | null
    studentId: string | null
  }

  export type StudentInvitationLinkCountAggregateOutputType = {
    id: number
    invitationId: number
    studentId: number
    _all: number
  }


  export type StudentInvitationLinkMinAggregateInputType = {
    id?: true
    invitationId?: true
    studentId?: true
  }

  export type StudentInvitationLinkMaxAggregateInputType = {
    id?: true
    invitationId?: true
    studentId?: true
  }

  export type StudentInvitationLinkCountAggregateInputType = {
    id?: true
    invitationId?: true
    studentId?: true
    _all?: true
  }

  export type StudentInvitationLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentInvitationLink to aggregate.
     */
    where?: StudentInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentInvitationLinks to fetch.
     */
    orderBy?: StudentInvitationLinkOrderByWithRelationInput | StudentInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentInvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentInvitationLinks
    **/
    _count?: true | StudentInvitationLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentInvitationLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentInvitationLinkMaxAggregateInputType
  }

  export type GetStudentInvitationLinkAggregateType<T extends StudentInvitationLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentInvitationLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentInvitationLink[P]>
      : GetScalarType<T[P], AggregateStudentInvitationLink[P]>
  }




  export type StudentInvitationLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentInvitationLinkWhereInput
    orderBy?: StudentInvitationLinkOrderByWithAggregationInput | StudentInvitationLinkOrderByWithAggregationInput[]
    by: StudentInvitationLinkScalarFieldEnum[] | StudentInvitationLinkScalarFieldEnum
    having?: StudentInvitationLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentInvitationLinkCountAggregateInputType | true
    _min?: StudentInvitationLinkMinAggregateInputType
    _max?: StudentInvitationLinkMaxAggregateInputType
  }

  export type StudentInvitationLinkGroupByOutputType = {
    id: string
    invitationId: string
    studentId: string
    _count: StudentInvitationLinkCountAggregateOutputType | null
    _min: StudentInvitationLinkMinAggregateOutputType | null
    _max: StudentInvitationLinkMaxAggregateOutputType | null
  }

  type GetStudentInvitationLinkGroupByPayload<T extends StudentInvitationLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentInvitationLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentInvitationLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentInvitationLinkGroupByOutputType[P]>
            : GetScalarType<T[P], StudentInvitationLinkGroupByOutputType[P]>
        }
      >
    >


  export type StudentInvitationLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invitationId?: boolean
    studentId?: boolean
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentInvitationLink"]>

  export type StudentInvitationLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invitationId?: boolean
    studentId?: boolean
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentInvitationLink"]>

  export type StudentInvitationLinkSelectScalar = {
    id?: boolean
    invitationId?: boolean
    studentId?: boolean
  }

  export type StudentInvitationLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentInvitationLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentInvitationLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentInvitationLink"
    objects: {
      invitation: Prisma.$ParentInvitationPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invitationId: string
      studentId: string
    }, ExtArgs["result"]["studentInvitationLink"]>
    composites: {}
  }

  type StudentInvitationLinkGetPayload<S extends boolean | null | undefined | StudentInvitationLinkDefaultArgs> = $Result.GetResult<Prisma.$StudentInvitationLinkPayload, S>

  type StudentInvitationLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentInvitationLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentInvitationLinkCountAggregateInputType | true
    }

  export interface StudentInvitationLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentInvitationLink'], meta: { name: 'StudentInvitationLink' } }
    /**
     * Find zero or one StudentInvitationLink that matches the filter.
     * @param {StudentInvitationLinkFindUniqueArgs} args - Arguments to find a StudentInvitationLink
     * @example
     * // Get one StudentInvitationLink
     * const studentInvitationLink = await prisma.studentInvitationLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentInvitationLinkFindUniqueArgs>(args: SelectSubset<T, StudentInvitationLinkFindUniqueArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentInvitationLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentInvitationLinkFindUniqueOrThrowArgs} args - Arguments to find a StudentInvitationLink
     * @example
     * // Get one StudentInvitationLink
     * const studentInvitationLink = await prisma.studentInvitationLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentInvitationLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentInvitationLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentInvitationLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInvitationLinkFindFirstArgs} args - Arguments to find a StudentInvitationLink
     * @example
     * // Get one StudentInvitationLink
     * const studentInvitationLink = await prisma.studentInvitationLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentInvitationLinkFindFirstArgs>(args?: SelectSubset<T, StudentInvitationLinkFindFirstArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentInvitationLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInvitationLinkFindFirstOrThrowArgs} args - Arguments to find a StudentInvitationLink
     * @example
     * // Get one StudentInvitationLink
     * const studentInvitationLink = await prisma.studentInvitationLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentInvitationLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentInvitationLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentInvitationLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInvitationLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentInvitationLinks
     * const studentInvitationLinks = await prisma.studentInvitationLink.findMany()
     * 
     * // Get first 10 StudentInvitationLinks
     * const studentInvitationLinks = await prisma.studentInvitationLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentInvitationLinkWithIdOnly = await prisma.studentInvitationLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentInvitationLinkFindManyArgs>(args?: SelectSubset<T, StudentInvitationLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentInvitationLink.
     * @param {StudentInvitationLinkCreateArgs} args - Arguments to create a StudentInvitationLink.
     * @example
     * // Create one StudentInvitationLink
     * const StudentInvitationLink = await prisma.studentInvitationLink.create({
     *   data: {
     *     // ... data to create a StudentInvitationLink
     *   }
     * })
     * 
     */
    create<T extends StudentInvitationLinkCreateArgs>(args: SelectSubset<T, StudentInvitationLinkCreateArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentInvitationLinks.
     * @param {StudentInvitationLinkCreateManyArgs} args - Arguments to create many StudentInvitationLinks.
     * @example
     * // Create many StudentInvitationLinks
     * const studentInvitationLink = await prisma.studentInvitationLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentInvitationLinkCreateManyArgs>(args?: SelectSubset<T, StudentInvitationLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentInvitationLinks and returns the data saved in the database.
     * @param {StudentInvitationLinkCreateManyAndReturnArgs} args - Arguments to create many StudentInvitationLinks.
     * @example
     * // Create many StudentInvitationLinks
     * const studentInvitationLink = await prisma.studentInvitationLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentInvitationLinks and only return the `id`
     * const studentInvitationLinkWithIdOnly = await prisma.studentInvitationLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentInvitationLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentInvitationLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentInvitationLink.
     * @param {StudentInvitationLinkDeleteArgs} args - Arguments to delete one StudentInvitationLink.
     * @example
     * // Delete one StudentInvitationLink
     * const StudentInvitationLink = await prisma.studentInvitationLink.delete({
     *   where: {
     *     // ... filter to delete one StudentInvitationLink
     *   }
     * })
     * 
     */
    delete<T extends StudentInvitationLinkDeleteArgs>(args: SelectSubset<T, StudentInvitationLinkDeleteArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentInvitationLink.
     * @param {StudentInvitationLinkUpdateArgs} args - Arguments to update one StudentInvitationLink.
     * @example
     * // Update one StudentInvitationLink
     * const studentInvitationLink = await prisma.studentInvitationLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentInvitationLinkUpdateArgs>(args: SelectSubset<T, StudentInvitationLinkUpdateArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentInvitationLinks.
     * @param {StudentInvitationLinkDeleteManyArgs} args - Arguments to filter StudentInvitationLinks to delete.
     * @example
     * // Delete a few StudentInvitationLinks
     * const { count } = await prisma.studentInvitationLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentInvitationLinkDeleteManyArgs>(args?: SelectSubset<T, StudentInvitationLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentInvitationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInvitationLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentInvitationLinks
     * const studentInvitationLink = await prisma.studentInvitationLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentInvitationLinkUpdateManyArgs>(args: SelectSubset<T, StudentInvitationLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentInvitationLink.
     * @param {StudentInvitationLinkUpsertArgs} args - Arguments to update or create a StudentInvitationLink.
     * @example
     * // Update or create a StudentInvitationLink
     * const studentInvitationLink = await prisma.studentInvitationLink.upsert({
     *   create: {
     *     // ... data to create a StudentInvitationLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentInvitationLink we want to update
     *   }
     * })
     */
    upsert<T extends StudentInvitationLinkUpsertArgs>(args: SelectSubset<T, StudentInvitationLinkUpsertArgs<ExtArgs>>): Prisma__StudentInvitationLinkClient<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentInvitationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInvitationLinkCountArgs} args - Arguments to filter StudentInvitationLinks to count.
     * @example
     * // Count the number of StudentInvitationLinks
     * const count = await prisma.studentInvitationLink.count({
     *   where: {
     *     // ... the filter for the StudentInvitationLinks we want to count
     *   }
     * })
    **/
    count<T extends StudentInvitationLinkCountArgs>(
      args?: Subset<T, StudentInvitationLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentInvitationLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentInvitationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInvitationLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentInvitationLinkAggregateArgs>(args: Subset<T, StudentInvitationLinkAggregateArgs>): Prisma.PrismaPromise<GetStudentInvitationLinkAggregateType<T>>

    /**
     * Group by StudentInvitationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentInvitationLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentInvitationLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentInvitationLinkGroupByArgs['orderBy'] }
        : { orderBy?: StudentInvitationLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentInvitationLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentInvitationLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentInvitationLink model
   */
  readonly fields: StudentInvitationLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentInvitationLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentInvitationLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitation<T extends ParentInvitationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentInvitationDefaultArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentInvitationLink model
   */ 
  interface StudentInvitationLinkFieldRefs {
    readonly id: FieldRef<"StudentInvitationLink", 'String'>
    readonly invitationId: FieldRef<"StudentInvitationLink", 'String'>
    readonly studentId: FieldRef<"StudentInvitationLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentInvitationLink findUnique
   */
  export type StudentInvitationLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentInvitationLink to fetch.
     */
    where: StudentInvitationLinkWhereUniqueInput
  }

  /**
   * StudentInvitationLink findUniqueOrThrow
   */
  export type StudentInvitationLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentInvitationLink to fetch.
     */
    where: StudentInvitationLinkWhereUniqueInput
  }

  /**
   * StudentInvitationLink findFirst
   */
  export type StudentInvitationLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentInvitationLink to fetch.
     */
    where?: StudentInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentInvitationLinks to fetch.
     */
    orderBy?: StudentInvitationLinkOrderByWithRelationInput | StudentInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentInvitationLinks.
     */
    cursor?: StudentInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentInvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentInvitationLinks.
     */
    distinct?: StudentInvitationLinkScalarFieldEnum | StudentInvitationLinkScalarFieldEnum[]
  }

  /**
   * StudentInvitationLink findFirstOrThrow
   */
  export type StudentInvitationLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentInvitationLink to fetch.
     */
    where?: StudentInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentInvitationLinks to fetch.
     */
    orderBy?: StudentInvitationLinkOrderByWithRelationInput | StudentInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentInvitationLinks.
     */
    cursor?: StudentInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentInvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentInvitationLinks.
     */
    distinct?: StudentInvitationLinkScalarFieldEnum | StudentInvitationLinkScalarFieldEnum[]
  }

  /**
   * StudentInvitationLink findMany
   */
  export type StudentInvitationLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which StudentInvitationLinks to fetch.
     */
    where?: StudentInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentInvitationLinks to fetch.
     */
    orderBy?: StudentInvitationLinkOrderByWithRelationInput | StudentInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentInvitationLinks.
     */
    cursor?: StudentInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentInvitationLinks.
     */
    skip?: number
    distinct?: StudentInvitationLinkScalarFieldEnum | StudentInvitationLinkScalarFieldEnum[]
  }

  /**
   * StudentInvitationLink create
   */
  export type StudentInvitationLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentInvitationLink.
     */
    data: XOR<StudentInvitationLinkCreateInput, StudentInvitationLinkUncheckedCreateInput>
  }

  /**
   * StudentInvitationLink createMany
   */
  export type StudentInvitationLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentInvitationLinks.
     */
    data: StudentInvitationLinkCreateManyInput | StudentInvitationLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentInvitationLink createManyAndReturn
   */
  export type StudentInvitationLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentInvitationLinks.
     */
    data: StudentInvitationLinkCreateManyInput | StudentInvitationLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentInvitationLink update
   */
  export type StudentInvitationLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentInvitationLink.
     */
    data: XOR<StudentInvitationLinkUpdateInput, StudentInvitationLinkUncheckedUpdateInput>
    /**
     * Choose, which StudentInvitationLink to update.
     */
    where: StudentInvitationLinkWhereUniqueInput
  }

  /**
   * StudentInvitationLink updateMany
   */
  export type StudentInvitationLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentInvitationLinks.
     */
    data: XOR<StudentInvitationLinkUpdateManyMutationInput, StudentInvitationLinkUncheckedUpdateManyInput>
    /**
     * Filter which StudentInvitationLinks to update
     */
    where?: StudentInvitationLinkWhereInput
  }

  /**
   * StudentInvitationLink upsert
   */
  export type StudentInvitationLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentInvitationLink to update in case it exists.
     */
    where: StudentInvitationLinkWhereUniqueInput
    /**
     * In case the StudentInvitationLink found by the `where` argument doesn't exist, create a new StudentInvitationLink with this data.
     */
    create: XOR<StudentInvitationLinkCreateInput, StudentInvitationLinkUncheckedCreateInput>
    /**
     * In case the StudentInvitationLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentInvitationLinkUpdateInput, StudentInvitationLinkUncheckedUpdateInput>
  }

  /**
   * StudentInvitationLink delete
   */
  export type StudentInvitationLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter which StudentInvitationLink to delete.
     */
    where: StudentInvitationLinkWhereUniqueInput
  }

  /**
   * StudentInvitationLink deleteMany
   */
  export type StudentInvitationLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentInvitationLinks to delete
     */
    where?: StudentInvitationLinkWhereInput
  }

  /**
   * StudentInvitationLink without action
   */
  export type StudentInvitationLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
  }


  /**
   * Model YearGroup
   */

  export type AggregateYearGroup = {
    _count: YearGroupCountAggregateOutputType | null
    _avg: YearGroupAvgAggregateOutputType | null
    _sum: YearGroupSumAggregateOutputType | null
    _min: YearGroupMinAggregateOutputType | null
    _max: YearGroupMaxAggregateOutputType | null
  }

  export type YearGroupAvgAggregateOutputType = {
    order: number | null
  }

  export type YearGroupSumAggregateOutputType = {
    order: number | null
  }

  export type YearGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YearGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YearGroupCountAggregateOutputType = {
    id: number
    name: number
    order: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YearGroupAvgAggregateInputType = {
    order?: true
  }

  export type YearGroupSumAggregateInputType = {
    order?: true
  }

  export type YearGroupMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YearGroupMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YearGroupCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YearGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearGroup to aggregate.
     */
    where?: YearGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearGroups to fetch.
     */
    orderBy?: YearGroupOrderByWithRelationInput | YearGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearGroups
    **/
    _count?: true | YearGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearGroupMaxAggregateInputType
  }

  export type GetYearGroupAggregateType<T extends YearGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateYearGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearGroup[P]>
      : GetScalarType<T[P], AggregateYearGroup[P]>
  }




  export type YearGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearGroupWhereInput
    orderBy?: YearGroupOrderByWithAggregationInput | YearGroupOrderByWithAggregationInput[]
    by: YearGroupScalarFieldEnum[] | YearGroupScalarFieldEnum
    having?: YearGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearGroupCountAggregateInputType | true
    _avg?: YearGroupAvgAggregateInputType
    _sum?: YearGroupSumAggregateInputType
    _min?: YearGroupMinAggregateInputType
    _max?: YearGroupMaxAggregateInputType
  }

  export type YearGroupGroupByOutputType = {
    id: string
    name: string
    order: number
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: YearGroupCountAggregateOutputType | null
    _avg: YearGroupAvgAggregateOutputType | null
    _sum: YearGroupSumAggregateOutputType | null
    _min: YearGroupMinAggregateOutputType | null
    _max: YearGroupMaxAggregateOutputType | null
  }

  type GetYearGroupGroupByPayload<T extends YearGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearGroupGroupByOutputType[P]>
            : GetScalarType<T[P], YearGroupGroupByOutputType[P]>
        }
      >
    >


  export type YearGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    classes?: boolean | YearGroup$classesArgs<ExtArgs>
    messages?: boolean | YearGroup$messagesArgs<ExtArgs>
    events?: boolean | YearGroup$eventsArgs<ExtArgs>
    scheduleItems?: boolean | YearGroup$scheduleItemsArgs<ExtArgs>
    _count?: boolean | YearGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearGroup"]>

  export type YearGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearGroup"]>

  export type YearGroupSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type YearGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    classes?: boolean | YearGroup$classesArgs<ExtArgs>
    messages?: boolean | YearGroup$messagesArgs<ExtArgs>
    events?: boolean | YearGroup$eventsArgs<ExtArgs>
    scheduleItems?: boolean | YearGroup$scheduleItemsArgs<ExtArgs>
    _count?: boolean | YearGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $YearGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearGroup"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      classes: Prisma.$ClassPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      scheduleItems: Prisma.$ScheduleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["yearGroup"]>
    composites: {}
  }

  type YearGroupGetPayload<S extends boolean | null | undefined | YearGroupDefaultArgs> = $Result.GetResult<Prisma.$YearGroupPayload, S>

  type YearGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<YearGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: YearGroupCountAggregateInputType | true
    }

  export interface YearGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearGroup'], meta: { name: 'YearGroup' } }
    /**
     * Find zero or one YearGroup that matches the filter.
     * @param {YearGroupFindUniqueArgs} args - Arguments to find a YearGroup
     * @example
     * // Get one YearGroup
     * const yearGroup = await prisma.yearGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearGroupFindUniqueArgs>(args: SelectSubset<T, YearGroupFindUniqueArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one YearGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {YearGroupFindUniqueOrThrowArgs} args - Arguments to find a YearGroup
     * @example
     * // Get one YearGroup
     * const yearGroup = await prisma.yearGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, YearGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first YearGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupFindFirstArgs} args - Arguments to find a YearGroup
     * @example
     * // Get one YearGroup
     * const yearGroup = await prisma.yearGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearGroupFindFirstArgs>(args?: SelectSubset<T, YearGroupFindFirstArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first YearGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupFindFirstOrThrowArgs} args - Arguments to find a YearGroup
     * @example
     * // Get one YearGroup
     * const yearGroup = await prisma.yearGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, YearGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more YearGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearGroups
     * const yearGroups = await prisma.yearGroup.findMany()
     * 
     * // Get first 10 YearGroups
     * const yearGroups = await prisma.yearGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearGroupWithIdOnly = await prisma.yearGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearGroupFindManyArgs>(args?: SelectSubset<T, YearGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a YearGroup.
     * @param {YearGroupCreateArgs} args - Arguments to create a YearGroup.
     * @example
     * // Create one YearGroup
     * const YearGroup = await prisma.yearGroup.create({
     *   data: {
     *     // ... data to create a YearGroup
     *   }
     * })
     * 
     */
    create<T extends YearGroupCreateArgs>(args: SelectSubset<T, YearGroupCreateArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many YearGroups.
     * @param {YearGroupCreateManyArgs} args - Arguments to create many YearGroups.
     * @example
     * // Create many YearGroups
     * const yearGroup = await prisma.yearGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearGroupCreateManyArgs>(args?: SelectSubset<T, YearGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearGroups and returns the data saved in the database.
     * @param {YearGroupCreateManyAndReturnArgs} args - Arguments to create many YearGroups.
     * @example
     * // Create many YearGroups
     * const yearGroup = await prisma.yearGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearGroups and only return the `id`
     * const yearGroupWithIdOnly = await prisma.yearGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, YearGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a YearGroup.
     * @param {YearGroupDeleteArgs} args - Arguments to delete one YearGroup.
     * @example
     * // Delete one YearGroup
     * const YearGroup = await prisma.yearGroup.delete({
     *   where: {
     *     // ... filter to delete one YearGroup
     *   }
     * })
     * 
     */
    delete<T extends YearGroupDeleteArgs>(args: SelectSubset<T, YearGroupDeleteArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one YearGroup.
     * @param {YearGroupUpdateArgs} args - Arguments to update one YearGroup.
     * @example
     * // Update one YearGroup
     * const yearGroup = await prisma.yearGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearGroupUpdateArgs>(args: SelectSubset<T, YearGroupUpdateArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more YearGroups.
     * @param {YearGroupDeleteManyArgs} args - Arguments to filter YearGroups to delete.
     * @example
     * // Delete a few YearGroups
     * const { count } = await prisma.yearGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearGroupDeleteManyArgs>(args?: SelectSubset<T, YearGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearGroups
     * const yearGroup = await prisma.yearGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearGroupUpdateManyArgs>(args: SelectSubset<T, YearGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YearGroup.
     * @param {YearGroupUpsertArgs} args - Arguments to update or create a YearGroup.
     * @example
     * // Update or create a YearGroup
     * const yearGroup = await prisma.yearGroup.upsert({
     *   create: {
     *     // ... data to create a YearGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearGroup we want to update
     *   }
     * })
     */
    upsert<T extends YearGroupUpsertArgs>(args: SelectSubset<T, YearGroupUpsertArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of YearGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupCountArgs} args - Arguments to filter YearGroups to count.
     * @example
     * // Count the number of YearGroups
     * const count = await prisma.yearGroup.count({
     *   where: {
     *     // ... the filter for the YearGroups we want to count
     *   }
     * })
    **/
    count<T extends YearGroupCountArgs>(
      args?: Subset<T, YearGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearGroupAggregateArgs>(args: Subset<T, YearGroupAggregateArgs>): Prisma.PrismaPromise<GetYearGroupAggregateType<T>>

    /**
     * Group by YearGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearGroupGroupByArgs['orderBy'] }
        : { orderBy?: YearGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearGroup model
   */
  readonly fields: YearGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    classes<T extends YearGroup$classesArgs<ExtArgs> = {}>(args?: Subset<T, YearGroup$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends YearGroup$messagesArgs<ExtArgs> = {}>(args?: Subset<T, YearGroup$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends YearGroup$eventsArgs<ExtArgs> = {}>(args?: Subset<T, YearGroup$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    scheduleItems<T extends YearGroup$scheduleItemsArgs<ExtArgs> = {}>(args?: Subset<T, YearGroup$scheduleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearGroup model
   */ 
  interface YearGroupFieldRefs {
    readonly id: FieldRef<"YearGroup", 'String'>
    readonly name: FieldRef<"YearGroup", 'String'>
    readonly order: FieldRef<"YearGroup", 'Int'>
    readonly schoolId: FieldRef<"YearGroup", 'String'>
    readonly createdAt: FieldRef<"YearGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"YearGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * YearGroup findUnique
   */
  export type YearGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * Filter, which YearGroup to fetch.
     */
    where: YearGroupWhereUniqueInput
  }

  /**
   * YearGroup findUniqueOrThrow
   */
  export type YearGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * Filter, which YearGroup to fetch.
     */
    where: YearGroupWhereUniqueInput
  }

  /**
   * YearGroup findFirst
   */
  export type YearGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * Filter, which YearGroup to fetch.
     */
    where?: YearGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearGroups to fetch.
     */
    orderBy?: YearGroupOrderByWithRelationInput | YearGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearGroups.
     */
    cursor?: YearGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearGroups.
     */
    distinct?: YearGroupScalarFieldEnum | YearGroupScalarFieldEnum[]
  }

  /**
   * YearGroup findFirstOrThrow
   */
  export type YearGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * Filter, which YearGroup to fetch.
     */
    where?: YearGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearGroups to fetch.
     */
    orderBy?: YearGroupOrderByWithRelationInput | YearGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearGroups.
     */
    cursor?: YearGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearGroups.
     */
    distinct?: YearGroupScalarFieldEnum | YearGroupScalarFieldEnum[]
  }

  /**
   * YearGroup findMany
   */
  export type YearGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * Filter, which YearGroups to fetch.
     */
    where?: YearGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearGroups to fetch.
     */
    orderBy?: YearGroupOrderByWithRelationInput | YearGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearGroups.
     */
    cursor?: YearGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearGroups.
     */
    skip?: number
    distinct?: YearGroupScalarFieldEnum | YearGroupScalarFieldEnum[]
  }

  /**
   * YearGroup create
   */
  export type YearGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a YearGroup.
     */
    data: XOR<YearGroupCreateInput, YearGroupUncheckedCreateInput>
  }

  /**
   * YearGroup createMany
   */
  export type YearGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearGroups.
     */
    data: YearGroupCreateManyInput | YearGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearGroup createManyAndReturn
   */
  export type YearGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many YearGroups.
     */
    data: YearGroupCreateManyInput | YearGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearGroup update
   */
  export type YearGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a YearGroup.
     */
    data: XOR<YearGroupUpdateInput, YearGroupUncheckedUpdateInput>
    /**
     * Choose, which YearGroup to update.
     */
    where: YearGroupWhereUniqueInput
  }

  /**
   * YearGroup updateMany
   */
  export type YearGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearGroups.
     */
    data: XOR<YearGroupUpdateManyMutationInput, YearGroupUncheckedUpdateManyInput>
    /**
     * Filter which YearGroups to update
     */
    where?: YearGroupWhereInput
  }

  /**
   * YearGroup upsert
   */
  export type YearGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the YearGroup to update in case it exists.
     */
    where: YearGroupWhereUniqueInput
    /**
     * In case the YearGroup found by the `where` argument doesn't exist, create a new YearGroup with this data.
     */
    create: XOR<YearGroupCreateInput, YearGroupUncheckedCreateInput>
    /**
     * In case the YearGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearGroupUpdateInput, YearGroupUncheckedUpdateInput>
  }

  /**
   * YearGroup delete
   */
  export type YearGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    /**
     * Filter which YearGroup to delete.
     */
    where: YearGroupWhereUniqueInput
  }

  /**
   * YearGroup deleteMany
   */
  export type YearGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearGroups to delete
     */
    where?: YearGroupWhereInput
  }

  /**
   * YearGroup.classes
   */
  export type YearGroup$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * YearGroup.messages
   */
  export type YearGroup$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * YearGroup.events
   */
  export type YearGroup$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * YearGroup.scheduleItems
   */
  export type YearGroup$scheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * YearGroup without action
   */
  export type YearGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    colorBg: string | null
    colorText: string | null
    schoolId: string | null
    yearGroupId: string | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    colorBg: string | null
    colorText: string | null
    schoolId: string | null
    yearGroupId: string | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    colorBg: number
    colorText: number
    schoolId: number
    yearGroupId: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    colorBg?: true
    colorText?: true
    schoolId?: true
    yearGroupId?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    colorBg?: true
    colorText?: true
    schoolId?: true
    yearGroupId?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    colorBg?: true
    colorText?: true
    schoolId?: true
    yearGroupId?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    colorBg: string
    colorText: string
    schoolId: string
    yearGroupId: string | null
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    colorBg?: boolean
    colorText?: boolean
    schoolId?: boolean
    yearGroupId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    yearGroup?: boolean | Class$yearGroupArgs<ExtArgs>
    children?: boolean | Class$childrenArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    messages?: boolean | Class$messagesArgs<ExtArgs>
    events?: boolean | Class$eventsArgs<ExtArgs>
    scheduleItems?: boolean | Class$scheduleItemsArgs<ExtArgs>
    assignedStaff?: boolean | Class$assignedStaffArgs<ExtArgs>
    childInvitationLinks?: boolean | Class$childInvitationLinksArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    colorBg?: boolean
    colorText?: boolean
    schoolId?: boolean
    yearGroupId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    yearGroup?: boolean | Class$yearGroupArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    colorBg?: boolean
    colorText?: boolean
    schoolId?: boolean
    yearGroupId?: boolean
  }

  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    yearGroup?: boolean | Class$yearGroupArgs<ExtArgs>
    children?: boolean | Class$childrenArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    messages?: boolean | Class$messagesArgs<ExtArgs>
    events?: boolean | Class$eventsArgs<ExtArgs>
    scheduleItems?: boolean | Class$scheduleItemsArgs<ExtArgs>
    assignedStaff?: boolean | Class$assignedStaffArgs<ExtArgs>
    childInvitationLinks?: boolean | Class$childInvitationLinksArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    yearGroup?: boolean | Class$yearGroupArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      yearGroup: Prisma.$YearGroupPayload<ExtArgs> | null
      children: Prisma.$ChildPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      scheduleItems: Prisma.$ScheduleItemPayload<ExtArgs>[]
      assignedStaff: Prisma.$StaffClassAssignmentPayload<ExtArgs>[]
      childInvitationLinks: Prisma.$ChildInvitationLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      colorBg: string
      colorText: string
      schoolId: string
      yearGroupId: string | null
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    yearGroup<T extends Class$yearGroupArgs<ExtArgs> = {}>(args?: Subset<T, Class$yearGroupArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Class$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Class$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Class$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Class$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Class$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Class$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    scheduleItems<T extends Class$scheduleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Class$scheduleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany"> | Null>
    assignedStaff<T extends Class$assignedStaffArgs<ExtArgs> = {}>(args?: Subset<T, Class$assignedStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    childInvitationLinks<T extends Class$childInvitationLinksArgs<ExtArgs> = {}>(args?: Subset<T, Class$childInvitationLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly colorBg: FieldRef<"Class", 'String'>
    readonly colorText: FieldRef<"Class", 'String'>
    readonly schoolId: FieldRef<"Class", 'String'>
    readonly yearGroupId: FieldRef<"Class", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
  }

  /**
   * Class.yearGroup
   */
  export type Class$yearGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    where?: YearGroupWhereInput
  }

  /**
   * Class.children
   */
  export type Class$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    cursor?: ChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.messages
   */
  export type Class$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Class.events
   */
  export type Class$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Class.scheduleItems
   */
  export type Class$scheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * Class.assignedStaff
   */
  export type Class$assignedStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    where?: StaffClassAssignmentWhereInput
    orderBy?: StaffClassAssignmentOrderByWithRelationInput | StaffClassAssignmentOrderByWithRelationInput[]
    cursor?: StaffClassAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffClassAssignmentScalarFieldEnum | StaffClassAssignmentScalarFieldEnum[]
  }

  /**
   * Class.childInvitationLinks
   */
  export type Class$childInvitationLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    where?: ChildInvitationLinkWhereInput
    orderBy?: ChildInvitationLinkOrderByWithRelationInput | ChildInvitationLinkOrderByWithRelationInput[]
    cursor?: ChildInvitationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildInvitationLinkScalarFieldEnum | ChildInvitationLinkScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model StaffClassAssignment
   */

  export type AggregateStaffClassAssignment = {
    _count: StaffClassAssignmentCountAggregateOutputType | null
    _min: StaffClassAssignmentMinAggregateOutputType | null
    _max: StaffClassAssignmentMaxAggregateOutputType | null
  }

  export type StaffClassAssignmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    createdAt: Date | null
  }

  export type StaffClassAssignmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    createdAt: Date | null
  }

  export type StaffClassAssignmentCountAggregateOutputType = {
    id: number
    userId: number
    classId: number
    createdAt: number
    _all: number
  }


  export type StaffClassAssignmentMinAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    createdAt?: true
  }

  export type StaffClassAssignmentMaxAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    createdAt?: true
  }

  export type StaffClassAssignmentCountAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    createdAt?: true
    _all?: true
  }

  export type StaffClassAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffClassAssignment to aggregate.
     */
    where?: StaffClassAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffClassAssignments to fetch.
     */
    orderBy?: StaffClassAssignmentOrderByWithRelationInput | StaffClassAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffClassAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffClassAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffClassAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffClassAssignments
    **/
    _count?: true | StaffClassAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffClassAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffClassAssignmentMaxAggregateInputType
  }

  export type GetStaffClassAssignmentAggregateType<T extends StaffClassAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffClassAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffClassAssignment[P]>
      : GetScalarType<T[P], AggregateStaffClassAssignment[P]>
  }




  export type StaffClassAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffClassAssignmentWhereInput
    orderBy?: StaffClassAssignmentOrderByWithAggregationInput | StaffClassAssignmentOrderByWithAggregationInput[]
    by: StaffClassAssignmentScalarFieldEnum[] | StaffClassAssignmentScalarFieldEnum
    having?: StaffClassAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffClassAssignmentCountAggregateInputType | true
    _min?: StaffClassAssignmentMinAggregateInputType
    _max?: StaffClassAssignmentMaxAggregateInputType
  }

  export type StaffClassAssignmentGroupByOutputType = {
    id: string
    userId: string
    classId: string
    createdAt: Date
    _count: StaffClassAssignmentCountAggregateOutputType | null
    _min: StaffClassAssignmentMinAggregateOutputType | null
    _max: StaffClassAssignmentMaxAggregateOutputType | null
  }

  type GetStaffClassAssignmentGroupByPayload<T extends StaffClassAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffClassAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffClassAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffClassAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], StaffClassAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type StaffClassAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffClassAssignment"]>

  export type StaffClassAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffClassAssignment"]>

  export type StaffClassAssignmentSelectScalar = {
    id?: boolean
    userId?: boolean
    classId?: boolean
    createdAt?: boolean
  }

  export type StaffClassAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type StaffClassAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $StaffClassAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffClassAssignment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      classId: string
      createdAt: Date
    }, ExtArgs["result"]["staffClassAssignment"]>
    composites: {}
  }

  type StaffClassAssignmentGetPayload<S extends boolean | null | undefined | StaffClassAssignmentDefaultArgs> = $Result.GetResult<Prisma.$StaffClassAssignmentPayload, S>

  type StaffClassAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffClassAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffClassAssignmentCountAggregateInputType | true
    }

  export interface StaffClassAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffClassAssignment'], meta: { name: 'StaffClassAssignment' } }
    /**
     * Find zero or one StaffClassAssignment that matches the filter.
     * @param {StaffClassAssignmentFindUniqueArgs} args - Arguments to find a StaffClassAssignment
     * @example
     * // Get one StaffClassAssignment
     * const staffClassAssignment = await prisma.staffClassAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffClassAssignmentFindUniqueArgs>(args: SelectSubset<T, StaffClassAssignmentFindUniqueArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StaffClassAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StaffClassAssignmentFindUniqueOrThrowArgs} args - Arguments to find a StaffClassAssignment
     * @example
     * // Get one StaffClassAssignment
     * const staffClassAssignment = await prisma.staffClassAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffClassAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffClassAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StaffClassAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffClassAssignmentFindFirstArgs} args - Arguments to find a StaffClassAssignment
     * @example
     * // Get one StaffClassAssignment
     * const staffClassAssignment = await prisma.staffClassAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffClassAssignmentFindFirstArgs>(args?: SelectSubset<T, StaffClassAssignmentFindFirstArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StaffClassAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffClassAssignmentFindFirstOrThrowArgs} args - Arguments to find a StaffClassAssignment
     * @example
     * // Get one StaffClassAssignment
     * const staffClassAssignment = await prisma.staffClassAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffClassAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffClassAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StaffClassAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffClassAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffClassAssignments
     * const staffClassAssignments = await prisma.staffClassAssignment.findMany()
     * 
     * // Get first 10 StaffClassAssignments
     * const staffClassAssignments = await prisma.staffClassAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffClassAssignmentWithIdOnly = await prisma.staffClassAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffClassAssignmentFindManyArgs>(args?: SelectSubset<T, StaffClassAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StaffClassAssignment.
     * @param {StaffClassAssignmentCreateArgs} args - Arguments to create a StaffClassAssignment.
     * @example
     * // Create one StaffClassAssignment
     * const StaffClassAssignment = await prisma.staffClassAssignment.create({
     *   data: {
     *     // ... data to create a StaffClassAssignment
     *   }
     * })
     * 
     */
    create<T extends StaffClassAssignmentCreateArgs>(args: SelectSubset<T, StaffClassAssignmentCreateArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StaffClassAssignments.
     * @param {StaffClassAssignmentCreateManyArgs} args - Arguments to create many StaffClassAssignments.
     * @example
     * // Create many StaffClassAssignments
     * const staffClassAssignment = await prisma.staffClassAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffClassAssignmentCreateManyArgs>(args?: SelectSubset<T, StaffClassAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffClassAssignments and returns the data saved in the database.
     * @param {StaffClassAssignmentCreateManyAndReturnArgs} args - Arguments to create many StaffClassAssignments.
     * @example
     * // Create many StaffClassAssignments
     * const staffClassAssignment = await prisma.staffClassAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffClassAssignments and only return the `id`
     * const staffClassAssignmentWithIdOnly = await prisma.staffClassAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffClassAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffClassAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StaffClassAssignment.
     * @param {StaffClassAssignmentDeleteArgs} args - Arguments to delete one StaffClassAssignment.
     * @example
     * // Delete one StaffClassAssignment
     * const StaffClassAssignment = await prisma.staffClassAssignment.delete({
     *   where: {
     *     // ... filter to delete one StaffClassAssignment
     *   }
     * })
     * 
     */
    delete<T extends StaffClassAssignmentDeleteArgs>(args: SelectSubset<T, StaffClassAssignmentDeleteArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StaffClassAssignment.
     * @param {StaffClassAssignmentUpdateArgs} args - Arguments to update one StaffClassAssignment.
     * @example
     * // Update one StaffClassAssignment
     * const staffClassAssignment = await prisma.staffClassAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffClassAssignmentUpdateArgs>(args: SelectSubset<T, StaffClassAssignmentUpdateArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StaffClassAssignments.
     * @param {StaffClassAssignmentDeleteManyArgs} args - Arguments to filter StaffClassAssignments to delete.
     * @example
     * // Delete a few StaffClassAssignments
     * const { count } = await prisma.staffClassAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffClassAssignmentDeleteManyArgs>(args?: SelectSubset<T, StaffClassAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffClassAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffClassAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffClassAssignments
     * const staffClassAssignment = await prisma.staffClassAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffClassAssignmentUpdateManyArgs>(args: SelectSubset<T, StaffClassAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaffClassAssignment.
     * @param {StaffClassAssignmentUpsertArgs} args - Arguments to update or create a StaffClassAssignment.
     * @example
     * // Update or create a StaffClassAssignment
     * const staffClassAssignment = await prisma.staffClassAssignment.upsert({
     *   create: {
     *     // ... data to create a StaffClassAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffClassAssignment we want to update
     *   }
     * })
     */
    upsert<T extends StaffClassAssignmentUpsertArgs>(args: SelectSubset<T, StaffClassAssignmentUpsertArgs<ExtArgs>>): Prisma__StaffClassAssignmentClient<$Result.GetResult<Prisma.$StaffClassAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StaffClassAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffClassAssignmentCountArgs} args - Arguments to filter StaffClassAssignments to count.
     * @example
     * // Count the number of StaffClassAssignments
     * const count = await prisma.staffClassAssignment.count({
     *   where: {
     *     // ... the filter for the StaffClassAssignments we want to count
     *   }
     * })
    **/
    count<T extends StaffClassAssignmentCountArgs>(
      args?: Subset<T, StaffClassAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffClassAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffClassAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffClassAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffClassAssignmentAggregateArgs>(args: Subset<T, StaffClassAssignmentAggregateArgs>): Prisma.PrismaPromise<GetStaffClassAssignmentAggregateType<T>>

    /**
     * Group by StaffClassAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffClassAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffClassAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffClassAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: StaffClassAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffClassAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffClassAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffClassAssignment model
   */
  readonly fields: StaffClassAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffClassAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClassAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffClassAssignment model
   */ 
  interface StaffClassAssignmentFieldRefs {
    readonly id: FieldRef<"StaffClassAssignment", 'String'>
    readonly userId: FieldRef<"StaffClassAssignment", 'String'>
    readonly classId: FieldRef<"StaffClassAssignment", 'String'>
    readonly createdAt: FieldRef<"StaffClassAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffClassAssignment findUnique
   */
  export type StaffClassAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StaffClassAssignment to fetch.
     */
    where: StaffClassAssignmentWhereUniqueInput
  }

  /**
   * StaffClassAssignment findUniqueOrThrow
   */
  export type StaffClassAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StaffClassAssignment to fetch.
     */
    where: StaffClassAssignmentWhereUniqueInput
  }

  /**
   * StaffClassAssignment findFirst
   */
  export type StaffClassAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StaffClassAssignment to fetch.
     */
    where?: StaffClassAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffClassAssignments to fetch.
     */
    orderBy?: StaffClassAssignmentOrderByWithRelationInput | StaffClassAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffClassAssignments.
     */
    cursor?: StaffClassAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffClassAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffClassAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffClassAssignments.
     */
    distinct?: StaffClassAssignmentScalarFieldEnum | StaffClassAssignmentScalarFieldEnum[]
  }

  /**
   * StaffClassAssignment findFirstOrThrow
   */
  export type StaffClassAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StaffClassAssignment to fetch.
     */
    where?: StaffClassAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffClassAssignments to fetch.
     */
    orderBy?: StaffClassAssignmentOrderByWithRelationInput | StaffClassAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffClassAssignments.
     */
    cursor?: StaffClassAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffClassAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffClassAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffClassAssignments.
     */
    distinct?: StaffClassAssignmentScalarFieldEnum | StaffClassAssignmentScalarFieldEnum[]
  }

  /**
   * StaffClassAssignment findMany
   */
  export type StaffClassAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which StaffClassAssignments to fetch.
     */
    where?: StaffClassAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffClassAssignments to fetch.
     */
    orderBy?: StaffClassAssignmentOrderByWithRelationInput | StaffClassAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffClassAssignments.
     */
    cursor?: StaffClassAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffClassAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffClassAssignments.
     */
    skip?: number
    distinct?: StaffClassAssignmentScalarFieldEnum | StaffClassAssignmentScalarFieldEnum[]
  }

  /**
   * StaffClassAssignment create
   */
  export type StaffClassAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffClassAssignment.
     */
    data: XOR<StaffClassAssignmentCreateInput, StaffClassAssignmentUncheckedCreateInput>
  }

  /**
   * StaffClassAssignment createMany
   */
  export type StaffClassAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffClassAssignments.
     */
    data: StaffClassAssignmentCreateManyInput | StaffClassAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffClassAssignment createManyAndReturn
   */
  export type StaffClassAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StaffClassAssignments.
     */
    data: StaffClassAssignmentCreateManyInput | StaffClassAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffClassAssignment update
   */
  export type StaffClassAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffClassAssignment.
     */
    data: XOR<StaffClassAssignmentUpdateInput, StaffClassAssignmentUncheckedUpdateInput>
    /**
     * Choose, which StaffClassAssignment to update.
     */
    where: StaffClassAssignmentWhereUniqueInput
  }

  /**
   * StaffClassAssignment updateMany
   */
  export type StaffClassAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffClassAssignments.
     */
    data: XOR<StaffClassAssignmentUpdateManyMutationInput, StaffClassAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which StaffClassAssignments to update
     */
    where?: StaffClassAssignmentWhereInput
  }

  /**
   * StaffClassAssignment upsert
   */
  export type StaffClassAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffClassAssignment to update in case it exists.
     */
    where: StaffClassAssignmentWhereUniqueInput
    /**
     * In case the StaffClassAssignment found by the `where` argument doesn't exist, create a new StaffClassAssignment with this data.
     */
    create: XOR<StaffClassAssignmentCreateInput, StaffClassAssignmentUncheckedCreateInput>
    /**
     * In case the StaffClassAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffClassAssignmentUpdateInput, StaffClassAssignmentUncheckedUpdateInput>
  }

  /**
   * StaffClassAssignment delete
   */
  export type StaffClassAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
    /**
     * Filter which StaffClassAssignment to delete.
     */
    where: StaffClassAssignmentWhereUniqueInput
  }

  /**
   * StaffClassAssignment deleteMany
   */
  export type StaffClassAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffClassAssignments to delete
     */
    where?: StaffClassAssignmentWhereInput
  }

  /**
   * StaffClassAssignment without action
   */
  export type StaffClassAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffClassAssignment
     */
    select?: StaffClassAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffClassAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    targetClass: string | null
    classId: string | null
    yearGroupId: string | null
    schoolId: string | null
    senderId: string | null
    senderName: string | null
    actionType: string | null
    actionLabel: string | null
    actionDueDate: Date | null
    actionAmount: string | null
    isPinned: boolean | null
    isUrgent: boolean | null
    expiresAt: Date | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    targetClass: string | null
    classId: string | null
    yearGroupId: string | null
    schoolId: string | null
    senderId: string | null
    senderName: string | null
    actionType: string | null
    actionLabel: string | null
    actionDueDate: Date | null
    actionAmount: string | null
    isPinned: boolean | null
    isUrgent: boolean | null
    expiresAt: Date | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    title: number
    content: number
    targetClass: number
    classId: number
    yearGroupId: number
    schoolId: number
    senderId: number
    senderName: number
    actionType: number
    actionLabel: number
    actionDueDate: number
    actionAmount: number
    isPinned: number
    isUrgent: number
    expiresAt: number
    formId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    senderId?: true
    senderName?: true
    actionType?: true
    actionLabel?: true
    actionDueDate?: true
    actionAmount?: true
    isPinned?: true
    isUrgent?: true
    expiresAt?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    senderId?: true
    senderName?: true
    actionType?: true
    actionLabel?: true
    actionDueDate?: true
    actionAmount?: true
    isPinned?: true
    isUrgent?: true
    expiresAt?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    senderId?: true
    senderName?: true
    actionType?: true
    actionLabel?: true
    actionDueDate?: true
    actionAmount?: true
    isPinned?: true
    isUrgent?: true
    expiresAt?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    title: string
    content: string
    targetClass: string
    classId: string | null
    yearGroupId: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType: string | null
    actionLabel: string | null
    actionDueDate: Date | null
    actionAmount: string | null
    isPinned: boolean
    isUrgent: boolean
    expiresAt: Date | null
    formId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    senderId?: boolean
    senderName?: boolean
    actionType?: boolean
    actionLabel?: boolean
    actionDueDate?: boolean
    actionAmount?: boolean
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Message$classArgs<ExtArgs>
    yearGroup?: boolean | Message$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    form?: boolean | Message$formArgs<ExtArgs>
    acknowledgments?: boolean | Message$acknowledgmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    senderId?: boolean
    senderName?: boolean
    actionType?: boolean
    actionLabel?: boolean
    actionDueDate?: boolean
    actionAmount?: boolean
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Message$classArgs<ExtArgs>
    yearGroup?: boolean | Message$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    form?: boolean | Message$formArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    senderId?: boolean
    senderName?: boolean
    actionType?: boolean
    actionLabel?: boolean
    actionDueDate?: boolean
    actionAmount?: boolean
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Message$classArgs<ExtArgs>
    yearGroup?: boolean | Message$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    form?: boolean | Message$formArgs<ExtArgs>
    acknowledgments?: boolean | Message$acknowledgmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Message$classArgs<ExtArgs>
    yearGroup?: boolean | Message$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    form?: boolean | Message$formArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      yearGroup: Prisma.$YearGroupPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      form: Prisma.$FormPayload<ExtArgs> | null
      acknowledgments: Prisma.$MessageAcknowledgmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      targetClass: string
      classId: string | null
      yearGroupId: string | null
      schoolId: string
      senderId: string
      senderName: string
      actionType: string | null
      actionLabel: string | null
      actionDueDate: Date | null
      actionAmount: string | null
      isPinned: boolean
      isUrgent: boolean
      expiresAt: Date | null
      formId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Message$classArgs<ExtArgs> = {}>(args?: Subset<T, Message$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    yearGroup<T extends Message$yearGroupArgs<ExtArgs> = {}>(args?: Subset<T, Message$yearGroupArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    form<T extends Message$formArgs<ExtArgs> = {}>(args?: Subset<T, Message$formArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    acknowledgments<T extends Message$acknowledgmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$acknowledgmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly title: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly targetClass: FieldRef<"Message", 'String'>
    readonly classId: FieldRef<"Message", 'String'>
    readonly yearGroupId: FieldRef<"Message", 'String'>
    readonly schoolId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly senderName: FieldRef<"Message", 'String'>
    readonly actionType: FieldRef<"Message", 'String'>
    readonly actionLabel: FieldRef<"Message", 'String'>
    readonly actionDueDate: FieldRef<"Message", 'DateTime'>
    readonly actionAmount: FieldRef<"Message", 'String'>
    readonly isPinned: FieldRef<"Message", 'Boolean'>
    readonly isUrgent: FieldRef<"Message", 'Boolean'>
    readonly expiresAt: FieldRef<"Message", 'DateTime'>
    readonly formId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.class
   */
  export type Message$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Message.yearGroup
   */
  export type Message$yearGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    where?: YearGroupWhereInput
  }

  /**
   * Message.form
   */
  export type Message$formArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
  }

  /**
   * Message.acknowledgments
   */
  export type Message$acknowledgmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    where?: MessageAcknowledgmentWhereInput
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    cursor?: MessageAcknowledgmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageAcknowledgment
   */

  export type AggregateMessageAcknowledgment = {
    _count: MessageAcknowledgmentCountAggregateOutputType | null
    _min: MessageAcknowledgmentMinAggregateOutputType | null
    _max: MessageAcknowledgmentMaxAggregateOutputType | null
  }

  export type MessageAcknowledgmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageAcknowledgmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageAcknowledgmentCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type MessageAcknowledgmentMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type MessageAcknowledgmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type MessageAcknowledgmentCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAcknowledgmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAcknowledgment to aggregate.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAcknowledgments
    **/
    _count?: true | MessageAcknowledgmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAcknowledgmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAcknowledgmentMaxAggregateInputType
  }

  export type GetMessageAcknowledgmentAggregateType<T extends MessageAcknowledgmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAcknowledgment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAcknowledgment[P]>
      : GetScalarType<T[P], AggregateMessageAcknowledgment[P]>
  }




  export type MessageAcknowledgmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAcknowledgmentWhereInput
    orderBy?: MessageAcknowledgmentOrderByWithAggregationInput | MessageAcknowledgmentOrderByWithAggregationInput[]
    by: MessageAcknowledgmentScalarFieldEnum[] | MessageAcknowledgmentScalarFieldEnum
    having?: MessageAcknowledgmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAcknowledgmentCountAggregateInputType | true
    _min?: MessageAcknowledgmentMinAggregateInputType
    _max?: MessageAcknowledgmentMaxAggregateInputType
  }

  export type MessageAcknowledgmentGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    createdAt: Date
    _count: MessageAcknowledgmentCountAggregateOutputType | null
    _min: MessageAcknowledgmentMinAggregateOutputType | null
    _max: MessageAcknowledgmentMaxAggregateOutputType | null
  }

  type GetMessageAcknowledgmentGroupByPayload<T extends MessageAcknowledgmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAcknowledgmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAcknowledgmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAcknowledgmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAcknowledgmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAcknowledgmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAcknowledgment"]>

  export type MessageAcknowledgmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAcknowledgment"]>

  export type MessageAcknowledgmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type MessageAcknowledgmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageAcknowledgmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageAcknowledgmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAcknowledgment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["messageAcknowledgment"]>
    composites: {}
  }

  type MessageAcknowledgmentGetPayload<S extends boolean | null | undefined | MessageAcknowledgmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAcknowledgmentPayload, S>

  type MessageAcknowledgmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageAcknowledgmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageAcknowledgmentCountAggregateInputType | true
    }

  export interface MessageAcknowledgmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAcknowledgment'], meta: { name: 'MessageAcknowledgment' } }
    /**
     * Find zero or one MessageAcknowledgment that matches the filter.
     * @param {MessageAcknowledgmentFindUniqueArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAcknowledgmentFindUniqueArgs>(args: SelectSubset<T, MessageAcknowledgmentFindUniqueArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageAcknowledgment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageAcknowledgmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAcknowledgmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAcknowledgmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageAcknowledgment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentFindFirstArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAcknowledgmentFindFirstArgs>(args?: SelectSubset<T, MessageAcknowledgmentFindFirstArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageAcknowledgment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentFindFirstOrThrowArgs} args - Arguments to find a MessageAcknowledgment
     * @example
     * // Get one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAcknowledgmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAcknowledgmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageAcknowledgments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAcknowledgments
     * const messageAcknowledgments = await prisma.messageAcknowledgment.findMany()
     * 
     * // Get first 10 MessageAcknowledgments
     * const messageAcknowledgments = await prisma.messageAcknowledgment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAcknowledgmentWithIdOnly = await prisma.messageAcknowledgment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAcknowledgmentFindManyArgs>(args?: SelectSubset<T, MessageAcknowledgmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageAcknowledgment.
     * @param {MessageAcknowledgmentCreateArgs} args - Arguments to create a MessageAcknowledgment.
     * @example
     * // Create one MessageAcknowledgment
     * const MessageAcknowledgment = await prisma.messageAcknowledgment.create({
     *   data: {
     *     // ... data to create a MessageAcknowledgment
     *   }
     * })
     * 
     */
    create<T extends MessageAcknowledgmentCreateArgs>(args: SelectSubset<T, MessageAcknowledgmentCreateArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageAcknowledgments.
     * @param {MessageAcknowledgmentCreateManyArgs} args - Arguments to create many MessageAcknowledgments.
     * @example
     * // Create many MessageAcknowledgments
     * const messageAcknowledgment = await prisma.messageAcknowledgment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAcknowledgmentCreateManyArgs>(args?: SelectSubset<T, MessageAcknowledgmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageAcknowledgments and returns the data saved in the database.
     * @param {MessageAcknowledgmentCreateManyAndReturnArgs} args - Arguments to create many MessageAcknowledgments.
     * @example
     * // Create many MessageAcknowledgments
     * const messageAcknowledgment = await prisma.messageAcknowledgment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageAcknowledgments and only return the `id`
     * const messageAcknowledgmentWithIdOnly = await prisma.messageAcknowledgment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageAcknowledgmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageAcknowledgmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageAcknowledgment.
     * @param {MessageAcknowledgmentDeleteArgs} args - Arguments to delete one MessageAcknowledgment.
     * @example
     * // Delete one MessageAcknowledgment
     * const MessageAcknowledgment = await prisma.messageAcknowledgment.delete({
     *   where: {
     *     // ... filter to delete one MessageAcknowledgment
     *   }
     * })
     * 
     */
    delete<T extends MessageAcknowledgmentDeleteArgs>(args: SelectSubset<T, MessageAcknowledgmentDeleteArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageAcknowledgment.
     * @param {MessageAcknowledgmentUpdateArgs} args - Arguments to update one MessageAcknowledgment.
     * @example
     * // Update one MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAcknowledgmentUpdateArgs>(args: SelectSubset<T, MessageAcknowledgmentUpdateArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageAcknowledgments.
     * @param {MessageAcknowledgmentDeleteManyArgs} args - Arguments to filter MessageAcknowledgments to delete.
     * @example
     * // Delete a few MessageAcknowledgments
     * const { count } = await prisma.messageAcknowledgment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAcknowledgmentDeleteManyArgs>(args?: SelectSubset<T, MessageAcknowledgmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAcknowledgments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAcknowledgments
     * const messageAcknowledgment = await prisma.messageAcknowledgment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAcknowledgmentUpdateManyArgs>(args: SelectSubset<T, MessageAcknowledgmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageAcknowledgment.
     * @param {MessageAcknowledgmentUpsertArgs} args - Arguments to update or create a MessageAcknowledgment.
     * @example
     * // Update or create a MessageAcknowledgment
     * const messageAcknowledgment = await prisma.messageAcknowledgment.upsert({
     *   create: {
     *     // ... data to create a MessageAcknowledgment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAcknowledgment we want to update
     *   }
     * })
     */
    upsert<T extends MessageAcknowledgmentUpsertArgs>(args: SelectSubset<T, MessageAcknowledgmentUpsertArgs<ExtArgs>>): Prisma__MessageAcknowledgmentClient<$Result.GetResult<Prisma.$MessageAcknowledgmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageAcknowledgments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentCountArgs} args - Arguments to filter MessageAcknowledgments to count.
     * @example
     * // Count the number of MessageAcknowledgments
     * const count = await prisma.messageAcknowledgment.count({
     *   where: {
     *     // ... the filter for the MessageAcknowledgments we want to count
     *   }
     * })
    **/
    count<T extends MessageAcknowledgmentCountArgs>(
      args?: Subset<T, MessageAcknowledgmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAcknowledgmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAcknowledgment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAcknowledgmentAggregateArgs>(args: Subset<T, MessageAcknowledgmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAcknowledgmentAggregateType<T>>

    /**
     * Group by MessageAcknowledgment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAcknowledgmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAcknowledgmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAcknowledgmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAcknowledgmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAcknowledgmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAcknowledgmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAcknowledgment model
   */
  readonly fields: MessageAcknowledgmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAcknowledgment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAcknowledgmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAcknowledgment model
   */ 
  interface MessageAcknowledgmentFieldRefs {
    readonly id: FieldRef<"MessageAcknowledgment", 'String'>
    readonly messageId: FieldRef<"MessageAcknowledgment", 'String'>
    readonly userId: FieldRef<"MessageAcknowledgment", 'String'>
    readonly createdAt: FieldRef<"MessageAcknowledgment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageAcknowledgment findUnique
   */
  export type MessageAcknowledgmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment findUniqueOrThrow
   */
  export type MessageAcknowledgmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment findFirst
   */
  export type MessageAcknowledgmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAcknowledgments.
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAcknowledgments.
     */
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * MessageAcknowledgment findFirstOrThrow
   */
  export type MessageAcknowledgmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgment to fetch.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAcknowledgments.
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAcknowledgments.
     */
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * MessageAcknowledgment findMany
   */
  export type MessageAcknowledgmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAcknowledgments to fetch.
     */
    where?: MessageAcknowledgmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAcknowledgments to fetch.
     */
    orderBy?: MessageAcknowledgmentOrderByWithRelationInput | MessageAcknowledgmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAcknowledgments.
     */
    cursor?: MessageAcknowledgmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAcknowledgments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAcknowledgments.
     */
    skip?: number
    distinct?: MessageAcknowledgmentScalarFieldEnum | MessageAcknowledgmentScalarFieldEnum[]
  }

  /**
   * MessageAcknowledgment create
   */
  export type MessageAcknowledgmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAcknowledgment.
     */
    data: XOR<MessageAcknowledgmentCreateInput, MessageAcknowledgmentUncheckedCreateInput>
  }

  /**
   * MessageAcknowledgment createMany
   */
  export type MessageAcknowledgmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAcknowledgments.
     */
    data: MessageAcknowledgmentCreateManyInput | MessageAcknowledgmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAcknowledgment createManyAndReturn
   */
  export type MessageAcknowledgmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageAcknowledgments.
     */
    data: MessageAcknowledgmentCreateManyInput | MessageAcknowledgmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAcknowledgment update
   */
  export type MessageAcknowledgmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAcknowledgment.
     */
    data: XOR<MessageAcknowledgmentUpdateInput, MessageAcknowledgmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAcknowledgment to update.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment updateMany
   */
  export type MessageAcknowledgmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAcknowledgments.
     */
    data: XOR<MessageAcknowledgmentUpdateManyMutationInput, MessageAcknowledgmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAcknowledgments to update
     */
    where?: MessageAcknowledgmentWhereInput
  }

  /**
   * MessageAcknowledgment upsert
   */
  export type MessageAcknowledgmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAcknowledgment to update in case it exists.
     */
    where: MessageAcknowledgmentWhereUniqueInput
    /**
     * In case the MessageAcknowledgment found by the `where` argument doesn't exist, create a new MessageAcknowledgment with this data.
     */
    create: XOR<MessageAcknowledgmentCreateInput, MessageAcknowledgmentUncheckedCreateInput>
    /**
     * In case the MessageAcknowledgment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAcknowledgmentUpdateInput, MessageAcknowledgmentUncheckedUpdateInput>
  }

  /**
   * MessageAcknowledgment delete
   */
  export type MessageAcknowledgmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAcknowledgment to delete.
     */
    where: MessageAcknowledgmentWhereUniqueInput
  }

  /**
   * MessageAcknowledgment deleteMany
   */
  export type MessageAcknowledgmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAcknowledgments to delete
     */
    where?: MessageAcknowledgmentWhereInput
  }

  /**
   * MessageAcknowledgment without action
   */
  export type MessageAcknowledgmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAcknowledgment
     */
    select?: MessageAcknowledgmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAcknowledgmentInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    targetClass: string | null
    classId: string | null
    yearGroupId: string | null
    schoolId: string | null
    requiresRsvp: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    location: string | null
    targetClass: string | null
    classId: string | null
    yearGroupId: string | null
    schoolId: string | null
    requiresRsvp: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    time: number
    location: number
    targetClass: number
    classId: number
    yearGroupId: number
    schoolId: number
    requiresRsvp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    requiresRsvp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    requiresRsvp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    location?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    requiresRsvp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    date: Date
    time: string | null
    location: string | null
    targetClass: string
    classId: string | null
    yearGroupId: string | null
    schoolId: string
    requiresRsvp: boolean
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    requiresRsvp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Event$classArgs<ExtArgs>
    yearGroup?: boolean | Event$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    rsvps?: boolean | Event$rsvpsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    requiresRsvp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | Event$classArgs<ExtArgs>
    yearGroup?: boolean | Event$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    location?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    requiresRsvp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Event$classArgs<ExtArgs>
    yearGroup?: boolean | Event$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    rsvps?: boolean | Event$rsvpsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Event$classArgs<ExtArgs>
    yearGroup?: boolean | Event$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      yearGroup: Prisma.$YearGroupPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
      rsvps: Prisma.$EventRsvpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      date: Date
      time: string | null
      location: string | null
      targetClass: string
      classId: string | null
      yearGroupId: string | null
      schoolId: string
      requiresRsvp: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Event$classArgs<ExtArgs> = {}>(args?: Subset<T, Event$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    yearGroup<T extends Event$yearGroupArgs<ExtArgs> = {}>(args?: Subset<T, Event$yearGroupArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rsvps<T extends Event$rsvpsArgs<ExtArgs> = {}>(args?: Subset<T, Event$rsvpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly date: FieldRef<"Event", 'DateTime'>
    readonly time: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly targetClass: FieldRef<"Event", 'String'>
    readonly classId: FieldRef<"Event", 'String'>
    readonly yearGroupId: FieldRef<"Event", 'String'>
    readonly schoolId: FieldRef<"Event", 'String'>
    readonly requiresRsvp: FieldRef<"Event", 'Boolean'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.class
   */
  export type Event$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Event.yearGroup
   */
  export type Event$yearGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    where?: YearGroupWhereInput
  }

  /**
   * Event.rsvps
   */
  export type Event$rsvpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    where?: EventRsvpWhereInput
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    cursor?: EventRsvpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventRsvp
   */

  export type AggregateEventRsvp = {
    _count: EventRsvpCountAggregateOutputType | null
    _min: EventRsvpMinAggregateOutputType | null
    _max: EventRsvpMaxAggregateOutputType | null
  }

  export type EventRsvpMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type EventRsvpMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type EventRsvpCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    status: number
    createdAt: number
    _all: number
  }


  export type EventRsvpMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type EventRsvpMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type EventRsvpCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type EventRsvpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRsvp to aggregate.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventRsvps
    **/
    _count?: true | EventRsvpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventRsvpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventRsvpMaxAggregateInputType
  }

  export type GetEventRsvpAggregateType<T extends EventRsvpAggregateArgs> = {
        [P in keyof T & keyof AggregateEventRsvp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRsvp[P]>
      : GetScalarType<T[P], AggregateEventRsvp[P]>
  }




  export type EventRsvpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRsvpWhereInput
    orderBy?: EventRsvpOrderByWithAggregationInput | EventRsvpOrderByWithAggregationInput[]
    by: EventRsvpScalarFieldEnum[] | EventRsvpScalarFieldEnum
    having?: EventRsvpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventRsvpCountAggregateInputType | true
    _min?: EventRsvpMinAggregateInputType
    _max?: EventRsvpMaxAggregateInputType
  }

  export type EventRsvpGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    status: string
    createdAt: Date
    _count: EventRsvpCountAggregateOutputType | null
    _min: EventRsvpMinAggregateOutputType | null
    _max: EventRsvpMaxAggregateOutputType | null
  }

  type GetEventRsvpGroupByPayload<T extends EventRsvpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventRsvpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventRsvpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventRsvpGroupByOutputType[P]>
            : GetScalarType<T[P], EventRsvpGroupByOutputType[P]>
        }
      >
    >


  export type EventRsvpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRsvp"]>

  export type EventRsvpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRsvp"]>

  export type EventRsvpSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type EventRsvpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventRsvpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventRsvpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventRsvp"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["eventRsvp"]>
    composites: {}
  }

  type EventRsvpGetPayload<S extends boolean | null | undefined | EventRsvpDefaultArgs> = $Result.GetResult<Prisma.$EventRsvpPayload, S>

  type EventRsvpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventRsvpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventRsvpCountAggregateInputType | true
    }

  export interface EventRsvpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRsvp'], meta: { name: 'EventRsvp' } }
    /**
     * Find zero or one EventRsvp that matches the filter.
     * @param {EventRsvpFindUniqueArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventRsvpFindUniqueArgs>(args: SelectSubset<T, EventRsvpFindUniqueArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventRsvp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventRsvpFindUniqueOrThrowArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventRsvpFindUniqueOrThrowArgs>(args: SelectSubset<T, EventRsvpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventRsvp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpFindFirstArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventRsvpFindFirstArgs>(args?: SelectSubset<T, EventRsvpFindFirstArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventRsvp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpFindFirstOrThrowArgs} args - Arguments to find a EventRsvp
     * @example
     * // Get one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventRsvpFindFirstOrThrowArgs>(args?: SelectSubset<T, EventRsvpFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventRsvps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRsvps
     * const eventRsvps = await prisma.eventRsvp.findMany()
     * 
     * // Get first 10 EventRsvps
     * const eventRsvps = await prisma.eventRsvp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventRsvpWithIdOnly = await prisma.eventRsvp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventRsvpFindManyArgs>(args?: SelectSubset<T, EventRsvpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventRsvp.
     * @param {EventRsvpCreateArgs} args - Arguments to create a EventRsvp.
     * @example
     * // Create one EventRsvp
     * const EventRsvp = await prisma.eventRsvp.create({
     *   data: {
     *     // ... data to create a EventRsvp
     *   }
     * })
     * 
     */
    create<T extends EventRsvpCreateArgs>(args: SelectSubset<T, EventRsvpCreateArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventRsvps.
     * @param {EventRsvpCreateManyArgs} args - Arguments to create many EventRsvps.
     * @example
     * // Create many EventRsvps
     * const eventRsvp = await prisma.eventRsvp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventRsvpCreateManyArgs>(args?: SelectSubset<T, EventRsvpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventRsvps and returns the data saved in the database.
     * @param {EventRsvpCreateManyAndReturnArgs} args - Arguments to create many EventRsvps.
     * @example
     * // Create many EventRsvps
     * const eventRsvp = await prisma.eventRsvp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventRsvps and only return the `id`
     * const eventRsvpWithIdOnly = await prisma.eventRsvp.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventRsvpCreateManyAndReturnArgs>(args?: SelectSubset<T, EventRsvpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventRsvp.
     * @param {EventRsvpDeleteArgs} args - Arguments to delete one EventRsvp.
     * @example
     * // Delete one EventRsvp
     * const EventRsvp = await prisma.eventRsvp.delete({
     *   where: {
     *     // ... filter to delete one EventRsvp
     *   }
     * })
     * 
     */
    delete<T extends EventRsvpDeleteArgs>(args: SelectSubset<T, EventRsvpDeleteArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventRsvp.
     * @param {EventRsvpUpdateArgs} args - Arguments to update one EventRsvp.
     * @example
     * // Update one EventRsvp
     * const eventRsvp = await prisma.eventRsvp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventRsvpUpdateArgs>(args: SelectSubset<T, EventRsvpUpdateArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventRsvps.
     * @param {EventRsvpDeleteManyArgs} args - Arguments to filter EventRsvps to delete.
     * @example
     * // Delete a few EventRsvps
     * const { count } = await prisma.eventRsvp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventRsvpDeleteManyArgs>(args?: SelectSubset<T, EventRsvpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRsvps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRsvps
     * const eventRsvp = await prisma.eventRsvp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventRsvpUpdateManyArgs>(args: SelectSubset<T, EventRsvpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventRsvp.
     * @param {EventRsvpUpsertArgs} args - Arguments to update or create a EventRsvp.
     * @example
     * // Update or create a EventRsvp
     * const eventRsvp = await prisma.eventRsvp.upsert({
     *   create: {
     *     // ... data to create a EventRsvp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRsvp we want to update
     *   }
     * })
     */
    upsert<T extends EventRsvpUpsertArgs>(args: SelectSubset<T, EventRsvpUpsertArgs<ExtArgs>>): Prisma__EventRsvpClient<$Result.GetResult<Prisma.$EventRsvpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventRsvps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpCountArgs} args - Arguments to filter EventRsvps to count.
     * @example
     * // Count the number of EventRsvps
     * const count = await prisma.eventRsvp.count({
     *   where: {
     *     // ... the filter for the EventRsvps we want to count
     *   }
     * })
    **/
    count<T extends EventRsvpCountArgs>(
      args?: Subset<T, EventRsvpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventRsvpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventRsvp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventRsvpAggregateArgs>(args: Subset<T, EventRsvpAggregateArgs>): Prisma.PrismaPromise<GetEventRsvpAggregateType<T>>

    /**
     * Group by EventRsvp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRsvpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventRsvpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRsvpGroupByArgs['orderBy'] }
        : { orderBy?: EventRsvpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventRsvpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRsvpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventRsvp model
   */
  readonly fields: EventRsvpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRsvp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventRsvpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventRsvp model
   */ 
  interface EventRsvpFieldRefs {
    readonly id: FieldRef<"EventRsvp", 'String'>
    readonly eventId: FieldRef<"EventRsvp", 'String'>
    readonly userId: FieldRef<"EventRsvp", 'String'>
    readonly status: FieldRef<"EventRsvp", 'String'>
    readonly createdAt: FieldRef<"EventRsvp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventRsvp findUnique
   */
  export type EventRsvpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp findUniqueOrThrow
   */
  export type EventRsvpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp findFirst
   */
  export type EventRsvpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRsvps.
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRsvps.
     */
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * EventRsvp findFirstOrThrow
   */
  export type EventRsvpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvp to fetch.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRsvps.
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRsvps.
     */
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * EventRsvp findMany
   */
  export type EventRsvpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter, which EventRsvps to fetch.
     */
    where?: EventRsvpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRsvps to fetch.
     */
    orderBy?: EventRsvpOrderByWithRelationInput | EventRsvpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventRsvps.
     */
    cursor?: EventRsvpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRsvps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRsvps.
     */
    skip?: number
    distinct?: EventRsvpScalarFieldEnum | EventRsvpScalarFieldEnum[]
  }

  /**
   * EventRsvp create
   */
  export type EventRsvpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * The data needed to create a EventRsvp.
     */
    data: XOR<EventRsvpCreateInput, EventRsvpUncheckedCreateInput>
  }

  /**
   * EventRsvp createMany
   */
  export type EventRsvpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventRsvps.
     */
    data: EventRsvpCreateManyInput | EventRsvpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventRsvp createManyAndReturn
   */
  export type EventRsvpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventRsvps.
     */
    data: EventRsvpCreateManyInput | EventRsvpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventRsvp update
   */
  export type EventRsvpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * The data needed to update a EventRsvp.
     */
    data: XOR<EventRsvpUpdateInput, EventRsvpUncheckedUpdateInput>
    /**
     * Choose, which EventRsvp to update.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp updateMany
   */
  export type EventRsvpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventRsvps.
     */
    data: XOR<EventRsvpUpdateManyMutationInput, EventRsvpUncheckedUpdateManyInput>
    /**
     * Filter which EventRsvps to update
     */
    where?: EventRsvpWhereInput
  }

  /**
   * EventRsvp upsert
   */
  export type EventRsvpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * The filter to search for the EventRsvp to update in case it exists.
     */
    where: EventRsvpWhereUniqueInput
    /**
     * In case the EventRsvp found by the `where` argument doesn't exist, create a new EventRsvp with this data.
     */
    create: XOR<EventRsvpCreateInput, EventRsvpUncheckedCreateInput>
    /**
     * In case the EventRsvp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventRsvpUpdateInput, EventRsvpUncheckedUpdateInput>
  }

  /**
   * EventRsvp delete
   */
  export type EventRsvpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
    /**
     * Filter which EventRsvp to delete.
     */
    where: EventRsvpWhereUniqueInput
  }

  /**
   * EventRsvp deleteMany
   */
  export type EventRsvpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRsvps to delete
     */
    where?: EventRsvpWhereInput
  }

  /**
   * EventRsvp without action
   */
  export type EventRsvpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRsvp
     */
    select?: EventRsvpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRsvpInclude<ExtArgs> | null
  }


  /**
   * Model TermDate
   */

  export type AggregateTermDate = {
    _count: TermDateCountAggregateOutputType | null
    _avg: TermDateAvgAggregateOutputType | null
    _sum: TermDateSumAggregateOutputType | null
    _min: TermDateMinAggregateOutputType | null
    _max: TermDateMaxAggregateOutputType | null
  }

  export type TermDateAvgAggregateOutputType = {
    term: number | null
  }

  export type TermDateSumAggregateOutputType = {
    term: number | null
  }

  export type TermDateMinAggregateOutputType = {
    id: string | null
    term: number | null
    termName: string | null
    label: string | null
    sublabel: string | null
    date: Date | null
    endDate: Date | null
    type: string | null
    color: string | null
    schoolId: string | null
  }

  export type TermDateMaxAggregateOutputType = {
    id: string | null
    term: number | null
    termName: string | null
    label: string | null
    sublabel: string | null
    date: Date | null
    endDate: Date | null
    type: string | null
    color: string | null
    schoolId: string | null
  }

  export type TermDateCountAggregateOutputType = {
    id: number
    term: number
    termName: number
    label: number
    sublabel: number
    date: number
    endDate: number
    type: number
    color: number
    schoolId: number
    _all: number
  }


  export type TermDateAvgAggregateInputType = {
    term?: true
  }

  export type TermDateSumAggregateInputType = {
    term?: true
  }

  export type TermDateMinAggregateInputType = {
    id?: true
    term?: true
    termName?: true
    label?: true
    sublabel?: true
    date?: true
    endDate?: true
    type?: true
    color?: true
    schoolId?: true
  }

  export type TermDateMaxAggregateInputType = {
    id?: true
    term?: true
    termName?: true
    label?: true
    sublabel?: true
    date?: true
    endDate?: true
    type?: true
    color?: true
    schoolId?: true
  }

  export type TermDateCountAggregateInputType = {
    id?: true
    term?: true
    termName?: true
    label?: true
    sublabel?: true
    date?: true
    endDate?: true
    type?: true
    color?: true
    schoolId?: true
    _all?: true
  }

  export type TermDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermDate to aggregate.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TermDates
    **/
    _count?: true | TermDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TermDateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TermDateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermDateMaxAggregateInputType
  }

  export type GetTermDateAggregateType<T extends TermDateAggregateArgs> = {
        [P in keyof T & keyof AggregateTermDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermDate[P]>
      : GetScalarType<T[P], AggregateTermDate[P]>
  }




  export type TermDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermDateWhereInput
    orderBy?: TermDateOrderByWithAggregationInput | TermDateOrderByWithAggregationInput[]
    by: TermDateScalarFieldEnum[] | TermDateScalarFieldEnum
    having?: TermDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermDateCountAggregateInputType | true
    _avg?: TermDateAvgAggregateInputType
    _sum?: TermDateSumAggregateInputType
    _min?: TermDateMinAggregateInputType
    _max?: TermDateMaxAggregateInputType
  }

  export type TermDateGroupByOutputType = {
    id: string
    term: number
    termName: string
    label: string
    sublabel: string | null
    date: Date
    endDate: Date | null
    type: string
    color: string
    schoolId: string
    _count: TermDateCountAggregateOutputType | null
    _avg: TermDateAvgAggregateOutputType | null
    _sum: TermDateSumAggregateOutputType | null
    _min: TermDateMinAggregateOutputType | null
    _max: TermDateMaxAggregateOutputType | null
  }

  type GetTermDateGroupByPayload<T extends TermDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermDateGroupByOutputType[P]>
            : GetScalarType<T[P], TermDateGroupByOutputType[P]>
        }
      >
    >


  export type TermDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    termName?: boolean
    label?: boolean
    sublabel?: boolean
    date?: boolean
    endDate?: boolean
    type?: boolean
    color?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["termDate"]>

  export type TermDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    termName?: boolean
    label?: boolean
    sublabel?: boolean
    date?: boolean
    endDate?: boolean
    type?: boolean
    color?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["termDate"]>

  export type TermDateSelectScalar = {
    id?: boolean
    term?: boolean
    termName?: boolean
    label?: boolean
    sublabel?: boolean
    date?: boolean
    endDate?: boolean
    type?: boolean
    color?: boolean
    schoolId?: boolean
  }

  export type TermDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type TermDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $TermDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TermDate"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      term: number
      termName: string
      label: string
      sublabel: string | null
      date: Date
      endDate: Date | null
      type: string
      color: string
      schoolId: string
    }, ExtArgs["result"]["termDate"]>
    composites: {}
  }

  type TermDateGetPayload<S extends boolean | null | undefined | TermDateDefaultArgs> = $Result.GetResult<Prisma.$TermDatePayload, S>

  type TermDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TermDateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TermDateCountAggregateInputType | true
    }

  export interface TermDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TermDate'], meta: { name: 'TermDate' } }
    /**
     * Find zero or one TermDate that matches the filter.
     * @param {TermDateFindUniqueArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermDateFindUniqueArgs>(args: SelectSubset<T, TermDateFindUniqueArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TermDate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TermDateFindUniqueOrThrowArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermDateFindUniqueOrThrowArgs>(args: SelectSubset<T, TermDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TermDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateFindFirstArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermDateFindFirstArgs>(args?: SelectSubset<T, TermDateFindFirstArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TermDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateFindFirstOrThrowArgs} args - Arguments to find a TermDate
     * @example
     * // Get one TermDate
     * const termDate = await prisma.termDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermDateFindFirstOrThrowArgs>(args?: SelectSubset<T, TermDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TermDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermDates
     * const termDates = await prisma.termDate.findMany()
     * 
     * // Get first 10 TermDates
     * const termDates = await prisma.termDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termDateWithIdOnly = await prisma.termDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermDateFindManyArgs>(args?: SelectSubset<T, TermDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TermDate.
     * @param {TermDateCreateArgs} args - Arguments to create a TermDate.
     * @example
     * // Create one TermDate
     * const TermDate = await prisma.termDate.create({
     *   data: {
     *     // ... data to create a TermDate
     *   }
     * })
     * 
     */
    create<T extends TermDateCreateArgs>(args: SelectSubset<T, TermDateCreateArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TermDates.
     * @param {TermDateCreateManyArgs} args - Arguments to create many TermDates.
     * @example
     * // Create many TermDates
     * const termDate = await prisma.termDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermDateCreateManyArgs>(args?: SelectSubset<T, TermDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TermDates and returns the data saved in the database.
     * @param {TermDateCreateManyAndReturnArgs} args - Arguments to create many TermDates.
     * @example
     * // Create many TermDates
     * const termDate = await prisma.termDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TermDates and only return the `id`
     * const termDateWithIdOnly = await prisma.termDate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TermDateCreateManyAndReturnArgs>(args?: SelectSubset<T, TermDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TermDate.
     * @param {TermDateDeleteArgs} args - Arguments to delete one TermDate.
     * @example
     * // Delete one TermDate
     * const TermDate = await prisma.termDate.delete({
     *   where: {
     *     // ... filter to delete one TermDate
     *   }
     * })
     * 
     */
    delete<T extends TermDateDeleteArgs>(args: SelectSubset<T, TermDateDeleteArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TermDate.
     * @param {TermDateUpdateArgs} args - Arguments to update one TermDate.
     * @example
     * // Update one TermDate
     * const termDate = await prisma.termDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermDateUpdateArgs>(args: SelectSubset<T, TermDateUpdateArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TermDates.
     * @param {TermDateDeleteManyArgs} args - Arguments to filter TermDates to delete.
     * @example
     * // Delete a few TermDates
     * const { count } = await prisma.termDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermDateDeleteManyArgs>(args?: SelectSubset<T, TermDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermDates
     * const termDate = await prisma.termDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermDateUpdateManyArgs>(args: SelectSubset<T, TermDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TermDate.
     * @param {TermDateUpsertArgs} args - Arguments to update or create a TermDate.
     * @example
     * // Update or create a TermDate
     * const termDate = await prisma.termDate.upsert({
     *   create: {
     *     // ... data to create a TermDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermDate we want to update
     *   }
     * })
     */
    upsert<T extends TermDateUpsertArgs>(args: SelectSubset<T, TermDateUpsertArgs<ExtArgs>>): Prisma__TermDateClient<$Result.GetResult<Prisma.$TermDatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TermDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateCountArgs} args - Arguments to filter TermDates to count.
     * @example
     * // Count the number of TermDates
     * const count = await prisma.termDate.count({
     *   where: {
     *     // ... the filter for the TermDates we want to count
     *   }
     * })
    **/
    count<T extends TermDateCountArgs>(
      args?: Subset<T, TermDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermDateAggregateArgs>(args: Subset<T, TermDateAggregateArgs>): Prisma.PrismaPromise<GetTermDateAggregateType<T>>

    /**
     * Group by TermDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermDateGroupByArgs['orderBy'] }
        : { orderBy?: TermDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TermDate model
   */
  readonly fields: TermDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TermDate model
   */ 
  interface TermDateFieldRefs {
    readonly id: FieldRef<"TermDate", 'String'>
    readonly term: FieldRef<"TermDate", 'Int'>
    readonly termName: FieldRef<"TermDate", 'String'>
    readonly label: FieldRef<"TermDate", 'String'>
    readonly sublabel: FieldRef<"TermDate", 'String'>
    readonly date: FieldRef<"TermDate", 'DateTime'>
    readonly endDate: FieldRef<"TermDate", 'DateTime'>
    readonly type: FieldRef<"TermDate", 'String'>
    readonly color: FieldRef<"TermDate", 'String'>
    readonly schoolId: FieldRef<"TermDate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TermDate findUnique
   */
  export type TermDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate findUniqueOrThrow
   */
  export type TermDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate findFirst
   */
  export type TermDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermDates.
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermDates.
     */
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * TermDate findFirstOrThrow
   */
  export type TermDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDate to fetch.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermDates.
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermDates.
     */
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * TermDate findMany
   */
  export type TermDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter, which TermDates to fetch.
     */
    where?: TermDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermDates to fetch.
     */
    orderBy?: TermDateOrderByWithRelationInput | TermDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TermDates.
     */
    cursor?: TermDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermDates.
     */
    skip?: number
    distinct?: TermDateScalarFieldEnum | TermDateScalarFieldEnum[]
  }

  /**
   * TermDate create
   */
  export type TermDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * The data needed to create a TermDate.
     */
    data: XOR<TermDateCreateInput, TermDateUncheckedCreateInput>
  }

  /**
   * TermDate createMany
   */
  export type TermDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TermDates.
     */
    data: TermDateCreateManyInput | TermDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermDate createManyAndReturn
   */
  export type TermDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TermDates.
     */
    data: TermDateCreateManyInput | TermDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TermDate update
   */
  export type TermDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * The data needed to update a TermDate.
     */
    data: XOR<TermDateUpdateInput, TermDateUncheckedUpdateInput>
    /**
     * Choose, which TermDate to update.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate updateMany
   */
  export type TermDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TermDates.
     */
    data: XOR<TermDateUpdateManyMutationInput, TermDateUncheckedUpdateManyInput>
    /**
     * Filter which TermDates to update
     */
    where?: TermDateWhereInput
  }

  /**
   * TermDate upsert
   */
  export type TermDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * The filter to search for the TermDate to update in case it exists.
     */
    where: TermDateWhereUniqueInput
    /**
     * In case the TermDate found by the `where` argument doesn't exist, create a new TermDate with this data.
     */
    create: XOR<TermDateCreateInput, TermDateUncheckedCreateInput>
    /**
     * In case the TermDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermDateUpdateInput, TermDateUncheckedUpdateInput>
  }

  /**
   * TermDate delete
   */
  export type TermDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
    /**
     * Filter which TermDate to delete.
     */
    where: TermDateWhereUniqueInput
  }

  /**
   * TermDate deleteMany
   */
  export type TermDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermDates to delete
     */
    where?: TermDateWhereInput
  }

  /**
   * TermDate without action
   */
  export type TermDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermDate
     */
    select?: TermDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermDateInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleItem
   */

  export type AggregateScheduleItem = {
    _count: ScheduleItemCountAggregateOutputType | null
    _avg: ScheduleItemAvgAggregateOutputType | null
    _sum: ScheduleItemSumAggregateOutputType | null
    _min: ScheduleItemMinAggregateOutputType | null
    _max: ScheduleItemMaxAggregateOutputType | null
  }

  export type ScheduleItemAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ScheduleItemSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ScheduleItemMinAggregateOutputType = {
    id: string | null
    targetClass: string | null
    classId: string | null
    yearGroupId: string | null
    schoolId: string | null
    isRecurring: boolean | null
    dayOfWeek: number | null
    active: boolean | null
    date: Date | null
    type: string | null
    label: string | null
    description: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type ScheduleItemMaxAggregateOutputType = {
    id: string | null
    targetClass: string | null
    classId: string | null
    yearGroupId: string | null
    schoolId: string | null
    isRecurring: boolean | null
    dayOfWeek: number | null
    active: boolean | null
    date: Date | null
    type: string | null
    label: string | null
    description: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type ScheduleItemCountAggregateOutputType = {
    id: number
    targetClass: number
    classId: number
    yearGroupId: number
    schoolId: number
    isRecurring: number
    dayOfWeek: number
    active: number
    date: number
    type: number
    label: number
    description: number
    icon: number
    createdAt: number
    _all: number
  }


  export type ScheduleItemAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type ScheduleItemSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type ScheduleItemMinAggregateInputType = {
    id?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    isRecurring?: true
    dayOfWeek?: true
    active?: true
    date?: true
    type?: true
    label?: true
    description?: true
    icon?: true
    createdAt?: true
  }

  export type ScheduleItemMaxAggregateInputType = {
    id?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    isRecurring?: true
    dayOfWeek?: true
    active?: true
    date?: true
    type?: true
    label?: true
    description?: true
    icon?: true
    createdAt?: true
  }

  export type ScheduleItemCountAggregateInputType = {
    id?: true
    targetClass?: true
    classId?: true
    yearGroupId?: true
    schoolId?: true
    isRecurring?: true
    dayOfWeek?: true
    active?: true
    date?: true
    type?: true
    label?: true
    description?: true
    icon?: true
    createdAt?: true
    _all?: true
  }

  export type ScheduleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleItem to aggregate.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleItems
    **/
    _count?: true | ScheduleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleItemMaxAggregateInputType
  }

  export type GetScheduleItemAggregateType<T extends ScheduleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleItem[P]>
      : GetScalarType<T[P], AggregateScheduleItem[P]>
  }




  export type ScheduleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithAggregationInput | ScheduleItemOrderByWithAggregationInput[]
    by: ScheduleItemScalarFieldEnum[] | ScheduleItemScalarFieldEnum
    having?: ScheduleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleItemCountAggregateInputType | true
    _avg?: ScheduleItemAvgAggregateInputType
    _sum?: ScheduleItemSumAggregateInputType
    _min?: ScheduleItemMinAggregateInputType
    _max?: ScheduleItemMaxAggregateInputType
  }

  export type ScheduleItemGroupByOutputType = {
    id: string
    targetClass: string
    classId: string | null
    yearGroupId: string | null
    schoolId: string
    isRecurring: boolean
    dayOfWeek: number | null
    active: boolean
    date: Date | null
    type: string
    label: string
    description: string | null
    icon: string | null
    createdAt: Date
    _count: ScheduleItemCountAggregateOutputType | null
    _avg: ScheduleItemAvgAggregateOutputType | null
    _sum: ScheduleItemSumAggregateOutputType | null
    _min: ScheduleItemMinAggregateOutputType | null
    _max: ScheduleItemMaxAggregateOutputType | null
  }

  type GetScheduleItemGroupByPayload<T extends ScheduleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleItemGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleItemGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    isRecurring?: boolean
    dayOfWeek?: boolean
    active?: boolean
    date?: boolean
    type?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    yearGroup?: boolean | ScheduleItem$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleItem"]>

  export type ScheduleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    isRecurring?: boolean
    dayOfWeek?: boolean
    active?: boolean
    date?: boolean
    type?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    yearGroup?: boolean | ScheduleItem$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleItem"]>

  export type ScheduleItemSelectScalar = {
    id?: boolean
    targetClass?: boolean
    classId?: boolean
    yearGroupId?: boolean
    schoolId?: boolean
    isRecurring?: boolean
    dayOfWeek?: boolean
    active?: boolean
    date?: boolean
    type?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
  }

  export type ScheduleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    yearGroup?: boolean | ScheduleItem$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type ScheduleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ScheduleItem$classArgs<ExtArgs>
    yearGroup?: boolean | ScheduleItem$yearGroupArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ScheduleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleItem"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs> | null
      yearGroup: Prisma.$YearGroupPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetClass: string
      classId: string | null
      yearGroupId: string | null
      schoolId: string
      isRecurring: boolean
      dayOfWeek: number | null
      active: boolean
      date: Date | null
      type: string
      label: string
      description: string | null
      icon: string | null
      createdAt: Date
    }, ExtArgs["result"]["scheduleItem"]>
    composites: {}
  }

  type ScheduleItemGetPayload<S extends boolean | null | undefined | ScheduleItemDefaultArgs> = $Result.GetResult<Prisma.$ScheduleItemPayload, S>

  type ScheduleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduleItemCountAggregateInputType | true
    }

  export interface ScheduleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleItem'], meta: { name: 'ScheduleItem' } }
    /**
     * Find zero or one ScheduleItem that matches the filter.
     * @param {ScheduleItemFindUniqueArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleItemFindUniqueArgs>(args: SelectSubset<T, ScheduleItemFindUniqueArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduleItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduleItemFindUniqueOrThrowArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindFirstArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleItemFindFirstArgs>(args?: SelectSubset<T, ScheduleItemFindFirstArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindFirstOrThrowArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleItems
     * const scheduleItems = await prisma.scheduleItem.findMany()
     * 
     * // Get first 10 ScheduleItems
     * const scheduleItems = await prisma.scheduleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleItemWithIdOnly = await prisma.scheduleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleItemFindManyArgs>(args?: SelectSubset<T, ScheduleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduleItem.
     * @param {ScheduleItemCreateArgs} args - Arguments to create a ScheduleItem.
     * @example
     * // Create one ScheduleItem
     * const ScheduleItem = await prisma.scheduleItem.create({
     *   data: {
     *     // ... data to create a ScheduleItem
     *   }
     * })
     * 
     */
    create<T extends ScheduleItemCreateArgs>(args: SelectSubset<T, ScheduleItemCreateArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduleItems.
     * @param {ScheduleItemCreateManyArgs} args - Arguments to create many ScheduleItems.
     * @example
     * // Create many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleItemCreateManyArgs>(args?: SelectSubset<T, ScheduleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleItems and returns the data saved in the database.
     * @param {ScheduleItemCreateManyAndReturnArgs} args - Arguments to create many ScheduleItems.
     * @example
     * // Create many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleItems and only return the `id`
     * const scheduleItemWithIdOnly = await prisma.scheduleItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduleItem.
     * @param {ScheduleItemDeleteArgs} args - Arguments to delete one ScheduleItem.
     * @example
     * // Delete one ScheduleItem
     * const ScheduleItem = await prisma.scheduleItem.delete({
     *   where: {
     *     // ... filter to delete one ScheduleItem
     *   }
     * })
     * 
     */
    delete<T extends ScheduleItemDeleteArgs>(args: SelectSubset<T, ScheduleItemDeleteArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduleItem.
     * @param {ScheduleItemUpdateArgs} args - Arguments to update one ScheduleItem.
     * @example
     * // Update one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleItemUpdateArgs>(args: SelectSubset<T, ScheduleItemUpdateArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduleItems.
     * @param {ScheduleItemDeleteManyArgs} args - Arguments to filter ScheduleItems to delete.
     * @example
     * // Delete a few ScheduleItems
     * const { count } = await prisma.scheduleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleItemDeleteManyArgs>(args?: SelectSubset<T, ScheduleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleItemUpdateManyArgs>(args: SelectSubset<T, ScheduleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduleItem.
     * @param {ScheduleItemUpsertArgs} args - Arguments to update or create a ScheduleItem.
     * @example
     * // Update or create a ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.upsert({
     *   create: {
     *     // ... data to create a ScheduleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleItem we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleItemUpsertArgs>(args: SelectSubset<T, ScheduleItemUpsertArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemCountArgs} args - Arguments to filter ScheduleItems to count.
     * @example
     * // Count the number of ScheduleItems
     * const count = await prisma.scheduleItem.count({
     *   where: {
     *     // ... the filter for the ScheduleItems we want to count
     *   }
     * })
    **/
    count<T extends ScheduleItemCountArgs>(
      args?: Subset<T, ScheduleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleItemAggregateArgs>(args: Subset<T, ScheduleItemAggregateArgs>): Prisma.PrismaPromise<GetScheduleItemAggregateType<T>>

    /**
     * Group by ScheduleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleItemGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleItem model
   */
  readonly fields: ScheduleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ScheduleItem$classArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleItem$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    yearGroup<T extends ScheduleItem$yearGroupArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleItem$yearGroupArgs<ExtArgs>>): Prisma__YearGroupClient<$Result.GetResult<Prisma.$YearGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleItem model
   */ 
  interface ScheduleItemFieldRefs {
    readonly id: FieldRef<"ScheduleItem", 'String'>
    readonly targetClass: FieldRef<"ScheduleItem", 'String'>
    readonly classId: FieldRef<"ScheduleItem", 'String'>
    readonly yearGroupId: FieldRef<"ScheduleItem", 'String'>
    readonly schoolId: FieldRef<"ScheduleItem", 'String'>
    readonly isRecurring: FieldRef<"ScheduleItem", 'Boolean'>
    readonly dayOfWeek: FieldRef<"ScheduleItem", 'Int'>
    readonly active: FieldRef<"ScheduleItem", 'Boolean'>
    readonly date: FieldRef<"ScheduleItem", 'DateTime'>
    readonly type: FieldRef<"ScheduleItem", 'String'>
    readonly label: FieldRef<"ScheduleItem", 'String'>
    readonly description: FieldRef<"ScheduleItem", 'String'>
    readonly icon: FieldRef<"ScheduleItem", 'String'>
    readonly createdAt: FieldRef<"ScheduleItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleItem findUnique
   */
  export type ScheduleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem findUniqueOrThrow
   */
  export type ScheduleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem findFirst
   */
  export type ScheduleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleItems.
     */
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem findFirstOrThrow
   */
  export type ScheduleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleItems.
     */
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem findMany
   */
  export type ScheduleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItems to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem create
   */
  export type ScheduleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleItem.
     */
    data: XOR<ScheduleItemCreateInput, ScheduleItemUncheckedCreateInput>
  }

  /**
   * ScheduleItem createMany
   */
  export type ScheduleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleItems.
     */
    data: ScheduleItemCreateManyInput | ScheduleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleItem createManyAndReturn
   */
  export type ScheduleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduleItems.
     */
    data: ScheduleItemCreateManyInput | ScheduleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleItem update
   */
  export type ScheduleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleItem.
     */
    data: XOR<ScheduleItemUpdateInput, ScheduleItemUncheckedUpdateInput>
    /**
     * Choose, which ScheduleItem to update.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem updateMany
   */
  export type ScheduleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleItems.
     */
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleItems to update
     */
    where?: ScheduleItemWhereInput
  }

  /**
   * ScheduleItem upsert
   */
  export type ScheduleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleItem to update in case it exists.
     */
    where: ScheduleItemWhereUniqueInput
    /**
     * In case the ScheduleItem found by the `where` argument doesn't exist, create a new ScheduleItem with this data.
     */
    create: XOR<ScheduleItemCreateInput, ScheduleItemUncheckedCreateInput>
    /**
     * In case the ScheduleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleItemUpdateInput, ScheduleItemUncheckedUpdateInput>
  }

  /**
   * ScheduleItem delete
   */
  export type ScheduleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter which ScheduleItem to delete.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem deleteMany
   */
  export type ScheduleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleItems to delete
     */
    where?: ScheduleItemWhereInput
  }

  /**
   * ScheduleItem.class
   */
  export type ScheduleItem$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * ScheduleItem.yearGroup
   */
  export type ScheduleItem$yearGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearGroup
     */
    select?: YearGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearGroupInclude<ExtArgs> | null
    where?: YearGroupWhereInput
  }

  /**
   * ScheduleItem without action
   */
  export type ScheduleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyMessage
   */

  export type AggregateWeeklyMessage = {
    _count: WeeklyMessageCountAggregateOutputType | null
    _min: WeeklyMessageMinAggregateOutputType | null
    _max: WeeklyMessageMaxAggregateOutputType | null
  }

  export type WeeklyMessageMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    weekOf: Date | null
    isCurrent: boolean | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    weekOf: Date | null
    isCurrent: boolean | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageCountAggregateOutputType = {
    id: number
    title: number
    content: number
    weekOf: number
    isCurrent: number
    schoolId: number
    createdAt: number
    _all: number
  }


  export type WeeklyMessageMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    weekOf?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
  }

  export type WeeklyMessageMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    weekOf?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
  }

  export type WeeklyMessageCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    weekOf?: true
    isCurrent?: true
    schoolId?: true
    createdAt?: true
    _all?: true
  }

  export type WeeklyMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessage to aggregate.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyMessages
    **/
    _count?: true | WeeklyMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyMessageMaxAggregateInputType
  }

  export type GetWeeklyMessageAggregateType<T extends WeeklyMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyMessage[P]>
      : GetScalarType<T[P], AggregateWeeklyMessage[P]>
  }




  export type WeeklyMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageWhereInput
    orderBy?: WeeklyMessageOrderByWithAggregationInput | WeeklyMessageOrderByWithAggregationInput[]
    by: WeeklyMessageScalarFieldEnum[] | WeeklyMessageScalarFieldEnum
    having?: WeeklyMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyMessageCountAggregateInputType | true
    _min?: WeeklyMessageMinAggregateInputType
    _max?: WeeklyMessageMaxAggregateInputType
  }

  export type WeeklyMessageGroupByOutputType = {
    id: string
    title: string
    content: string
    weekOf: Date
    isCurrent: boolean
    schoolId: string
    createdAt: Date
    _count: WeeklyMessageCountAggregateOutputType | null
    _min: WeeklyMessageMinAggregateOutputType | null
    _max: WeeklyMessageMaxAggregateOutputType | null
  }

  type GetWeeklyMessageGroupByPayload<T extends WeeklyMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyMessageGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyMessageGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    weekOf?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    hearts?: boolean | WeeklyMessage$heartsArgs<ExtArgs>
    _count?: boolean | WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessage"]>

  export type WeeklyMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    weekOf?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessage"]>

  export type WeeklyMessageSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    weekOf?: boolean
    isCurrent?: boolean
    schoolId?: boolean
    createdAt?: boolean
  }

  export type WeeklyMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    hearts?: boolean | WeeklyMessage$heartsArgs<ExtArgs>
    _count?: boolean | WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeeklyMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $WeeklyMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyMessage"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      hearts: Prisma.$WeeklyMessageHeartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      weekOf: Date
      isCurrent: boolean
      schoolId: string
      createdAt: Date
    }, ExtArgs["result"]["weeklyMessage"]>
    composites: {}
  }

  type WeeklyMessageGetPayload<S extends boolean | null | undefined | WeeklyMessageDefaultArgs> = $Result.GetResult<Prisma.$WeeklyMessagePayload, S>

  type WeeklyMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeeklyMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeeklyMessageCountAggregateInputType | true
    }

  export interface WeeklyMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyMessage'], meta: { name: 'WeeklyMessage' } }
    /**
     * Find zero or one WeeklyMessage that matches the filter.
     * @param {WeeklyMessageFindUniqueArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyMessageFindUniqueArgs>(args: SelectSubset<T, WeeklyMessageFindUniqueArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeeklyMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeeklyMessageFindUniqueOrThrowArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeeklyMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageFindFirstArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyMessageFindFirstArgs>(args?: SelectSubset<T, WeeklyMessageFindFirstArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeeklyMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageFindFirstOrThrowArgs} args - Arguments to find a WeeklyMessage
     * @example
     * // Get one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeeklyMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyMessages
     * const weeklyMessages = await prisma.weeklyMessage.findMany()
     * 
     * // Get first 10 WeeklyMessages
     * const weeklyMessages = await prisma.weeklyMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyMessageWithIdOnly = await prisma.weeklyMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyMessageFindManyArgs>(args?: SelectSubset<T, WeeklyMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeeklyMessage.
     * @param {WeeklyMessageCreateArgs} args - Arguments to create a WeeklyMessage.
     * @example
     * // Create one WeeklyMessage
     * const WeeklyMessage = await prisma.weeklyMessage.create({
     *   data: {
     *     // ... data to create a WeeklyMessage
     *   }
     * })
     * 
     */
    create<T extends WeeklyMessageCreateArgs>(args: SelectSubset<T, WeeklyMessageCreateArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeeklyMessages.
     * @param {WeeklyMessageCreateManyArgs} args - Arguments to create many WeeklyMessages.
     * @example
     * // Create many WeeklyMessages
     * const weeklyMessage = await prisma.weeklyMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyMessageCreateManyArgs>(args?: SelectSubset<T, WeeklyMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklyMessages and returns the data saved in the database.
     * @param {WeeklyMessageCreateManyAndReturnArgs} args - Arguments to create many WeeklyMessages.
     * @example
     * // Create many WeeklyMessages
     * const weeklyMessage = await prisma.weeklyMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklyMessages and only return the `id`
     * const weeklyMessageWithIdOnly = await prisma.weeklyMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeeklyMessage.
     * @param {WeeklyMessageDeleteArgs} args - Arguments to delete one WeeklyMessage.
     * @example
     * // Delete one WeeklyMessage
     * const WeeklyMessage = await prisma.weeklyMessage.delete({
     *   where: {
     *     // ... filter to delete one WeeklyMessage
     *   }
     * })
     * 
     */
    delete<T extends WeeklyMessageDeleteArgs>(args: SelectSubset<T, WeeklyMessageDeleteArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeeklyMessage.
     * @param {WeeklyMessageUpdateArgs} args - Arguments to update one WeeklyMessage.
     * @example
     * // Update one WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyMessageUpdateArgs>(args: SelectSubset<T, WeeklyMessageUpdateArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeeklyMessages.
     * @param {WeeklyMessageDeleteManyArgs} args - Arguments to filter WeeklyMessages to delete.
     * @example
     * // Delete a few WeeklyMessages
     * const { count } = await prisma.weeklyMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyMessageDeleteManyArgs>(args?: SelectSubset<T, WeeklyMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyMessages
     * const weeklyMessage = await prisma.weeklyMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyMessageUpdateManyArgs>(args: SelectSubset<T, WeeklyMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeeklyMessage.
     * @param {WeeklyMessageUpsertArgs} args - Arguments to update or create a WeeklyMessage.
     * @example
     * // Update or create a WeeklyMessage
     * const weeklyMessage = await prisma.weeklyMessage.upsert({
     *   create: {
     *     // ... data to create a WeeklyMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyMessage we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyMessageUpsertArgs>(args: SelectSubset<T, WeeklyMessageUpsertArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeeklyMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageCountArgs} args - Arguments to filter WeeklyMessages to count.
     * @example
     * // Count the number of WeeklyMessages
     * const count = await prisma.weeklyMessage.count({
     *   where: {
     *     // ... the filter for the WeeklyMessages we want to count
     *   }
     * })
    **/
    count<T extends WeeklyMessageCountArgs>(
      args?: Subset<T, WeeklyMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyMessageAggregateArgs>(args: Subset<T, WeeklyMessageAggregateArgs>): Prisma.PrismaPromise<GetWeeklyMessageAggregateType<T>>

    /**
     * Group by WeeklyMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyMessageGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyMessage model
   */
  readonly fields: WeeklyMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hearts<T extends WeeklyMessage$heartsArgs<ExtArgs> = {}>(args?: Subset<T, WeeklyMessage$heartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyMessage model
   */ 
  interface WeeklyMessageFieldRefs {
    readonly id: FieldRef<"WeeklyMessage", 'String'>
    readonly title: FieldRef<"WeeklyMessage", 'String'>
    readonly content: FieldRef<"WeeklyMessage", 'String'>
    readonly weekOf: FieldRef<"WeeklyMessage", 'DateTime'>
    readonly isCurrent: FieldRef<"WeeklyMessage", 'Boolean'>
    readonly schoolId: FieldRef<"WeeklyMessage", 'String'>
    readonly createdAt: FieldRef<"WeeklyMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyMessage findUnique
   */
  export type WeeklyMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage findUniqueOrThrow
   */
  export type WeeklyMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage findFirst
   */
  export type WeeklyMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessages.
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessages.
     */
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * WeeklyMessage findFirstOrThrow
   */
  export type WeeklyMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessage to fetch.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessages.
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessages.
     */
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * WeeklyMessage findMany
   */
  export type WeeklyMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessages to fetch.
     */
    where?: WeeklyMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessages to fetch.
     */
    orderBy?: WeeklyMessageOrderByWithRelationInput | WeeklyMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyMessages.
     */
    cursor?: WeeklyMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessages.
     */
    skip?: number
    distinct?: WeeklyMessageScalarFieldEnum | WeeklyMessageScalarFieldEnum[]
  }

  /**
   * WeeklyMessage create
   */
  export type WeeklyMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyMessage.
     */
    data: XOR<WeeklyMessageCreateInput, WeeklyMessageUncheckedCreateInput>
  }

  /**
   * WeeklyMessage createMany
   */
  export type WeeklyMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyMessages.
     */
    data: WeeklyMessageCreateManyInput | WeeklyMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyMessage createManyAndReturn
   */
  export type WeeklyMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeeklyMessages.
     */
    data: WeeklyMessageCreateManyInput | WeeklyMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyMessage update
   */
  export type WeeklyMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyMessage.
     */
    data: XOR<WeeklyMessageUpdateInput, WeeklyMessageUncheckedUpdateInput>
    /**
     * Choose, which WeeklyMessage to update.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage updateMany
   */
  export type WeeklyMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyMessages.
     */
    data: XOR<WeeklyMessageUpdateManyMutationInput, WeeklyMessageUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyMessages to update
     */
    where?: WeeklyMessageWhereInput
  }

  /**
   * WeeklyMessage upsert
   */
  export type WeeklyMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyMessage to update in case it exists.
     */
    where: WeeklyMessageWhereUniqueInput
    /**
     * In case the WeeklyMessage found by the `where` argument doesn't exist, create a new WeeklyMessage with this data.
     */
    create: XOR<WeeklyMessageCreateInput, WeeklyMessageUncheckedCreateInput>
    /**
     * In case the WeeklyMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyMessageUpdateInput, WeeklyMessageUncheckedUpdateInput>
  }

  /**
   * WeeklyMessage delete
   */
  export type WeeklyMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
    /**
     * Filter which WeeklyMessage to delete.
     */
    where: WeeklyMessageWhereUniqueInput
  }

  /**
   * WeeklyMessage deleteMany
   */
  export type WeeklyMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessages to delete
     */
    where?: WeeklyMessageWhereInput
  }

  /**
   * WeeklyMessage.hearts
   */
  export type WeeklyMessage$heartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    where?: WeeklyMessageHeartWhereInput
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    cursor?: WeeklyMessageHeartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessage without action
   */
  export type WeeklyMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessage
     */
    select?: WeeklyMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyMessageHeart
   */

  export type AggregateWeeklyMessageHeart = {
    _count: WeeklyMessageHeartCountAggregateOutputType | null
    _min: WeeklyMessageHeartMinAggregateOutputType | null
    _max: WeeklyMessageHeartMaxAggregateOutputType | null
  }

  export type WeeklyMessageHeartMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageHeartMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type WeeklyMessageHeartCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type WeeklyMessageHeartMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type WeeklyMessageHeartMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
  }

  export type WeeklyMessageHeartCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type WeeklyMessageHeartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessageHeart to aggregate.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyMessageHearts
    **/
    _count?: true | WeeklyMessageHeartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyMessageHeartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyMessageHeartMaxAggregateInputType
  }

  export type GetWeeklyMessageHeartAggregateType<T extends WeeklyMessageHeartAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyMessageHeart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyMessageHeart[P]>
      : GetScalarType<T[P], AggregateWeeklyMessageHeart[P]>
  }




  export type WeeklyMessageHeartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyMessageHeartWhereInput
    orderBy?: WeeklyMessageHeartOrderByWithAggregationInput | WeeklyMessageHeartOrderByWithAggregationInput[]
    by: WeeklyMessageHeartScalarFieldEnum[] | WeeklyMessageHeartScalarFieldEnum
    having?: WeeklyMessageHeartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyMessageHeartCountAggregateInputType | true
    _min?: WeeklyMessageHeartMinAggregateInputType
    _max?: WeeklyMessageHeartMaxAggregateInputType
  }

  export type WeeklyMessageHeartGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    createdAt: Date
    _count: WeeklyMessageHeartCountAggregateOutputType | null
    _min: WeeklyMessageHeartMinAggregateOutputType | null
    _max: WeeklyMessageHeartMaxAggregateOutputType | null
  }

  type GetWeeklyMessageHeartGroupByPayload<T extends WeeklyMessageHeartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyMessageHeartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyMessageHeartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyMessageHeartGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyMessageHeartGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyMessageHeartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessageHeart"]>

  export type WeeklyMessageHeartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyMessageHeart"]>

  export type WeeklyMessageHeartSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type WeeklyMessageHeartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WeeklyMessageHeartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | WeeklyMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WeeklyMessageHeartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyMessageHeart"
    objects: {
      message: Prisma.$WeeklyMessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["weeklyMessageHeart"]>
    composites: {}
  }

  type WeeklyMessageHeartGetPayload<S extends boolean | null | undefined | WeeklyMessageHeartDefaultArgs> = $Result.GetResult<Prisma.$WeeklyMessageHeartPayload, S>

  type WeeklyMessageHeartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeeklyMessageHeartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeeklyMessageHeartCountAggregateInputType | true
    }

  export interface WeeklyMessageHeartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyMessageHeart'], meta: { name: 'WeeklyMessageHeart' } }
    /**
     * Find zero or one WeeklyMessageHeart that matches the filter.
     * @param {WeeklyMessageHeartFindUniqueArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyMessageHeartFindUniqueArgs>(args: SelectSubset<T, WeeklyMessageHeartFindUniqueArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeeklyMessageHeart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeeklyMessageHeartFindUniqueOrThrowArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyMessageHeartFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyMessageHeartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeeklyMessageHeart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartFindFirstArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyMessageHeartFindFirstArgs>(args?: SelectSubset<T, WeeklyMessageHeartFindFirstArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeeklyMessageHeart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartFindFirstOrThrowArgs} args - Arguments to find a WeeklyMessageHeart
     * @example
     * // Get one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyMessageHeartFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyMessageHeartFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeeklyMessageHearts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyMessageHearts
     * const weeklyMessageHearts = await prisma.weeklyMessageHeart.findMany()
     * 
     * // Get first 10 WeeklyMessageHearts
     * const weeklyMessageHearts = await prisma.weeklyMessageHeart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyMessageHeartWithIdOnly = await prisma.weeklyMessageHeart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyMessageHeartFindManyArgs>(args?: SelectSubset<T, WeeklyMessageHeartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeeklyMessageHeart.
     * @param {WeeklyMessageHeartCreateArgs} args - Arguments to create a WeeklyMessageHeart.
     * @example
     * // Create one WeeklyMessageHeart
     * const WeeklyMessageHeart = await prisma.weeklyMessageHeart.create({
     *   data: {
     *     // ... data to create a WeeklyMessageHeart
     *   }
     * })
     * 
     */
    create<T extends WeeklyMessageHeartCreateArgs>(args: SelectSubset<T, WeeklyMessageHeartCreateArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeeklyMessageHearts.
     * @param {WeeklyMessageHeartCreateManyArgs} args - Arguments to create many WeeklyMessageHearts.
     * @example
     * // Create many WeeklyMessageHearts
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyMessageHeartCreateManyArgs>(args?: SelectSubset<T, WeeklyMessageHeartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklyMessageHearts and returns the data saved in the database.
     * @param {WeeklyMessageHeartCreateManyAndReturnArgs} args - Arguments to create many WeeklyMessageHearts.
     * @example
     * // Create many WeeklyMessageHearts
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklyMessageHearts and only return the `id`
     * const weeklyMessageHeartWithIdOnly = await prisma.weeklyMessageHeart.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyMessageHeartCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyMessageHeartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeeklyMessageHeart.
     * @param {WeeklyMessageHeartDeleteArgs} args - Arguments to delete one WeeklyMessageHeart.
     * @example
     * // Delete one WeeklyMessageHeart
     * const WeeklyMessageHeart = await prisma.weeklyMessageHeart.delete({
     *   where: {
     *     // ... filter to delete one WeeklyMessageHeart
     *   }
     * })
     * 
     */
    delete<T extends WeeklyMessageHeartDeleteArgs>(args: SelectSubset<T, WeeklyMessageHeartDeleteArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeeklyMessageHeart.
     * @param {WeeklyMessageHeartUpdateArgs} args - Arguments to update one WeeklyMessageHeart.
     * @example
     * // Update one WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyMessageHeartUpdateArgs>(args: SelectSubset<T, WeeklyMessageHeartUpdateArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeeklyMessageHearts.
     * @param {WeeklyMessageHeartDeleteManyArgs} args - Arguments to filter WeeklyMessageHearts to delete.
     * @example
     * // Delete a few WeeklyMessageHearts
     * const { count } = await prisma.weeklyMessageHeart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyMessageHeartDeleteManyArgs>(args?: SelectSubset<T, WeeklyMessageHeartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyMessageHearts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyMessageHearts
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyMessageHeartUpdateManyArgs>(args: SelectSubset<T, WeeklyMessageHeartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeeklyMessageHeart.
     * @param {WeeklyMessageHeartUpsertArgs} args - Arguments to update or create a WeeklyMessageHeart.
     * @example
     * // Update or create a WeeklyMessageHeart
     * const weeklyMessageHeart = await prisma.weeklyMessageHeart.upsert({
     *   create: {
     *     // ... data to create a WeeklyMessageHeart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyMessageHeart we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyMessageHeartUpsertArgs>(args: SelectSubset<T, WeeklyMessageHeartUpsertArgs<ExtArgs>>): Prisma__WeeklyMessageHeartClient<$Result.GetResult<Prisma.$WeeklyMessageHeartPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeeklyMessageHearts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartCountArgs} args - Arguments to filter WeeklyMessageHearts to count.
     * @example
     * // Count the number of WeeklyMessageHearts
     * const count = await prisma.weeklyMessageHeart.count({
     *   where: {
     *     // ... the filter for the WeeklyMessageHearts we want to count
     *   }
     * })
    **/
    count<T extends WeeklyMessageHeartCountArgs>(
      args?: Subset<T, WeeklyMessageHeartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyMessageHeartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyMessageHeart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyMessageHeartAggregateArgs>(args: Subset<T, WeeklyMessageHeartAggregateArgs>): Prisma.PrismaPromise<GetWeeklyMessageHeartAggregateType<T>>

    /**
     * Group by WeeklyMessageHeart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyMessageHeartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyMessageHeartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyMessageHeartGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyMessageHeartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyMessageHeartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyMessageHeartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyMessageHeart model
   */
  readonly fields: WeeklyMessageHeartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyMessageHeart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyMessageHeartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends WeeklyMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeeklyMessageDefaultArgs<ExtArgs>>): Prisma__WeeklyMessageClient<$Result.GetResult<Prisma.$WeeklyMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyMessageHeart model
   */ 
  interface WeeklyMessageHeartFieldRefs {
    readonly id: FieldRef<"WeeklyMessageHeart", 'String'>
    readonly messageId: FieldRef<"WeeklyMessageHeart", 'String'>
    readonly userId: FieldRef<"WeeklyMessageHeart", 'String'>
    readonly createdAt: FieldRef<"WeeklyMessageHeart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyMessageHeart findUnique
   */
  export type WeeklyMessageHeartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart findUniqueOrThrow
   */
  export type WeeklyMessageHeartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart findFirst
   */
  export type WeeklyMessageHeartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessageHearts.
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessageHearts.
     */
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessageHeart findFirstOrThrow
   */
  export type WeeklyMessageHeartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHeart to fetch.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyMessageHearts.
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyMessageHearts.
     */
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessageHeart findMany
   */
  export type WeeklyMessageHeartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyMessageHearts to fetch.
     */
    where?: WeeklyMessageHeartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyMessageHearts to fetch.
     */
    orderBy?: WeeklyMessageHeartOrderByWithRelationInput | WeeklyMessageHeartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyMessageHearts.
     */
    cursor?: WeeklyMessageHeartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyMessageHearts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyMessageHearts.
     */
    skip?: number
    distinct?: WeeklyMessageHeartScalarFieldEnum | WeeklyMessageHeartScalarFieldEnum[]
  }

  /**
   * WeeklyMessageHeart create
   */
  export type WeeklyMessageHeartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyMessageHeart.
     */
    data: XOR<WeeklyMessageHeartCreateInput, WeeklyMessageHeartUncheckedCreateInput>
  }

  /**
   * WeeklyMessageHeart createMany
   */
  export type WeeklyMessageHeartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyMessageHearts.
     */
    data: WeeklyMessageHeartCreateManyInput | WeeklyMessageHeartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyMessageHeart createManyAndReturn
   */
  export type WeeklyMessageHeartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeeklyMessageHearts.
     */
    data: WeeklyMessageHeartCreateManyInput | WeeklyMessageHeartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyMessageHeart update
   */
  export type WeeklyMessageHeartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyMessageHeart.
     */
    data: XOR<WeeklyMessageHeartUpdateInput, WeeklyMessageHeartUncheckedUpdateInput>
    /**
     * Choose, which WeeklyMessageHeart to update.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart updateMany
   */
  export type WeeklyMessageHeartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyMessageHearts.
     */
    data: XOR<WeeklyMessageHeartUpdateManyMutationInput, WeeklyMessageHeartUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyMessageHearts to update
     */
    where?: WeeklyMessageHeartWhereInput
  }

  /**
   * WeeklyMessageHeart upsert
   */
  export type WeeklyMessageHeartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyMessageHeart to update in case it exists.
     */
    where: WeeklyMessageHeartWhereUniqueInput
    /**
     * In case the WeeklyMessageHeart found by the `where` argument doesn't exist, create a new WeeklyMessageHeart with this data.
     */
    create: XOR<WeeklyMessageHeartCreateInput, WeeklyMessageHeartUncheckedCreateInput>
    /**
     * In case the WeeklyMessageHeart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyMessageHeartUpdateInput, WeeklyMessageHeartUncheckedUpdateInput>
  }

  /**
   * WeeklyMessageHeart delete
   */
  export type WeeklyMessageHeartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
    /**
     * Filter which WeeklyMessageHeart to delete.
     */
    where: WeeklyMessageHeartWhereUniqueInput
  }

  /**
   * WeeklyMessageHeart deleteMany
   */
  export type WeeklyMessageHeartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyMessageHearts to delete
     */
    where?: WeeklyMessageHeartWhereInput
  }

  /**
   * WeeklyMessageHeart without action
   */
  export type WeeklyMessageHeartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyMessageHeart
     */
    select?: WeeklyMessageHeartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyMessageHeartInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeCategory
   */

  export type AggregateKnowledgeCategory = {
    _count: KnowledgeCategoryCountAggregateOutputType | null
    _avg: KnowledgeCategoryAvgAggregateOutputType | null
    _sum: KnowledgeCategorySumAggregateOutputType | null
    _min: KnowledgeCategoryMinAggregateOutputType | null
    _max: KnowledgeCategoryMaxAggregateOutputType | null
  }

  export type KnowledgeCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type KnowledgeCategorySumAggregateOutputType = {
    order: number | null
  }

  export type KnowledgeCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    order: number | null
    schoolId: string | null
  }

  export type KnowledgeCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    order: number | null
    schoolId: string | null
  }

  export type KnowledgeCategoryCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    color: number
    order: number
    schoolId: number
    _all: number
  }


  export type KnowledgeCategoryAvgAggregateInputType = {
    order?: true
  }

  export type KnowledgeCategorySumAggregateInputType = {
    order?: true
  }

  export type KnowledgeCategoryMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    order?: true
    schoolId?: true
  }

  export type KnowledgeCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    order?: true
    schoolId?: true
  }

  export type KnowledgeCategoryCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    order?: true
    schoolId?: true
    _all?: true
  }

  export type KnowledgeCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeCategory to aggregate.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeCategories
    **/
    _count?: true | KnowledgeCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeCategoryMaxAggregateInputType
  }

  export type GetKnowledgeCategoryAggregateType<T extends KnowledgeCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeCategory[P]>
      : GetScalarType<T[P], AggregateKnowledgeCategory[P]>
  }




  export type KnowledgeCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeCategoryWhereInput
    orderBy?: KnowledgeCategoryOrderByWithAggregationInput | KnowledgeCategoryOrderByWithAggregationInput[]
    by: KnowledgeCategoryScalarFieldEnum[] | KnowledgeCategoryScalarFieldEnum
    having?: KnowledgeCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeCategoryCountAggregateInputType | true
    _avg?: KnowledgeCategoryAvgAggregateInputType
    _sum?: KnowledgeCategorySumAggregateInputType
    _min?: KnowledgeCategoryMinAggregateInputType
    _max?: KnowledgeCategoryMaxAggregateInputType
  }

  export type KnowledgeCategoryGroupByOutputType = {
    id: string
    name: string
    icon: string
    color: string
    order: number
    schoolId: string
    _count: KnowledgeCategoryCountAggregateOutputType | null
    _avg: KnowledgeCategoryAvgAggregateOutputType | null
    _sum: KnowledgeCategorySumAggregateOutputType | null
    _min: KnowledgeCategoryMinAggregateOutputType | null
    _max: KnowledgeCategoryMaxAggregateOutputType | null
  }

  type GetKnowledgeCategoryGroupByPayload<T extends KnowledgeCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeCategoryGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    articles?: boolean | KnowledgeCategory$articlesArgs<ExtArgs>
    _count?: boolean | KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeCategory"]>

  export type KnowledgeCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    schoolId?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeCategory"]>

  export type KnowledgeCategorySelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    schoolId?: boolean
  }

  export type KnowledgeCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    articles?: boolean | KnowledgeCategory$articlesArgs<ExtArgs>
    _count?: boolean | KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $KnowledgeCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeCategory"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      articles: Prisma.$KnowledgeArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      color: string
      order: number
      schoolId: string
    }, ExtArgs["result"]["knowledgeCategory"]>
    composites: {}
  }

  type KnowledgeCategoryGetPayload<S extends boolean | null | undefined | KnowledgeCategoryDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeCategoryPayload, S>

  type KnowledgeCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeCategoryCountAggregateInputType | true
    }

  export interface KnowledgeCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeCategory'], meta: { name: 'KnowledgeCategory' } }
    /**
     * Find zero or one KnowledgeCategory that matches the filter.
     * @param {KnowledgeCategoryFindUniqueArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeCategoryFindUniqueArgs>(args: SelectSubset<T, KnowledgeCategoryFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeCategoryFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryFindFirstArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeCategoryFindFirstArgs>(args?: SelectSubset<T, KnowledgeCategoryFindFirstArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryFindFirstOrThrowArgs} args - Arguments to find a KnowledgeCategory
     * @example
     * // Get one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeCategories
     * const knowledgeCategories = await prisma.knowledgeCategory.findMany()
     * 
     * // Get first 10 KnowledgeCategories
     * const knowledgeCategories = await prisma.knowledgeCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeCategoryWithIdOnly = await prisma.knowledgeCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeCategoryFindManyArgs>(args?: SelectSubset<T, KnowledgeCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeCategory.
     * @param {KnowledgeCategoryCreateArgs} args - Arguments to create a KnowledgeCategory.
     * @example
     * // Create one KnowledgeCategory
     * const KnowledgeCategory = await prisma.knowledgeCategory.create({
     *   data: {
     *     // ... data to create a KnowledgeCategory
     *   }
     * })
     * 
     */
    create<T extends KnowledgeCategoryCreateArgs>(args: SelectSubset<T, KnowledgeCategoryCreateArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeCategories.
     * @param {KnowledgeCategoryCreateManyArgs} args - Arguments to create many KnowledgeCategories.
     * @example
     * // Create many KnowledgeCategories
     * const knowledgeCategory = await prisma.knowledgeCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeCategoryCreateManyArgs>(args?: SelectSubset<T, KnowledgeCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeCategories and returns the data saved in the database.
     * @param {KnowledgeCategoryCreateManyAndReturnArgs} args - Arguments to create many KnowledgeCategories.
     * @example
     * // Create many KnowledgeCategories
     * const knowledgeCategory = await prisma.knowledgeCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeCategories and only return the `id`
     * const knowledgeCategoryWithIdOnly = await prisma.knowledgeCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KnowledgeCategory.
     * @param {KnowledgeCategoryDeleteArgs} args - Arguments to delete one KnowledgeCategory.
     * @example
     * // Delete one KnowledgeCategory
     * const KnowledgeCategory = await prisma.knowledgeCategory.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeCategory
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeCategoryDeleteArgs>(args: SelectSubset<T, KnowledgeCategoryDeleteArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeCategory.
     * @param {KnowledgeCategoryUpdateArgs} args - Arguments to update one KnowledgeCategory.
     * @example
     * // Update one KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeCategoryUpdateArgs>(args: SelectSubset<T, KnowledgeCategoryUpdateArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeCategories.
     * @param {KnowledgeCategoryDeleteManyArgs} args - Arguments to filter KnowledgeCategories to delete.
     * @example
     * // Delete a few KnowledgeCategories
     * const { count } = await prisma.knowledgeCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeCategoryDeleteManyArgs>(args?: SelectSubset<T, KnowledgeCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeCategories
     * const knowledgeCategory = await prisma.knowledgeCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeCategoryUpdateManyArgs>(args: SelectSubset<T, KnowledgeCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeCategory.
     * @param {KnowledgeCategoryUpsertArgs} args - Arguments to update or create a KnowledgeCategory.
     * @example
     * // Update or create a KnowledgeCategory
     * const knowledgeCategory = await prisma.knowledgeCategory.upsert({
     *   create: {
     *     // ... data to create a KnowledgeCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeCategory we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeCategoryUpsertArgs>(args: SelectSubset<T, KnowledgeCategoryUpsertArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryCountArgs} args - Arguments to filter KnowledgeCategories to count.
     * @example
     * // Count the number of KnowledgeCategories
     * const count = await prisma.knowledgeCategory.count({
     *   where: {
     *     // ... the filter for the KnowledgeCategories we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeCategoryCountArgs>(
      args?: Subset<T, KnowledgeCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeCategoryAggregateArgs>(args: Subset<T, KnowledgeCategoryAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeCategoryAggregateType<T>>

    /**
     * Group by KnowledgeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeCategoryGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeCategory model
   */
  readonly fields: KnowledgeCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    articles<T extends KnowledgeCategory$articlesArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeCategory$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeCategory model
   */ 
  interface KnowledgeCategoryFieldRefs {
    readonly id: FieldRef<"KnowledgeCategory", 'String'>
    readonly name: FieldRef<"KnowledgeCategory", 'String'>
    readonly icon: FieldRef<"KnowledgeCategory", 'String'>
    readonly color: FieldRef<"KnowledgeCategory", 'String'>
    readonly order: FieldRef<"KnowledgeCategory", 'Int'>
    readonly schoolId: FieldRef<"KnowledgeCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeCategory findUnique
   */
  export type KnowledgeCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory findUniqueOrThrow
   */
  export type KnowledgeCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory findFirst
   */
  export type KnowledgeCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeCategories.
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeCategories.
     */
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory findFirstOrThrow
   */
  export type KnowledgeCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategory to fetch.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeCategories.
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeCategories.
     */
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory findMany
   */
  export type KnowledgeCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeCategories to fetch.
     */
    where?: KnowledgeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeCategories to fetch.
     */
    orderBy?: KnowledgeCategoryOrderByWithRelationInput | KnowledgeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeCategories.
     */
    cursor?: KnowledgeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeCategories.
     */
    skip?: number
    distinct?: KnowledgeCategoryScalarFieldEnum | KnowledgeCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory create
   */
  export type KnowledgeCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeCategory.
     */
    data: XOR<KnowledgeCategoryCreateInput, KnowledgeCategoryUncheckedCreateInput>
  }

  /**
   * KnowledgeCategory createMany
   */
  export type KnowledgeCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeCategories.
     */
    data: KnowledgeCategoryCreateManyInput | KnowledgeCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeCategory createManyAndReturn
   */
  export type KnowledgeCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KnowledgeCategories.
     */
    data: KnowledgeCategoryCreateManyInput | KnowledgeCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeCategory update
   */
  export type KnowledgeCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeCategory.
     */
    data: XOR<KnowledgeCategoryUpdateInput, KnowledgeCategoryUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeCategory to update.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory updateMany
   */
  export type KnowledgeCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeCategories.
     */
    data: XOR<KnowledgeCategoryUpdateManyMutationInput, KnowledgeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeCategories to update
     */
    where?: KnowledgeCategoryWhereInput
  }

  /**
   * KnowledgeCategory upsert
   */
  export type KnowledgeCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeCategory to update in case it exists.
     */
    where: KnowledgeCategoryWhereUniqueInput
    /**
     * In case the KnowledgeCategory found by the `where` argument doesn't exist, create a new KnowledgeCategory with this data.
     */
    create: XOR<KnowledgeCategoryCreateInput, KnowledgeCategoryUncheckedCreateInput>
    /**
     * In case the KnowledgeCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeCategoryUpdateInput, KnowledgeCategoryUncheckedUpdateInput>
  }

  /**
   * KnowledgeCategory delete
   */
  export type KnowledgeCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeCategory to delete.
     */
    where: KnowledgeCategoryWhereUniqueInput
  }

  /**
   * KnowledgeCategory deleteMany
   */
  export type KnowledgeCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeCategories to delete
     */
    where?: KnowledgeCategoryWhereInput
  }

  /**
   * KnowledgeCategory.articles
   */
  export type KnowledgeCategory$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    where?: KnowledgeArticleWhereInput
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    cursor?: KnowledgeArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeCategory without action
   */
  export type KnowledgeCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCategory
     */
    select?: KnowledgeCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeCategoryInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeArticle
   */

  export type AggregateKnowledgeArticle = {
    _count: KnowledgeArticleCountAggregateOutputType | null
    _min: KnowledgeArticleMinAggregateOutputType | null
    _max: KnowledgeArticleMaxAggregateOutputType | null
  }

  export type KnowledgeArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type KnowledgeArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    categoryId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type KnowledgeArticleCountAggregateOutputType = {
    id: number
    title: number
    content: number
    categoryId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type KnowledgeArticleMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type KnowledgeArticleMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type KnowledgeArticleCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    categoryId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type KnowledgeArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeArticle to aggregate.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeArticles
    **/
    _count?: true | KnowledgeArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeArticleMaxAggregateInputType
  }

  export type GetKnowledgeArticleAggregateType<T extends KnowledgeArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeArticle[P]>
      : GetScalarType<T[P], AggregateKnowledgeArticle[P]>
  }




  export type KnowledgeArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeArticleWhereInput
    orderBy?: KnowledgeArticleOrderByWithAggregationInput | KnowledgeArticleOrderByWithAggregationInput[]
    by: KnowledgeArticleScalarFieldEnum[] | KnowledgeArticleScalarFieldEnum
    having?: KnowledgeArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeArticleCountAggregateInputType | true
    _min?: KnowledgeArticleMinAggregateInputType
    _max?: KnowledgeArticleMaxAggregateInputType
  }

  export type KnowledgeArticleGroupByOutputType = {
    id: string
    title: string
    content: string
    categoryId: string
    updatedAt: Date
    createdAt: Date
    _count: KnowledgeArticleCountAggregateOutputType | null
    _min: KnowledgeArticleMinAggregateOutputType | null
    _max: KnowledgeArticleMaxAggregateOutputType | null
  }

  type GetKnowledgeArticleGroupByPayload<T extends KnowledgeArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeArticleGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeArticleGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeArticle"]>

  export type KnowledgeArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeArticle"]>

  export type KnowledgeArticleSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    categoryId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type KnowledgeArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }
  export type KnowledgeArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | KnowledgeCategoryDefaultArgs<ExtArgs>
  }

  export type $KnowledgeArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeArticle"
    objects: {
      category: Prisma.$KnowledgeCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      categoryId: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["knowledgeArticle"]>
    composites: {}
  }

  type KnowledgeArticleGetPayload<S extends boolean | null | undefined | KnowledgeArticleDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeArticlePayload, S>

  type KnowledgeArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeArticleCountAggregateInputType | true
    }

  export interface KnowledgeArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeArticle'], meta: { name: 'KnowledgeArticle' } }
    /**
     * Find zero or one KnowledgeArticle that matches the filter.
     * @param {KnowledgeArticleFindUniqueArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeArticleFindUniqueArgs>(args: SelectSubset<T, KnowledgeArticleFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeArticleFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindFirstArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeArticleFindFirstArgs>(args?: SelectSubset<T, KnowledgeArticleFindFirstArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindFirstOrThrowArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeArticles
     * const knowledgeArticles = await prisma.knowledgeArticle.findMany()
     * 
     * // Get first 10 KnowledgeArticles
     * const knowledgeArticles = await prisma.knowledgeArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeArticleWithIdOnly = await prisma.knowledgeArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeArticleFindManyArgs>(args?: SelectSubset<T, KnowledgeArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeArticle.
     * @param {KnowledgeArticleCreateArgs} args - Arguments to create a KnowledgeArticle.
     * @example
     * // Create one KnowledgeArticle
     * const KnowledgeArticle = await prisma.knowledgeArticle.create({
     *   data: {
     *     // ... data to create a KnowledgeArticle
     *   }
     * })
     * 
     */
    create<T extends KnowledgeArticleCreateArgs>(args: SelectSubset<T, KnowledgeArticleCreateArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeArticles.
     * @param {KnowledgeArticleCreateManyArgs} args - Arguments to create many KnowledgeArticles.
     * @example
     * // Create many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeArticleCreateManyArgs>(args?: SelectSubset<T, KnowledgeArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeArticles and returns the data saved in the database.
     * @param {KnowledgeArticleCreateManyAndReturnArgs} args - Arguments to create many KnowledgeArticles.
     * @example
     * // Create many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeArticles and only return the `id`
     * const knowledgeArticleWithIdOnly = await prisma.knowledgeArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KnowledgeArticle.
     * @param {KnowledgeArticleDeleteArgs} args - Arguments to delete one KnowledgeArticle.
     * @example
     * // Delete one KnowledgeArticle
     * const KnowledgeArticle = await prisma.knowledgeArticle.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeArticle
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeArticleDeleteArgs>(args: SelectSubset<T, KnowledgeArticleDeleteArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeArticle.
     * @param {KnowledgeArticleUpdateArgs} args - Arguments to update one KnowledgeArticle.
     * @example
     * // Update one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeArticleUpdateArgs>(args: SelectSubset<T, KnowledgeArticleUpdateArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeArticles.
     * @param {KnowledgeArticleDeleteManyArgs} args - Arguments to filter KnowledgeArticles to delete.
     * @example
     * // Delete a few KnowledgeArticles
     * const { count } = await prisma.knowledgeArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeArticleDeleteManyArgs>(args?: SelectSubset<T, KnowledgeArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeArticleUpdateManyArgs>(args: SelectSubset<T, KnowledgeArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeArticle.
     * @param {KnowledgeArticleUpsertArgs} args - Arguments to update or create a KnowledgeArticle.
     * @example
     * // Update or create a KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.upsert({
     *   create: {
     *     // ... data to create a KnowledgeArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeArticle we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeArticleUpsertArgs>(args: SelectSubset<T, KnowledgeArticleUpsertArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleCountArgs} args - Arguments to filter KnowledgeArticles to count.
     * @example
     * // Count the number of KnowledgeArticles
     * const count = await prisma.knowledgeArticle.count({
     *   where: {
     *     // ... the filter for the KnowledgeArticles we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeArticleCountArgs>(
      args?: Subset<T, KnowledgeArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeArticleAggregateArgs>(args: Subset<T, KnowledgeArticleAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeArticleAggregateType<T>>

    /**
     * Group by KnowledgeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeArticleGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeArticle model
   */
  readonly fields: KnowledgeArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends KnowledgeCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeCategoryDefaultArgs<ExtArgs>>): Prisma__KnowledgeCategoryClient<$Result.GetResult<Prisma.$KnowledgeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeArticle model
   */ 
  interface KnowledgeArticleFieldRefs {
    readonly id: FieldRef<"KnowledgeArticle", 'String'>
    readonly title: FieldRef<"KnowledgeArticle", 'String'>
    readonly content: FieldRef<"KnowledgeArticle", 'String'>
    readonly categoryId: FieldRef<"KnowledgeArticle", 'String'>
    readonly updatedAt: FieldRef<"KnowledgeArticle", 'DateTime'>
    readonly createdAt: FieldRef<"KnowledgeArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeArticle findUnique
   */
  export type KnowledgeArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle findUniqueOrThrow
   */
  export type KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle findFirst
   */
  export type KnowledgeArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeArticles.
     */
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle findFirstOrThrow
   */
  export type KnowledgeArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeArticles.
     */
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle findMany
   */
  export type KnowledgeArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticles to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle create
   */
  export type KnowledgeArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeArticle.
     */
    data: XOR<KnowledgeArticleCreateInput, KnowledgeArticleUncheckedCreateInput>
  }

  /**
   * KnowledgeArticle createMany
   */
  export type KnowledgeArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeArticles.
     */
    data: KnowledgeArticleCreateManyInput | KnowledgeArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeArticle createManyAndReturn
   */
  export type KnowledgeArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KnowledgeArticles.
     */
    data: KnowledgeArticleCreateManyInput | KnowledgeArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeArticle update
   */
  export type KnowledgeArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeArticle.
     */
    data: XOR<KnowledgeArticleUpdateInput, KnowledgeArticleUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeArticle to update.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle updateMany
   */
  export type KnowledgeArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeArticles.
     */
    data: XOR<KnowledgeArticleUpdateManyMutationInput, KnowledgeArticleUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeArticles to update
     */
    where?: KnowledgeArticleWhereInput
  }

  /**
   * KnowledgeArticle upsert
   */
  export type KnowledgeArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeArticle to update in case it exists.
     */
    where: KnowledgeArticleWhereUniqueInput
    /**
     * In case the KnowledgeArticle found by the `where` argument doesn't exist, create a new KnowledgeArticle with this data.
     */
    create: XOR<KnowledgeArticleCreateInput, KnowledgeArticleUncheckedCreateInput>
    /**
     * In case the KnowledgeArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeArticleUpdateInput, KnowledgeArticleUncheckedUpdateInput>
  }

  /**
   * KnowledgeArticle delete
   */
  export type KnowledgeArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeArticle to delete.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle deleteMany
   */
  export type KnowledgeArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeArticles to delete
     */
    where?: KnowledgeArticleWhereInput
  }

  /**
   * KnowledgeArticle without action
   */
  export type KnowledgeArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeArticleInclude<ExtArgs> | null
  }


  /**
   * Model PulseSurvey
   */

  export type AggregatePulseSurvey = {
    _count: PulseSurveyCountAggregateOutputType | null
    _min: PulseSurveyMinAggregateOutputType | null
    _max: PulseSurveyMaxAggregateOutputType | null
  }

  export type PulseSurveyMinAggregateOutputType = {
    id: string | null
    halfTermName: string | null
    status: string | null
    opensAt: Date | null
    closesAt: Date | null
    additionalQuestionKey: string | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type PulseSurveyMaxAggregateOutputType = {
    id: string | null
    halfTermName: string | null
    status: string | null
    opensAt: Date | null
    closesAt: Date | null
    additionalQuestionKey: string | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type PulseSurveyCountAggregateOutputType = {
    id: number
    halfTermName: number
    status: number
    opensAt: number
    closesAt: number
    additionalQuestionKey: number
    schoolId: number
    createdAt: number
    _all: number
  }


  export type PulseSurveyMinAggregateInputType = {
    id?: true
    halfTermName?: true
    status?: true
    opensAt?: true
    closesAt?: true
    additionalQuestionKey?: true
    schoolId?: true
    createdAt?: true
  }

  export type PulseSurveyMaxAggregateInputType = {
    id?: true
    halfTermName?: true
    status?: true
    opensAt?: true
    closesAt?: true
    additionalQuestionKey?: true
    schoolId?: true
    createdAt?: true
  }

  export type PulseSurveyCountAggregateInputType = {
    id?: true
    halfTermName?: true
    status?: true
    opensAt?: true
    closesAt?: true
    additionalQuestionKey?: true
    schoolId?: true
    createdAt?: true
    _all?: true
  }

  export type PulseSurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseSurvey to aggregate.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PulseSurveys
    **/
    _count?: true | PulseSurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PulseSurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PulseSurveyMaxAggregateInputType
  }

  export type GetPulseSurveyAggregateType<T extends PulseSurveyAggregateArgs> = {
        [P in keyof T & keyof AggregatePulseSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePulseSurvey[P]>
      : GetScalarType<T[P], AggregatePulseSurvey[P]>
  }




  export type PulseSurveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseSurveyWhereInput
    orderBy?: PulseSurveyOrderByWithAggregationInput | PulseSurveyOrderByWithAggregationInput[]
    by: PulseSurveyScalarFieldEnum[] | PulseSurveyScalarFieldEnum
    having?: PulseSurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PulseSurveyCountAggregateInputType | true
    _min?: PulseSurveyMinAggregateInputType
    _max?: PulseSurveyMaxAggregateInputType
  }

  export type PulseSurveyGroupByOutputType = {
    id: string
    halfTermName: string
    status: string
    opensAt: Date
    closesAt: Date
    additionalQuestionKey: string | null
    schoolId: string
    createdAt: Date
    _count: PulseSurveyCountAggregateOutputType | null
    _min: PulseSurveyMinAggregateOutputType | null
    _max: PulseSurveyMaxAggregateOutputType | null
  }

  type GetPulseSurveyGroupByPayload<T extends PulseSurveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PulseSurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PulseSurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PulseSurveyGroupByOutputType[P]>
            : GetScalarType<T[P], PulseSurveyGroupByOutputType[P]>
        }
      >
    >


  export type PulseSurveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    halfTermName?: boolean
    status?: boolean
    opensAt?: boolean
    closesAt?: boolean
    additionalQuestionKey?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    responses?: boolean | PulseSurvey$responsesArgs<ExtArgs>
    _count?: boolean | PulseSurveyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseSurvey"]>

  export type PulseSurveySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    halfTermName?: boolean
    status?: boolean
    opensAt?: boolean
    closesAt?: boolean
    additionalQuestionKey?: boolean
    schoolId?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseSurvey"]>

  export type PulseSurveySelectScalar = {
    id?: boolean
    halfTermName?: boolean
    status?: boolean
    opensAt?: boolean
    closesAt?: boolean
    additionalQuestionKey?: boolean
    schoolId?: boolean
    createdAt?: boolean
  }

  export type PulseSurveyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    responses?: boolean | PulseSurvey$responsesArgs<ExtArgs>
    _count?: boolean | PulseSurveyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PulseSurveyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $PulseSurveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PulseSurvey"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      responses: Prisma.$PulseResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      halfTermName: string
      status: string
      opensAt: Date
      closesAt: Date
      additionalQuestionKey: string | null
      schoolId: string
      createdAt: Date
    }, ExtArgs["result"]["pulseSurvey"]>
    composites: {}
  }

  type PulseSurveyGetPayload<S extends boolean | null | undefined | PulseSurveyDefaultArgs> = $Result.GetResult<Prisma.$PulseSurveyPayload, S>

  type PulseSurveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PulseSurveyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PulseSurveyCountAggregateInputType | true
    }

  export interface PulseSurveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PulseSurvey'], meta: { name: 'PulseSurvey' } }
    /**
     * Find zero or one PulseSurvey that matches the filter.
     * @param {PulseSurveyFindUniqueArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PulseSurveyFindUniqueArgs>(args: SelectSubset<T, PulseSurveyFindUniqueArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PulseSurvey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PulseSurveyFindUniqueOrThrowArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PulseSurveyFindUniqueOrThrowArgs>(args: SelectSubset<T, PulseSurveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PulseSurvey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyFindFirstArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PulseSurveyFindFirstArgs>(args?: SelectSubset<T, PulseSurveyFindFirstArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PulseSurvey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyFindFirstOrThrowArgs} args - Arguments to find a PulseSurvey
     * @example
     * // Get one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PulseSurveyFindFirstOrThrowArgs>(args?: SelectSubset<T, PulseSurveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PulseSurveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PulseSurveys
     * const pulseSurveys = await prisma.pulseSurvey.findMany()
     * 
     * // Get first 10 PulseSurveys
     * const pulseSurveys = await prisma.pulseSurvey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pulseSurveyWithIdOnly = await prisma.pulseSurvey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PulseSurveyFindManyArgs>(args?: SelectSubset<T, PulseSurveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PulseSurvey.
     * @param {PulseSurveyCreateArgs} args - Arguments to create a PulseSurvey.
     * @example
     * // Create one PulseSurvey
     * const PulseSurvey = await prisma.pulseSurvey.create({
     *   data: {
     *     // ... data to create a PulseSurvey
     *   }
     * })
     * 
     */
    create<T extends PulseSurveyCreateArgs>(args: SelectSubset<T, PulseSurveyCreateArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PulseSurveys.
     * @param {PulseSurveyCreateManyArgs} args - Arguments to create many PulseSurveys.
     * @example
     * // Create many PulseSurveys
     * const pulseSurvey = await prisma.pulseSurvey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PulseSurveyCreateManyArgs>(args?: SelectSubset<T, PulseSurveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PulseSurveys and returns the data saved in the database.
     * @param {PulseSurveyCreateManyAndReturnArgs} args - Arguments to create many PulseSurveys.
     * @example
     * // Create many PulseSurveys
     * const pulseSurvey = await prisma.pulseSurvey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PulseSurveys and only return the `id`
     * const pulseSurveyWithIdOnly = await prisma.pulseSurvey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PulseSurveyCreateManyAndReturnArgs>(args?: SelectSubset<T, PulseSurveyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PulseSurvey.
     * @param {PulseSurveyDeleteArgs} args - Arguments to delete one PulseSurvey.
     * @example
     * // Delete one PulseSurvey
     * const PulseSurvey = await prisma.pulseSurvey.delete({
     *   where: {
     *     // ... filter to delete one PulseSurvey
     *   }
     * })
     * 
     */
    delete<T extends PulseSurveyDeleteArgs>(args: SelectSubset<T, PulseSurveyDeleteArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PulseSurvey.
     * @param {PulseSurveyUpdateArgs} args - Arguments to update one PulseSurvey.
     * @example
     * // Update one PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PulseSurveyUpdateArgs>(args: SelectSubset<T, PulseSurveyUpdateArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PulseSurveys.
     * @param {PulseSurveyDeleteManyArgs} args - Arguments to filter PulseSurveys to delete.
     * @example
     * // Delete a few PulseSurveys
     * const { count } = await prisma.pulseSurvey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PulseSurveyDeleteManyArgs>(args?: SelectSubset<T, PulseSurveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PulseSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PulseSurveys
     * const pulseSurvey = await prisma.pulseSurvey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PulseSurveyUpdateManyArgs>(args: SelectSubset<T, PulseSurveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PulseSurvey.
     * @param {PulseSurveyUpsertArgs} args - Arguments to update or create a PulseSurvey.
     * @example
     * // Update or create a PulseSurvey
     * const pulseSurvey = await prisma.pulseSurvey.upsert({
     *   create: {
     *     // ... data to create a PulseSurvey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PulseSurvey we want to update
     *   }
     * })
     */
    upsert<T extends PulseSurveyUpsertArgs>(args: SelectSubset<T, PulseSurveyUpsertArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PulseSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyCountArgs} args - Arguments to filter PulseSurveys to count.
     * @example
     * // Count the number of PulseSurveys
     * const count = await prisma.pulseSurvey.count({
     *   where: {
     *     // ... the filter for the PulseSurveys we want to count
     *   }
     * })
    **/
    count<T extends PulseSurveyCountArgs>(
      args?: Subset<T, PulseSurveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PulseSurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PulseSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PulseSurveyAggregateArgs>(args: Subset<T, PulseSurveyAggregateArgs>): Prisma.PrismaPromise<GetPulseSurveyAggregateType<T>>

    /**
     * Group by PulseSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseSurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PulseSurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PulseSurveyGroupByArgs['orderBy'] }
        : { orderBy?: PulseSurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PulseSurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPulseSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PulseSurvey model
   */
  readonly fields: PulseSurveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PulseSurvey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PulseSurveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responses<T extends PulseSurvey$responsesArgs<ExtArgs> = {}>(args?: Subset<T, PulseSurvey$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PulseSurvey model
   */ 
  interface PulseSurveyFieldRefs {
    readonly id: FieldRef<"PulseSurvey", 'String'>
    readonly halfTermName: FieldRef<"PulseSurvey", 'String'>
    readonly status: FieldRef<"PulseSurvey", 'String'>
    readonly opensAt: FieldRef<"PulseSurvey", 'DateTime'>
    readonly closesAt: FieldRef<"PulseSurvey", 'DateTime'>
    readonly additionalQuestionKey: FieldRef<"PulseSurvey", 'String'>
    readonly schoolId: FieldRef<"PulseSurvey", 'String'>
    readonly createdAt: FieldRef<"PulseSurvey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PulseSurvey findUnique
   */
  export type PulseSurveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey findUniqueOrThrow
   */
  export type PulseSurveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey findFirst
   */
  export type PulseSurveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseSurveys.
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseSurveys.
     */
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * PulseSurvey findFirstOrThrow
   */
  export type PulseSurveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurvey to fetch.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseSurveys.
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseSurveys.
     */
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * PulseSurvey findMany
   */
  export type PulseSurveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter, which PulseSurveys to fetch.
     */
    where?: PulseSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseSurveys to fetch.
     */
    orderBy?: PulseSurveyOrderByWithRelationInput | PulseSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PulseSurveys.
     */
    cursor?: PulseSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseSurveys.
     */
    skip?: number
    distinct?: PulseSurveyScalarFieldEnum | PulseSurveyScalarFieldEnum[]
  }

  /**
   * PulseSurvey create
   */
  export type PulseSurveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * The data needed to create a PulseSurvey.
     */
    data: XOR<PulseSurveyCreateInput, PulseSurveyUncheckedCreateInput>
  }

  /**
   * PulseSurvey createMany
   */
  export type PulseSurveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PulseSurveys.
     */
    data: PulseSurveyCreateManyInput | PulseSurveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PulseSurvey createManyAndReturn
   */
  export type PulseSurveyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PulseSurveys.
     */
    data: PulseSurveyCreateManyInput | PulseSurveyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PulseSurvey update
   */
  export type PulseSurveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * The data needed to update a PulseSurvey.
     */
    data: XOR<PulseSurveyUpdateInput, PulseSurveyUncheckedUpdateInput>
    /**
     * Choose, which PulseSurvey to update.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey updateMany
   */
  export type PulseSurveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PulseSurveys.
     */
    data: XOR<PulseSurveyUpdateManyMutationInput, PulseSurveyUncheckedUpdateManyInput>
    /**
     * Filter which PulseSurveys to update
     */
    where?: PulseSurveyWhereInput
  }

  /**
   * PulseSurvey upsert
   */
  export type PulseSurveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * The filter to search for the PulseSurvey to update in case it exists.
     */
    where: PulseSurveyWhereUniqueInput
    /**
     * In case the PulseSurvey found by the `where` argument doesn't exist, create a new PulseSurvey with this data.
     */
    create: XOR<PulseSurveyCreateInput, PulseSurveyUncheckedCreateInput>
    /**
     * In case the PulseSurvey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PulseSurveyUpdateInput, PulseSurveyUncheckedUpdateInput>
  }

  /**
   * PulseSurvey delete
   */
  export type PulseSurveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
    /**
     * Filter which PulseSurvey to delete.
     */
    where: PulseSurveyWhereUniqueInput
  }

  /**
   * PulseSurvey deleteMany
   */
  export type PulseSurveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseSurveys to delete
     */
    where?: PulseSurveyWhereInput
  }

  /**
   * PulseSurvey.responses
   */
  export type PulseSurvey$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    where?: PulseResponseWhereInput
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    cursor?: PulseResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseSurvey without action
   */
  export type PulseSurveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseSurvey
     */
    select?: PulseSurveySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseSurveyInclude<ExtArgs> | null
  }


  /**
   * Model PulseResponse
   */

  export type AggregatePulseResponse = {
    _count: PulseResponseCountAggregateOutputType | null
    _min: PulseResponseMinAggregateOutputType | null
    _max: PulseResponseMaxAggregateOutputType | null
  }

  export type PulseResponseMinAggregateOutputType = {
    id: string | null
    pulseId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PulseResponseMaxAggregateOutputType = {
    id: string | null
    pulseId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PulseResponseCountAggregateOutputType = {
    id: number
    pulseId: number
    userId: number
    answers: number
    createdAt: number
    _all: number
  }


  export type PulseResponseMinAggregateInputType = {
    id?: true
    pulseId?: true
    userId?: true
    createdAt?: true
  }

  export type PulseResponseMaxAggregateInputType = {
    id?: true
    pulseId?: true
    userId?: true
    createdAt?: true
  }

  export type PulseResponseCountAggregateInputType = {
    id?: true
    pulseId?: true
    userId?: true
    answers?: true
    createdAt?: true
    _all?: true
  }

  export type PulseResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseResponse to aggregate.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PulseResponses
    **/
    _count?: true | PulseResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PulseResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PulseResponseMaxAggregateInputType
  }

  export type GetPulseResponseAggregateType<T extends PulseResponseAggregateArgs> = {
        [P in keyof T & keyof AggregatePulseResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePulseResponse[P]>
      : GetScalarType<T[P], AggregatePulseResponse[P]>
  }




  export type PulseResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PulseResponseWhereInput
    orderBy?: PulseResponseOrderByWithAggregationInput | PulseResponseOrderByWithAggregationInput[]
    by: PulseResponseScalarFieldEnum[] | PulseResponseScalarFieldEnum
    having?: PulseResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PulseResponseCountAggregateInputType | true
    _min?: PulseResponseMinAggregateInputType
    _max?: PulseResponseMaxAggregateInputType
  }

  export type PulseResponseGroupByOutputType = {
    id: string
    pulseId: string
    userId: string
    answers: JsonValue
    createdAt: Date
    _count: PulseResponseCountAggregateOutputType | null
    _min: PulseResponseMinAggregateOutputType | null
    _max: PulseResponseMaxAggregateOutputType | null
  }

  type GetPulseResponseGroupByPayload<T extends PulseResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PulseResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PulseResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PulseResponseGroupByOutputType[P]>
            : GetScalarType<T[P], PulseResponseGroupByOutputType[P]>
        }
      >
    >


  export type PulseResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pulseId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseResponse"]>

  export type PulseResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pulseId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pulseResponse"]>

  export type PulseResponseSelectScalar = {
    id?: boolean
    pulseId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
  }

  export type PulseResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PulseResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pulse?: boolean | PulseSurveyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PulseResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PulseResponse"
    objects: {
      pulse: Prisma.$PulseSurveyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pulseId: string
      userId: string
      answers: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["pulseResponse"]>
    composites: {}
  }

  type PulseResponseGetPayload<S extends boolean | null | undefined | PulseResponseDefaultArgs> = $Result.GetResult<Prisma.$PulseResponsePayload, S>

  type PulseResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PulseResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PulseResponseCountAggregateInputType | true
    }

  export interface PulseResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PulseResponse'], meta: { name: 'PulseResponse' } }
    /**
     * Find zero or one PulseResponse that matches the filter.
     * @param {PulseResponseFindUniqueArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PulseResponseFindUniqueArgs>(args: SelectSubset<T, PulseResponseFindUniqueArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PulseResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PulseResponseFindUniqueOrThrowArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PulseResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, PulseResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PulseResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseFindFirstArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PulseResponseFindFirstArgs>(args?: SelectSubset<T, PulseResponseFindFirstArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PulseResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseFindFirstOrThrowArgs} args - Arguments to find a PulseResponse
     * @example
     * // Get one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PulseResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, PulseResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PulseResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PulseResponses
     * const pulseResponses = await prisma.pulseResponse.findMany()
     * 
     * // Get first 10 PulseResponses
     * const pulseResponses = await prisma.pulseResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pulseResponseWithIdOnly = await prisma.pulseResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PulseResponseFindManyArgs>(args?: SelectSubset<T, PulseResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PulseResponse.
     * @param {PulseResponseCreateArgs} args - Arguments to create a PulseResponse.
     * @example
     * // Create one PulseResponse
     * const PulseResponse = await prisma.pulseResponse.create({
     *   data: {
     *     // ... data to create a PulseResponse
     *   }
     * })
     * 
     */
    create<T extends PulseResponseCreateArgs>(args: SelectSubset<T, PulseResponseCreateArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PulseResponses.
     * @param {PulseResponseCreateManyArgs} args - Arguments to create many PulseResponses.
     * @example
     * // Create many PulseResponses
     * const pulseResponse = await prisma.pulseResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PulseResponseCreateManyArgs>(args?: SelectSubset<T, PulseResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PulseResponses and returns the data saved in the database.
     * @param {PulseResponseCreateManyAndReturnArgs} args - Arguments to create many PulseResponses.
     * @example
     * // Create many PulseResponses
     * const pulseResponse = await prisma.pulseResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PulseResponses and only return the `id`
     * const pulseResponseWithIdOnly = await prisma.pulseResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PulseResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, PulseResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PulseResponse.
     * @param {PulseResponseDeleteArgs} args - Arguments to delete one PulseResponse.
     * @example
     * // Delete one PulseResponse
     * const PulseResponse = await prisma.pulseResponse.delete({
     *   where: {
     *     // ... filter to delete one PulseResponse
     *   }
     * })
     * 
     */
    delete<T extends PulseResponseDeleteArgs>(args: SelectSubset<T, PulseResponseDeleteArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PulseResponse.
     * @param {PulseResponseUpdateArgs} args - Arguments to update one PulseResponse.
     * @example
     * // Update one PulseResponse
     * const pulseResponse = await prisma.pulseResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PulseResponseUpdateArgs>(args: SelectSubset<T, PulseResponseUpdateArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PulseResponses.
     * @param {PulseResponseDeleteManyArgs} args - Arguments to filter PulseResponses to delete.
     * @example
     * // Delete a few PulseResponses
     * const { count } = await prisma.pulseResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PulseResponseDeleteManyArgs>(args?: SelectSubset<T, PulseResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PulseResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PulseResponses
     * const pulseResponse = await prisma.pulseResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PulseResponseUpdateManyArgs>(args: SelectSubset<T, PulseResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PulseResponse.
     * @param {PulseResponseUpsertArgs} args - Arguments to update or create a PulseResponse.
     * @example
     * // Update or create a PulseResponse
     * const pulseResponse = await prisma.pulseResponse.upsert({
     *   create: {
     *     // ... data to create a PulseResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PulseResponse we want to update
     *   }
     * })
     */
    upsert<T extends PulseResponseUpsertArgs>(args: SelectSubset<T, PulseResponseUpsertArgs<ExtArgs>>): Prisma__PulseResponseClient<$Result.GetResult<Prisma.$PulseResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PulseResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseCountArgs} args - Arguments to filter PulseResponses to count.
     * @example
     * // Count the number of PulseResponses
     * const count = await prisma.pulseResponse.count({
     *   where: {
     *     // ... the filter for the PulseResponses we want to count
     *   }
     * })
    **/
    count<T extends PulseResponseCountArgs>(
      args?: Subset<T, PulseResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PulseResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PulseResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PulseResponseAggregateArgs>(args: Subset<T, PulseResponseAggregateArgs>): Prisma.PrismaPromise<GetPulseResponseAggregateType<T>>

    /**
     * Group by PulseResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PulseResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PulseResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PulseResponseGroupByArgs['orderBy'] }
        : { orderBy?: PulseResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PulseResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPulseResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PulseResponse model
   */
  readonly fields: PulseResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PulseResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PulseResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pulse<T extends PulseSurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PulseSurveyDefaultArgs<ExtArgs>>): Prisma__PulseSurveyClient<$Result.GetResult<Prisma.$PulseSurveyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PulseResponse model
   */ 
  interface PulseResponseFieldRefs {
    readonly id: FieldRef<"PulseResponse", 'String'>
    readonly pulseId: FieldRef<"PulseResponse", 'String'>
    readonly userId: FieldRef<"PulseResponse", 'String'>
    readonly answers: FieldRef<"PulseResponse", 'Json'>
    readonly createdAt: FieldRef<"PulseResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PulseResponse findUnique
   */
  export type PulseResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse findUniqueOrThrow
   */
  export type PulseResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse findFirst
   */
  export type PulseResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseResponses.
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseResponses.
     */
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseResponse findFirstOrThrow
   */
  export type PulseResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponse to fetch.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PulseResponses.
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PulseResponses.
     */
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseResponse findMany
   */
  export type PulseResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter, which PulseResponses to fetch.
     */
    where?: PulseResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PulseResponses to fetch.
     */
    orderBy?: PulseResponseOrderByWithRelationInput | PulseResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PulseResponses.
     */
    cursor?: PulseResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PulseResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PulseResponses.
     */
    skip?: number
    distinct?: PulseResponseScalarFieldEnum | PulseResponseScalarFieldEnum[]
  }

  /**
   * PulseResponse create
   */
  export type PulseResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a PulseResponse.
     */
    data: XOR<PulseResponseCreateInput, PulseResponseUncheckedCreateInput>
  }

  /**
   * PulseResponse createMany
   */
  export type PulseResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PulseResponses.
     */
    data: PulseResponseCreateManyInput | PulseResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PulseResponse createManyAndReturn
   */
  export type PulseResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PulseResponses.
     */
    data: PulseResponseCreateManyInput | PulseResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PulseResponse update
   */
  export type PulseResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a PulseResponse.
     */
    data: XOR<PulseResponseUpdateInput, PulseResponseUncheckedUpdateInput>
    /**
     * Choose, which PulseResponse to update.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse updateMany
   */
  export type PulseResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PulseResponses.
     */
    data: XOR<PulseResponseUpdateManyMutationInput, PulseResponseUncheckedUpdateManyInput>
    /**
     * Filter which PulseResponses to update
     */
    where?: PulseResponseWhereInput
  }

  /**
   * PulseResponse upsert
   */
  export type PulseResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the PulseResponse to update in case it exists.
     */
    where: PulseResponseWhereUniqueInput
    /**
     * In case the PulseResponse found by the `where` argument doesn't exist, create a new PulseResponse with this data.
     */
    create: XOR<PulseResponseCreateInput, PulseResponseUncheckedCreateInput>
    /**
     * In case the PulseResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PulseResponseUpdateInput, PulseResponseUncheckedUpdateInput>
  }

  /**
   * PulseResponse delete
   */
  export type PulseResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
    /**
     * Filter which PulseResponse to delete.
     */
    where: PulseResponseWhereUniqueInput
  }

  /**
   * PulseResponse deleteMany
   */
  export type PulseResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PulseResponses to delete
     */
    where?: PulseResponseWhereInput
  }

  /**
   * PulseResponse without action
   */
  export type PulseResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PulseResponse
     */
    select?: PulseResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PulseResponseInclude<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type PolicySumAggregateOutputType = {
    fileSize: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fileUrl: string | null
    fileSize: number | null
    schoolId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fileUrl: string | null
    fileSize: number | null
    schoolId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fileUrl: number
    fileSize: number
    schoolId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    fileSize?: true
  }

  export type PolicySumAggregateInputType = {
    fileSize?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileSize?: true
    schoolId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileSize?: true
    schoolId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fileUrl?: true
    fileSize?: true
    schoolId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    fileUrl: string
    fileSize: number | null
    schoolId: string
    updatedAt: Date
    createdAt: Date
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    schoolId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    schoolId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    schoolId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type PolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type PolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      fileUrl: string
      fileSize: number | null
      schoolId: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policies and returns the data saved in the database.
     * @param {PolicyCreateManyAndReturnArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */ 
  interface PolicyFieldRefs {
    readonly id: FieldRef<"Policy", 'String'>
    readonly name: FieldRef<"Policy", 'String'>
    readonly description: FieldRef<"Policy", 'String'>
    readonly fileUrl: FieldRef<"Policy", 'String'>
    readonly fileSize: FieldRef<"Policy", 'Int'>
    readonly schoolId: FieldRef<"Policy", 'String'>
    readonly updatedAt: FieldRef<"Policy", 'DateTime'>
    readonly createdAt: FieldRef<"Policy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy createManyAndReturn
   */
  export type PolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
  }


  /**
   * Model FileFolder
   */

  export type AggregateFileFolder = {
    _count: FileFolderCountAggregateOutputType | null
    _avg: FileFolderAvgAggregateOutputType | null
    _sum: FileFolderSumAggregateOutputType | null
    _min: FileFolderMinAggregateOutputType | null
    _max: FileFolderMaxAggregateOutputType | null
  }

  export type FileFolderAvgAggregateOutputType = {
    order: number | null
  }

  export type FileFolderSumAggregateOutputType = {
    order: number | null
  }

  export type FileFolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    schoolId: string | null
    order: number | null
    createdAt: Date | null
  }

  export type FileFolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    schoolId: string | null
    order: number | null
    createdAt: Date | null
  }

  export type FileFolderCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    color: number
    parentId: number
    schoolId: number
    order: number
    createdAt: number
    _all: number
  }


  export type FileFolderAvgAggregateInputType = {
    order?: true
  }

  export type FileFolderSumAggregateInputType = {
    order?: true
  }

  export type FileFolderMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    parentId?: true
    schoolId?: true
    order?: true
    createdAt?: true
  }

  export type FileFolderMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    parentId?: true
    schoolId?: true
    order?: true
    createdAt?: true
  }

  export type FileFolderCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    parentId?: true
    schoolId?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type FileFolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileFolder to aggregate.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileFolders
    **/
    _count?: true | FileFolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileFolderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileFolderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileFolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileFolderMaxAggregateInputType
  }

  export type GetFileFolderAggregateType<T extends FileFolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFileFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileFolder[P]>
      : GetScalarType<T[P], AggregateFileFolder[P]>
  }




  export type FileFolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithAggregationInput | FileFolderOrderByWithAggregationInput[]
    by: FileFolderScalarFieldEnum[] | FileFolderScalarFieldEnum
    having?: FileFolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileFolderCountAggregateInputType | true
    _avg?: FileFolderAvgAggregateInputType
    _sum?: FileFolderSumAggregateInputType
    _min?: FileFolderMinAggregateInputType
    _max?: FileFolderMaxAggregateInputType
  }

  export type FileFolderGroupByOutputType = {
    id: string
    name: string
    icon: string | null
    color: string | null
    parentId: string | null
    schoolId: string
    order: number
    createdAt: Date
    _count: FileFolderCountAggregateOutputType | null
    _avg: FileFolderAvgAggregateOutputType | null
    _sum: FileFolderSumAggregateOutputType | null
    _min: FileFolderMinAggregateOutputType | null
    _max: FileFolderMaxAggregateOutputType | null
  }

  type GetFileFolderGroupByPayload<T extends FileFolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileFolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileFolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileFolderGroupByOutputType[P]>
            : GetScalarType<T[P], FileFolderGroupByOutputType[P]>
        }
      >
    >


  export type FileFolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    schoolId?: boolean
    order?: boolean
    createdAt?: boolean
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    children?: boolean | FileFolder$childrenArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    files?: boolean | FileFolder$filesArgs<ExtArgs>
    _count?: boolean | FileFolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileFolder"]>

  export type FileFolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    schoolId?: boolean
    order?: boolean
    createdAt?: boolean
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileFolder"]>

  export type FileFolderSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    schoolId?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type FileFolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    children?: boolean | FileFolder$childrenArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    files?: boolean | FileFolder$filesArgs<ExtArgs>
    _count?: boolean | FileFolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileFolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | FileFolder$parentArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $FileFolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileFolder"
    objects: {
      parent: Prisma.$FileFolderPayload<ExtArgs> | null
      children: Prisma.$FileFolderPayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs>
      files: Prisma.$SchoolFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string | null
      color: string | null
      parentId: string | null
      schoolId: string
      order: number
      createdAt: Date
    }, ExtArgs["result"]["fileFolder"]>
    composites: {}
  }

  type FileFolderGetPayload<S extends boolean | null | undefined | FileFolderDefaultArgs> = $Result.GetResult<Prisma.$FileFolderPayload, S>

  type FileFolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileFolderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileFolderCountAggregateInputType | true
    }

  export interface FileFolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileFolder'], meta: { name: 'FileFolder' } }
    /**
     * Find zero or one FileFolder that matches the filter.
     * @param {FileFolderFindUniqueArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFolderFindUniqueArgs>(args: SelectSubset<T, FileFolderFindUniqueArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FileFolder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileFolderFindUniqueOrThrowArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FileFolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindFirstArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFolderFindFirstArgs>(args?: SelectSubset<T, FileFolderFindFirstArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FileFolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindFirstOrThrowArgs} args - Arguments to find a FileFolder
     * @example
     * // Get one FileFolder
     * const fileFolder = await prisma.fileFolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FileFolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileFolders
     * const fileFolders = await prisma.fileFolder.findMany()
     * 
     * // Get first 10 FileFolders
     * const fileFolders = await prisma.fileFolder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileFolderWithIdOnly = await prisma.fileFolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFolderFindManyArgs>(args?: SelectSubset<T, FileFolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FileFolder.
     * @param {FileFolderCreateArgs} args - Arguments to create a FileFolder.
     * @example
     * // Create one FileFolder
     * const FileFolder = await prisma.fileFolder.create({
     *   data: {
     *     // ... data to create a FileFolder
     *   }
     * })
     * 
     */
    create<T extends FileFolderCreateArgs>(args: SelectSubset<T, FileFolderCreateArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FileFolders.
     * @param {FileFolderCreateManyArgs} args - Arguments to create many FileFolders.
     * @example
     * // Create many FileFolders
     * const fileFolder = await prisma.fileFolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileFolderCreateManyArgs>(args?: SelectSubset<T, FileFolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileFolders and returns the data saved in the database.
     * @param {FileFolderCreateManyAndReturnArgs} args - Arguments to create many FileFolders.
     * @example
     * // Create many FileFolders
     * const fileFolder = await prisma.fileFolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileFolders and only return the `id`
     * const fileFolderWithIdOnly = await prisma.fileFolder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileFolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FileFolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FileFolder.
     * @param {FileFolderDeleteArgs} args - Arguments to delete one FileFolder.
     * @example
     * // Delete one FileFolder
     * const FileFolder = await prisma.fileFolder.delete({
     *   where: {
     *     // ... filter to delete one FileFolder
     *   }
     * })
     * 
     */
    delete<T extends FileFolderDeleteArgs>(args: SelectSubset<T, FileFolderDeleteArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FileFolder.
     * @param {FileFolderUpdateArgs} args - Arguments to update one FileFolder.
     * @example
     * // Update one FileFolder
     * const fileFolder = await prisma.fileFolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileFolderUpdateArgs>(args: SelectSubset<T, FileFolderUpdateArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FileFolders.
     * @param {FileFolderDeleteManyArgs} args - Arguments to filter FileFolders to delete.
     * @example
     * // Delete a few FileFolders
     * const { count } = await prisma.fileFolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileFolderDeleteManyArgs>(args?: SelectSubset<T, FileFolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileFolders
     * const fileFolder = await prisma.fileFolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileFolderUpdateManyArgs>(args: SelectSubset<T, FileFolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileFolder.
     * @param {FileFolderUpsertArgs} args - Arguments to update or create a FileFolder.
     * @example
     * // Update or create a FileFolder
     * const fileFolder = await prisma.fileFolder.upsert({
     *   create: {
     *     // ... data to create a FileFolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileFolder we want to update
     *   }
     * })
     */
    upsert<T extends FileFolderUpsertArgs>(args: SelectSubset<T, FileFolderUpsertArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FileFolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderCountArgs} args - Arguments to filter FileFolders to count.
     * @example
     * // Count the number of FileFolders
     * const count = await prisma.fileFolder.count({
     *   where: {
     *     // ... the filter for the FileFolders we want to count
     *   }
     * })
    **/
    count<T extends FileFolderCountArgs>(
      args?: Subset<T, FileFolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileFolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileFolderAggregateArgs>(args: Subset<T, FileFolderAggregateArgs>): Prisma.PrismaPromise<GetFileFolderAggregateType<T>>

    /**
     * Group by FileFolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileFolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileFolderGroupByArgs['orderBy'] }
        : { orderBy?: FileFolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileFolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileFolder model
   */
  readonly fields: FileFolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileFolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileFolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends FileFolder$parentArgs<ExtArgs> = {}>(args?: Subset<T, FileFolder$parentArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends FileFolder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, FileFolder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findMany"> | Null>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    files<T extends FileFolder$filesArgs<ExtArgs> = {}>(args?: Subset<T, FileFolder$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileFolder model
   */ 
  interface FileFolderFieldRefs {
    readonly id: FieldRef<"FileFolder", 'String'>
    readonly name: FieldRef<"FileFolder", 'String'>
    readonly icon: FieldRef<"FileFolder", 'String'>
    readonly color: FieldRef<"FileFolder", 'String'>
    readonly parentId: FieldRef<"FileFolder", 'String'>
    readonly schoolId: FieldRef<"FileFolder", 'String'>
    readonly order: FieldRef<"FileFolder", 'Int'>
    readonly createdAt: FieldRef<"FileFolder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileFolder findUnique
   */
  export type FileFolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder findUniqueOrThrow
   */
  export type FileFolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder findFirst
   */
  export type FileFolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileFolders.
     */
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder findFirstOrThrow
   */
  export type FileFolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolder to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileFolders.
     */
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder findMany
   */
  export type FileFolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter, which FileFolders to fetch.
     */
    where?: FileFolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileFolders to fetch.
     */
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileFolders.
     */
    cursor?: FileFolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileFolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileFolders.
     */
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder create
   */
  export type FileFolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The data needed to create a FileFolder.
     */
    data: XOR<FileFolderCreateInput, FileFolderUncheckedCreateInput>
  }

  /**
   * FileFolder createMany
   */
  export type FileFolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileFolders.
     */
    data: FileFolderCreateManyInput | FileFolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileFolder createManyAndReturn
   */
  export type FileFolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FileFolders.
     */
    data: FileFolderCreateManyInput | FileFolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileFolder update
   */
  export type FileFolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The data needed to update a FileFolder.
     */
    data: XOR<FileFolderUpdateInput, FileFolderUncheckedUpdateInput>
    /**
     * Choose, which FileFolder to update.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder updateMany
   */
  export type FileFolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileFolders.
     */
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyInput>
    /**
     * Filter which FileFolders to update
     */
    where?: FileFolderWhereInput
  }

  /**
   * FileFolder upsert
   */
  export type FileFolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * The filter to search for the FileFolder to update in case it exists.
     */
    where: FileFolderWhereUniqueInput
    /**
     * In case the FileFolder found by the `where` argument doesn't exist, create a new FileFolder with this data.
     */
    create: XOR<FileFolderCreateInput, FileFolderUncheckedCreateInput>
    /**
     * In case the FileFolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileFolderUpdateInput, FileFolderUncheckedUpdateInput>
  }

  /**
   * FileFolder delete
   */
  export type FileFolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    /**
     * Filter which FileFolder to delete.
     */
    where: FileFolderWhereUniqueInput
  }

  /**
   * FileFolder deleteMany
   */
  export type FileFolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileFolders to delete
     */
    where?: FileFolderWhereInput
  }

  /**
   * FileFolder.parent
   */
  export type FileFolder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
  }

  /**
   * FileFolder.children
   */
  export type FileFolder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
    orderBy?: FileFolderOrderByWithRelationInput | FileFolderOrderByWithRelationInput[]
    cursor?: FileFolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileFolderScalarFieldEnum | FileFolderScalarFieldEnum[]
  }

  /**
   * FileFolder.files
   */
  export type FileFolder$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    where?: SchoolFileWhereInput
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    cursor?: SchoolFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * FileFolder without action
   */
  export type FileFolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
  }


  /**
   * Model SchoolFile
   */

  export type AggregateSchoolFile = {
    _count: SchoolFileCountAggregateOutputType | null
    _avg: SchoolFileAvgAggregateOutputType | null
    _sum: SchoolFileSumAggregateOutputType | null
    _min: SchoolFileMinAggregateOutputType | null
    _max: SchoolFileMaxAggregateOutputType | null
  }

  export type SchoolFileAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type SchoolFileSumAggregateOutputType = {
    fileSize: number | null
  }

  export type SchoolFileMinAggregateOutputType = {
    id: string | null
    name: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    folderId: string | null
    schoolId: string | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolFileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    folderId: string | null
    schoolId: string | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolFileCountAggregateOutputType = {
    id: number
    name: number
    fileName: number
    fileUrl: number
    fileType: number
    fileSize: number
    folderId: number
    schoolId: number
    uploadedAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolFileAvgAggregateInputType = {
    fileSize?: true
  }

  export type SchoolFileSumAggregateInputType = {
    fileSize?: true
  }

  export type SchoolFileMinAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    folderId?: true
    schoolId?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type SchoolFileMaxAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    folderId?: true
    schoolId?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type SchoolFileCountAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    folderId?: true
    schoolId?: true
    uploadedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolFile to aggregate.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolFiles
    **/
    _count?: true | SchoolFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolFileMaxAggregateInputType
  }

  export type GetSchoolFileAggregateType<T extends SchoolFileAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolFile[P]>
      : GetScalarType<T[P], AggregateSchoolFile[P]>
  }




  export type SchoolFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolFileWhereInput
    orderBy?: SchoolFileOrderByWithAggregationInput | SchoolFileOrderByWithAggregationInput[]
    by: SchoolFileScalarFieldEnum[] | SchoolFileScalarFieldEnum
    having?: SchoolFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolFileCountAggregateInputType | true
    _avg?: SchoolFileAvgAggregateInputType
    _sum?: SchoolFileSumAggregateInputType
    _min?: SchoolFileMinAggregateInputType
    _max?: SchoolFileMaxAggregateInputType
  }

  export type SchoolFileGroupByOutputType = {
    id: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId: string | null
    schoolId: string
    uploadedAt: Date
    updatedAt: Date
    _count: SchoolFileCountAggregateOutputType | null
    _avg: SchoolFileAvgAggregateOutputType | null
    _sum: SchoolFileSumAggregateOutputType | null
    _min: SchoolFileMinAggregateOutputType | null
    _max: SchoolFileMaxAggregateOutputType | null
  }

  type GetSchoolFileGroupByPayload<T extends SchoolFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolFileGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolFileGroupByOutputType[P]>
        }
      >
    >


  export type SchoolFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    folderId?: boolean
    schoolId?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolFile"]>

  export type SchoolFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    folderId?: boolean
    schoolId?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolFile"]>

  export type SchoolFileSelectScalar = {
    id?: boolean
    name?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    folderId?: boolean
    schoolId?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | SchoolFile$folderArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolFile"
    objects: {
      folder: Prisma.$FileFolderPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      fileName: string
      fileUrl: string
      fileType: string
      fileSize: number
      folderId: string | null
      schoolId: string
      uploadedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolFile"]>
    composites: {}
  }

  type SchoolFileGetPayload<S extends boolean | null | undefined | SchoolFileDefaultArgs> = $Result.GetResult<Prisma.$SchoolFilePayload, S>

  type SchoolFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolFileCountAggregateInputType | true
    }

  export interface SchoolFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolFile'], meta: { name: 'SchoolFile' } }
    /**
     * Find zero or one SchoolFile that matches the filter.
     * @param {SchoolFileFindUniqueArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFileFindUniqueArgs>(args: SelectSubset<T, SchoolFileFindUniqueArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolFileFindUniqueOrThrowArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFileFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileFindFirstArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFileFindFirstArgs>(args?: SelectSubset<T, SchoolFileFindFirstArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileFindFirstOrThrowArgs} args - Arguments to find a SchoolFile
     * @example
     * // Get one SchoolFile
     * const schoolFile = await prisma.schoolFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFileFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolFiles
     * const schoolFiles = await prisma.schoolFile.findMany()
     * 
     * // Get first 10 SchoolFiles
     * const schoolFiles = await prisma.schoolFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolFileWithIdOnly = await prisma.schoolFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFileFindManyArgs>(args?: SelectSubset<T, SchoolFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolFile.
     * @param {SchoolFileCreateArgs} args - Arguments to create a SchoolFile.
     * @example
     * // Create one SchoolFile
     * const SchoolFile = await prisma.schoolFile.create({
     *   data: {
     *     // ... data to create a SchoolFile
     *   }
     * })
     * 
     */
    create<T extends SchoolFileCreateArgs>(args: SelectSubset<T, SchoolFileCreateArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolFiles.
     * @param {SchoolFileCreateManyArgs} args - Arguments to create many SchoolFiles.
     * @example
     * // Create many SchoolFiles
     * const schoolFile = await prisma.schoolFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolFileCreateManyArgs>(args?: SelectSubset<T, SchoolFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolFiles and returns the data saved in the database.
     * @param {SchoolFileCreateManyAndReturnArgs} args - Arguments to create many SchoolFiles.
     * @example
     * // Create many SchoolFiles
     * const schoolFile = await prisma.schoolFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolFiles and only return the `id`
     * const schoolFileWithIdOnly = await prisma.schoolFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolFileCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolFile.
     * @param {SchoolFileDeleteArgs} args - Arguments to delete one SchoolFile.
     * @example
     * // Delete one SchoolFile
     * const SchoolFile = await prisma.schoolFile.delete({
     *   where: {
     *     // ... filter to delete one SchoolFile
     *   }
     * })
     * 
     */
    delete<T extends SchoolFileDeleteArgs>(args: SelectSubset<T, SchoolFileDeleteArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolFile.
     * @param {SchoolFileUpdateArgs} args - Arguments to update one SchoolFile.
     * @example
     * // Update one SchoolFile
     * const schoolFile = await prisma.schoolFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolFileUpdateArgs>(args: SelectSubset<T, SchoolFileUpdateArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolFiles.
     * @param {SchoolFileDeleteManyArgs} args - Arguments to filter SchoolFiles to delete.
     * @example
     * // Delete a few SchoolFiles
     * const { count } = await prisma.schoolFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolFileDeleteManyArgs>(args?: SelectSubset<T, SchoolFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolFiles
     * const schoolFile = await prisma.schoolFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolFileUpdateManyArgs>(args: SelectSubset<T, SchoolFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolFile.
     * @param {SchoolFileUpsertArgs} args - Arguments to update or create a SchoolFile.
     * @example
     * // Update or create a SchoolFile
     * const schoolFile = await prisma.schoolFile.upsert({
     *   create: {
     *     // ... data to create a SchoolFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolFile we want to update
     *   }
     * })
     */
    upsert<T extends SchoolFileUpsertArgs>(args: SelectSubset<T, SchoolFileUpsertArgs<ExtArgs>>): Prisma__SchoolFileClient<$Result.GetResult<Prisma.$SchoolFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileCountArgs} args - Arguments to filter SchoolFiles to count.
     * @example
     * // Count the number of SchoolFiles
     * const count = await prisma.schoolFile.count({
     *   where: {
     *     // ... the filter for the SchoolFiles we want to count
     *   }
     * })
    **/
    count<T extends SchoolFileCountArgs>(
      args?: Subset<T, SchoolFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolFileAggregateArgs>(args: Subset<T, SchoolFileAggregateArgs>): Prisma.PrismaPromise<GetSchoolFileAggregateType<T>>

    /**
     * Group by SchoolFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolFileGroupByArgs['orderBy'] }
        : { orderBy?: SchoolFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolFile model
   */
  readonly fields: SchoolFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    folder<T extends SchoolFile$folderArgs<ExtArgs> = {}>(args?: Subset<T, SchoolFile$folderArgs<ExtArgs>>): Prisma__FileFolderClient<$Result.GetResult<Prisma.$FileFolderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolFile model
   */ 
  interface SchoolFileFieldRefs {
    readonly id: FieldRef<"SchoolFile", 'String'>
    readonly name: FieldRef<"SchoolFile", 'String'>
    readonly fileName: FieldRef<"SchoolFile", 'String'>
    readonly fileUrl: FieldRef<"SchoolFile", 'String'>
    readonly fileType: FieldRef<"SchoolFile", 'String'>
    readonly fileSize: FieldRef<"SchoolFile", 'Int'>
    readonly folderId: FieldRef<"SchoolFile", 'String'>
    readonly schoolId: FieldRef<"SchoolFile", 'String'>
    readonly uploadedAt: FieldRef<"SchoolFile", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolFile findUnique
   */
  export type SchoolFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile findUniqueOrThrow
   */
  export type SchoolFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile findFirst
   */
  export type SchoolFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolFiles.
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolFiles.
     */
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * SchoolFile findFirstOrThrow
   */
  export type SchoolFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFile to fetch.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolFiles.
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolFiles.
     */
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * SchoolFile findMany
   */
  export type SchoolFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter, which SchoolFiles to fetch.
     */
    where?: SchoolFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolFiles to fetch.
     */
    orderBy?: SchoolFileOrderByWithRelationInput | SchoolFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolFiles.
     */
    cursor?: SchoolFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolFiles.
     */
    skip?: number
    distinct?: SchoolFileScalarFieldEnum | SchoolFileScalarFieldEnum[]
  }

  /**
   * SchoolFile create
   */
  export type SchoolFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolFile.
     */
    data: XOR<SchoolFileCreateInput, SchoolFileUncheckedCreateInput>
  }

  /**
   * SchoolFile createMany
   */
  export type SchoolFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolFiles.
     */
    data: SchoolFileCreateManyInput | SchoolFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolFile createManyAndReturn
   */
  export type SchoolFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolFiles.
     */
    data: SchoolFileCreateManyInput | SchoolFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolFile update
   */
  export type SchoolFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolFile.
     */
    data: XOR<SchoolFileUpdateInput, SchoolFileUncheckedUpdateInput>
    /**
     * Choose, which SchoolFile to update.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile updateMany
   */
  export type SchoolFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolFiles.
     */
    data: XOR<SchoolFileUpdateManyMutationInput, SchoolFileUncheckedUpdateManyInput>
    /**
     * Filter which SchoolFiles to update
     */
    where?: SchoolFileWhereInput
  }

  /**
   * SchoolFile upsert
   */
  export type SchoolFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolFile to update in case it exists.
     */
    where: SchoolFileWhereUniqueInput
    /**
     * In case the SchoolFile found by the `where` argument doesn't exist, create a new SchoolFile with this data.
     */
    create: XOR<SchoolFileCreateInput, SchoolFileUncheckedCreateInput>
    /**
     * In case the SchoolFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolFileUpdateInput, SchoolFileUncheckedUpdateInput>
  }

  /**
   * SchoolFile delete
   */
  export type SchoolFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
    /**
     * Filter which SchoolFile to delete.
     */
    where: SchoolFileWhereUniqueInput
  }

  /**
   * SchoolFile deleteMany
   */
  export type SchoolFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolFiles to delete
     */
    where?: SchoolFileWhereInput
  }

  /**
   * SchoolFile.folder
   */
  export type SchoolFile$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileFolder
     */
    select?: FileFolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileFolderInclude<ExtArgs> | null
    where?: FileFolderWhereInput
  }

  /**
   * SchoolFile without action
   */
  export type SchoolFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolFile
     */
    select?: SchoolFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolFileInclude<ExtArgs> | null
  }


  /**
   * Model Form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    targetClass: string | null
    schoolId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    targetClass: string | null
    schoolId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    status: number
    fields: number
    targetClass: number
    classIds: number
    yearGroupIds: number
    schoolId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    targetClass?: true
    schoolId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    targetClass?: true
    schoolId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    fields?: true
    targetClass?: true
    classIds?: true
    yearGroupIds?: true
    schoolId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form to aggregate.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
    orderBy?: FormOrderByWithAggregationInput | FormOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: string
    status: string
    fields: JsonValue
    targetClass: string
    classIds: JsonValue
    yearGroupIds: JsonValue
    schoolId: string
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    fields?: boolean
    targetClass?: boolean
    classIds?: boolean
    yearGroupIds?: boolean
    schoolId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    message?: boolean | Form$messageArgs<ExtArgs>
    responses?: boolean | Form$responsesArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    fields?: boolean
    targetClass?: boolean
    classIds?: boolean
    yearGroupIds?: boolean
    schoolId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    fields?: boolean
    targetClass?: boolean
    classIds?: boolean
    yearGroupIds?: boolean
    schoolId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    message?: boolean | Form$messageArgs<ExtArgs>
    responses?: boolean | Form$responsesArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $FormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      message: Prisma.$MessagePayload<ExtArgs> | null
      responses: Prisma.$FormResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: string
      status: string
      fields: Prisma.JsonValue
      targetClass: string
      classIds: Prisma.JsonValue
      yearGroupIds: Prisma.JsonValue
      schoolId: string
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["form"]>
    composites: {}
  }

  type FormGetPayload<S extends boolean | null | undefined | FormDefaultArgs> = $Result.GetResult<Prisma.$FormPayload, S>

  type FormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormCountAggregateInputType | true
    }

  export interface FormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form'], meta: { name: 'Form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFindUniqueArgs>(args: SelectSubset<T, FormFindUniqueArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Form that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFindFirstArgs>(args?: SelectSubset<T, FormFindFirstArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFindManyArgs>(args?: SelectSubset<T, FormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
     */
    create<T extends FormCreateArgs>(args: SelectSubset<T, FormCreateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Forms.
     * @param {FormCreateManyArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormCreateManyArgs>(args?: SelectSubset<T, FormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Forms and returns the data saved in the database.
     * @param {FormCreateManyAndReturnArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Forms and only return the `id`
     * const formWithIdOnly = await prisma.form.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormCreateManyAndReturnArgs>(args?: SelectSubset<T, FormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
     */
    delete<T extends FormDeleteArgs>(args: SelectSubset<T, FormDeleteArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormUpdateArgs>(args: SelectSubset<T, FormUpdateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormDeleteManyArgs>(args?: SelectSubset<T, FormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormUpdateManyArgs>(args: SelectSubset<T, FormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
     */
    upsert<T extends FormUpsertArgs>(args: SelectSubset<T, FormUpsertArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form model
   */
  readonly fields: FormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    message<T extends Form$messageArgs<ExtArgs> = {}>(args?: Subset<T, Form$messageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    responses<T extends Form$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Form$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Form model
   */ 
  interface FormFieldRefs {
    readonly id: FieldRef<"Form", 'String'>
    readonly title: FieldRef<"Form", 'String'>
    readonly description: FieldRef<"Form", 'String'>
    readonly type: FieldRef<"Form", 'String'>
    readonly status: FieldRef<"Form", 'String'>
    readonly fields: FieldRef<"Form", 'Json'>
    readonly targetClass: FieldRef<"Form", 'String'>
    readonly classIds: FieldRef<"Form", 'Json'>
    readonly yearGroupIds: FieldRef<"Form", 'Json'>
    readonly schoolId: FieldRef<"Form", 'String'>
    readonly expiresAt: FieldRef<"Form", 'DateTime'>
    readonly createdAt: FieldRef<"Form", 'DateTime'>
    readonly updatedAt: FieldRef<"Form", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Form findUnique
   */
  export type FormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form findFirst
   */
  export type FormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form findMany
   */
  export type FormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Form create
   */
  export type FormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to create a Form.
     */
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
  }

  /**
   * Form createMany
   */
  export type FormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form createManyAndReturn
   */
  export type FormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Form update
   */
  export type FormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to update a Form.
     */
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
  }

  /**
   * Form upsert
   */
  export type FormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The filter to search for the Form to update in case it exists.
     */
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     */
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
  }

  /**
   * Form delete
   */
  export type FormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter which Form to delete.
     */
    where: FormWhereUniqueInput
  }

  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormWhereInput
  }

  /**
   * Form.message
   */
  export type Form$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Form.responses
   */
  export type Form$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    cursor?: FormResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * Form without action
   */
  export type FormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
  }


  /**
   * Model FormResponse
   */

  export type AggregateFormResponse = {
    _count: FormResponseCountAggregateOutputType | null
    _min: FormResponseMinAggregateOutputType | null
    _max: FormResponseMaxAggregateOutputType | null
  }

  export type FormResponseMinAggregateOutputType = {
    id: string | null
    formId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type FormResponseMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type FormResponseCountAggregateOutputType = {
    id: number
    formId: number
    userId: number
    answers: number
    createdAt: number
    _all: number
  }


  export type FormResponseMinAggregateInputType = {
    id?: true
    formId?: true
    userId?: true
    createdAt?: true
  }

  export type FormResponseMaxAggregateInputType = {
    id?: true
    formId?: true
    userId?: true
    createdAt?: true
  }

  export type FormResponseCountAggregateInputType = {
    id?: true
    formId?: true
    userId?: true
    answers?: true
    createdAt?: true
    _all?: true
  }

  export type FormResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResponse to aggregate.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormResponses
    **/
    _count?: true | FormResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormResponseMaxAggregateInputType
  }

  export type GetFormResponseAggregateType<T extends FormResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateFormResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormResponse[P]>
      : GetScalarType<T[P], AggregateFormResponse[P]>
  }




  export type FormResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithAggregationInput | FormResponseOrderByWithAggregationInput[]
    by: FormResponseScalarFieldEnum[] | FormResponseScalarFieldEnum
    having?: FormResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormResponseCountAggregateInputType | true
    _min?: FormResponseMinAggregateInputType
    _max?: FormResponseMaxAggregateInputType
  }

  export type FormResponseGroupByOutputType = {
    id: string
    formId: string
    userId: string
    answers: JsonValue
    createdAt: Date
    _count: FormResponseCountAggregateOutputType | null
    _min: FormResponseMinAggregateOutputType | null
    _max: FormResponseMaxAggregateOutputType | null
  }

  type GetFormResponseGroupByPayload<T extends FormResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormResponseGroupByOutputType[P]>
            : GetScalarType<T[P], FormResponseGroupByOutputType[P]>
        }
      >
    >


  export type FormResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formResponse"]>

  export type FormResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formResponse"]>

  export type FormResponseSelectScalar = {
    id?: boolean
    formId?: boolean
    userId?: boolean
    answers?: boolean
    createdAt?: boolean
  }

  export type FormResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FormResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FormResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormResponse"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      userId: string
      answers: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["formResponse"]>
    composites: {}
  }

  type FormResponseGetPayload<S extends boolean | null | undefined | FormResponseDefaultArgs> = $Result.GetResult<Prisma.$FormResponsePayload, S>

  type FormResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormResponseCountAggregateInputType | true
    }

  export interface FormResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormResponse'], meta: { name: 'FormResponse' } }
    /**
     * Find zero or one FormResponse that matches the filter.
     * @param {FormResponseFindUniqueArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormResponseFindUniqueArgs>(args: SelectSubset<T, FormResponseFindUniqueArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FormResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FormResponseFindUniqueOrThrowArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, FormResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FormResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindFirstArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormResponseFindFirstArgs>(args?: SelectSubset<T, FormResponseFindFirstArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FormResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindFirstOrThrowArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, FormResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FormResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormResponses
     * const formResponses = await prisma.formResponse.findMany()
     * 
     * // Get first 10 FormResponses
     * const formResponses = await prisma.formResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formResponseWithIdOnly = await prisma.formResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormResponseFindManyArgs>(args?: SelectSubset<T, FormResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FormResponse.
     * @param {FormResponseCreateArgs} args - Arguments to create a FormResponse.
     * @example
     * // Create one FormResponse
     * const FormResponse = await prisma.formResponse.create({
     *   data: {
     *     // ... data to create a FormResponse
     *   }
     * })
     * 
     */
    create<T extends FormResponseCreateArgs>(args: SelectSubset<T, FormResponseCreateArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FormResponses.
     * @param {FormResponseCreateManyArgs} args - Arguments to create many FormResponses.
     * @example
     * // Create many FormResponses
     * const formResponse = await prisma.formResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormResponseCreateManyArgs>(args?: SelectSubset<T, FormResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormResponses and returns the data saved in the database.
     * @param {FormResponseCreateManyAndReturnArgs} args - Arguments to create many FormResponses.
     * @example
     * // Create many FormResponses
     * const formResponse = await prisma.formResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormResponses and only return the `id`
     * const formResponseWithIdOnly = await prisma.formResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, FormResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FormResponse.
     * @param {FormResponseDeleteArgs} args - Arguments to delete one FormResponse.
     * @example
     * // Delete one FormResponse
     * const FormResponse = await prisma.formResponse.delete({
     *   where: {
     *     // ... filter to delete one FormResponse
     *   }
     * })
     * 
     */
    delete<T extends FormResponseDeleteArgs>(args: SelectSubset<T, FormResponseDeleteArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FormResponse.
     * @param {FormResponseUpdateArgs} args - Arguments to update one FormResponse.
     * @example
     * // Update one FormResponse
     * const formResponse = await prisma.formResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormResponseUpdateArgs>(args: SelectSubset<T, FormResponseUpdateArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FormResponses.
     * @param {FormResponseDeleteManyArgs} args - Arguments to filter FormResponses to delete.
     * @example
     * // Delete a few FormResponses
     * const { count } = await prisma.formResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormResponseDeleteManyArgs>(args?: SelectSubset<T, FormResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormResponses
     * const formResponse = await prisma.formResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormResponseUpdateManyArgs>(args: SelectSubset<T, FormResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormResponse.
     * @param {FormResponseUpsertArgs} args - Arguments to update or create a FormResponse.
     * @example
     * // Update or create a FormResponse
     * const formResponse = await prisma.formResponse.upsert({
     *   create: {
     *     // ... data to create a FormResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormResponse we want to update
     *   }
     * })
     */
    upsert<T extends FormResponseUpsertArgs>(args: SelectSubset<T, FormResponseUpsertArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FormResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseCountArgs} args - Arguments to filter FormResponses to count.
     * @example
     * // Count the number of FormResponses
     * const count = await prisma.formResponse.count({
     *   where: {
     *     // ... the filter for the FormResponses we want to count
     *   }
     * })
    **/
    count<T extends FormResponseCountArgs>(
      args?: Subset<T, FormResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormResponseAggregateArgs>(args: Subset<T, FormResponseAggregateArgs>): Prisma.PrismaPromise<GetFormResponseAggregateType<T>>

    /**
     * Group by FormResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormResponseGroupByArgs['orderBy'] }
        : { orderBy?: FormResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormResponse model
   */
  readonly fields: FormResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormResponse model
   */ 
  interface FormResponseFieldRefs {
    readonly id: FieldRef<"FormResponse", 'String'>
    readonly formId: FieldRef<"FormResponse", 'String'>
    readonly userId: FieldRef<"FormResponse", 'String'>
    readonly answers: FieldRef<"FormResponse", 'Json'>
    readonly createdAt: FieldRef<"FormResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormResponse findUnique
   */
  export type FormResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where: FormResponseWhereUniqueInput
  }

  /**
   * FormResponse findUniqueOrThrow
   */
  export type FormResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where: FormResponseWhereUniqueInput
  }

  /**
   * FormResponse findFirst
   */
  export type FormResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResponses.
     */
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * FormResponse findFirstOrThrow
   */
  export type FormResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResponses.
     */
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * FormResponse findMany
   */
  export type FormResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponses to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * FormResponse create
   */
  export type FormResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a FormResponse.
     */
    data: XOR<FormResponseCreateInput, FormResponseUncheckedCreateInput>
  }

  /**
   * FormResponse createMany
   */
  export type FormResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormResponses.
     */
    data: FormResponseCreateManyInput | FormResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormResponse createManyAndReturn
   */
  export type FormResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FormResponses.
     */
    data: FormResponseCreateManyInput | FormResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormResponse update
   */
  export type FormResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a FormResponse.
     */
    data: XOR<FormResponseUpdateInput, FormResponseUncheckedUpdateInput>
    /**
     * Choose, which FormResponse to update.
     */
    where: FormResponseWhereUniqueInput
  }

  /**
   * FormResponse updateMany
   */
  export type FormResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormResponses.
     */
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyInput>
    /**
     * Filter which FormResponses to update
     */
    where?: FormResponseWhereInput
  }

  /**
   * FormResponse upsert
   */
  export type FormResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the FormResponse to update in case it exists.
     */
    where: FormResponseWhereUniqueInput
    /**
     * In case the FormResponse found by the `where` argument doesn't exist, create a new FormResponse with this data.
     */
    create: XOR<FormResponseCreateInput, FormResponseUncheckedCreateInput>
    /**
     * In case the FormResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormResponseUpdateInput, FormResponseUncheckedUpdateInput>
  }

  /**
   * FormResponse delete
   */
  export type FormResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter which FormResponse to delete.
     */
    where: FormResponseWhereUniqueInput
  }

  /**
   * FormResponse deleteMany
   */
  export type FormResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResponses to delete
     */
    where?: FormResponseWhereInput
  }

  /**
   * FormResponse without action
   */
  export type FormResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
  }


  /**
   * Model ParentInvitation
   */

  export type AggregateParentInvitation = {
    _count: ParentInvitationCountAggregateOutputType | null
    _min: ParentInvitationMinAggregateOutputType | null
    _max: ParentInvitationMaxAggregateOutputType | null
  }

  export type ParentInvitationMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    accessCode: string | null
    magicToken: string | null
    parentEmail: string | null
    parentName: string | null
    status: string | null
    expiresAt: Date | null
    redeemedAt: Date | null
    redeemedByUserId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ParentInvitationMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    accessCode: string | null
    magicToken: string | null
    parentEmail: string | null
    parentName: string | null
    status: string | null
    expiresAt: Date | null
    redeemedAt: Date | null
    redeemedByUserId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ParentInvitationCountAggregateOutputType = {
    id: number
    schoolId: number
    accessCode: number
    magicToken: number
    parentEmail: number
    parentName: number
    status: number
    expiresAt: number
    redeemedAt: number
    redeemedByUserId: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type ParentInvitationMinAggregateInputType = {
    id?: true
    schoolId?: true
    accessCode?: true
    magicToken?: true
    parentEmail?: true
    parentName?: true
    status?: true
    expiresAt?: true
    redeemedAt?: true
    redeemedByUserId?: true
    createdById?: true
    createdAt?: true
  }

  export type ParentInvitationMaxAggregateInputType = {
    id?: true
    schoolId?: true
    accessCode?: true
    magicToken?: true
    parentEmail?: true
    parentName?: true
    status?: true
    expiresAt?: true
    redeemedAt?: true
    redeemedByUserId?: true
    createdById?: true
    createdAt?: true
  }

  export type ParentInvitationCountAggregateInputType = {
    id?: true
    schoolId?: true
    accessCode?: true
    magicToken?: true
    parentEmail?: true
    parentName?: true
    status?: true
    expiresAt?: true
    redeemedAt?: true
    redeemedByUserId?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type ParentInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentInvitation to aggregate.
     */
    where?: ParentInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvitations to fetch.
     */
    orderBy?: ParentInvitationOrderByWithRelationInput | ParentInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentInvitations
    **/
    _count?: true | ParentInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentInvitationMaxAggregateInputType
  }

  export type GetParentInvitationAggregateType<T extends ParentInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateParentInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentInvitation[P]>
      : GetScalarType<T[P], AggregateParentInvitation[P]>
  }




  export type ParentInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentInvitationWhereInput
    orderBy?: ParentInvitationOrderByWithAggregationInput | ParentInvitationOrderByWithAggregationInput[]
    by: ParentInvitationScalarFieldEnum[] | ParentInvitationScalarFieldEnum
    having?: ParentInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentInvitationCountAggregateInputType | true
    _min?: ParentInvitationMinAggregateInputType
    _max?: ParentInvitationMaxAggregateInputType
  }

  export type ParentInvitationGroupByOutputType = {
    id: string
    schoolId: string
    accessCode: string
    magicToken: string | null
    parentEmail: string | null
    parentName: string | null
    status: string
    expiresAt: Date | null
    redeemedAt: Date | null
    redeemedByUserId: string | null
    createdById: string
    createdAt: Date
    _count: ParentInvitationCountAggregateOutputType | null
    _min: ParentInvitationMinAggregateOutputType | null
    _max: ParentInvitationMaxAggregateOutputType | null
  }

  type GetParentInvitationGroupByPayload<T extends ParentInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], ParentInvitationGroupByOutputType[P]>
        }
      >
    >


  export type ParentInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    accessCode?: boolean
    magicToken?: boolean
    parentEmail?: boolean
    parentName?: boolean
    status?: boolean
    expiresAt?: boolean
    redeemedAt?: boolean
    redeemedByUserId?: boolean
    createdById?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    childLinks?: boolean | ParentInvitation$childLinksArgs<ExtArgs>
    studentLinks?: boolean | ParentInvitation$studentLinksArgs<ExtArgs>
    redeemedByUser?: boolean | ParentInvitation$redeemedByUserArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ParentInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentInvitation"]>

  export type ParentInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    accessCode?: boolean
    magicToken?: boolean
    parentEmail?: boolean
    parentName?: boolean
    status?: boolean
    expiresAt?: boolean
    redeemedAt?: boolean
    redeemedByUserId?: boolean
    createdById?: boolean
    createdAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    redeemedByUser?: boolean | ParentInvitation$redeemedByUserArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentInvitation"]>

  export type ParentInvitationSelectScalar = {
    id?: boolean
    schoolId?: boolean
    accessCode?: boolean
    magicToken?: boolean
    parentEmail?: boolean
    parentName?: boolean
    status?: boolean
    expiresAt?: boolean
    redeemedAt?: boolean
    redeemedByUserId?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type ParentInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    childLinks?: boolean | ParentInvitation$childLinksArgs<ExtArgs>
    studentLinks?: boolean | ParentInvitation$studentLinksArgs<ExtArgs>
    redeemedByUser?: boolean | ParentInvitation$redeemedByUserArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ParentInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    redeemedByUser?: boolean | ParentInvitation$redeemedByUserArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ParentInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParentInvitation"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      childLinks: Prisma.$ChildInvitationLinkPayload<ExtArgs>[]
      studentLinks: Prisma.$StudentInvitationLinkPayload<ExtArgs>[]
      redeemedByUser: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      accessCode: string
      magicToken: string | null
      parentEmail: string | null
      parentName: string | null
      status: string
      expiresAt: Date | null
      redeemedAt: Date | null
      redeemedByUserId: string | null
      createdById: string
      createdAt: Date
    }, ExtArgs["result"]["parentInvitation"]>
    composites: {}
  }

  type ParentInvitationGetPayload<S extends boolean | null | undefined | ParentInvitationDefaultArgs> = $Result.GetResult<Prisma.$ParentInvitationPayload, S>

  type ParentInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentInvitationCountAggregateInputType | true
    }

  export interface ParentInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParentInvitation'], meta: { name: 'ParentInvitation' } }
    /**
     * Find zero or one ParentInvitation that matches the filter.
     * @param {ParentInvitationFindUniqueArgs} args - Arguments to find a ParentInvitation
     * @example
     * // Get one ParentInvitation
     * const parentInvitation = await prisma.parentInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentInvitationFindUniqueArgs>(args: SelectSubset<T, ParentInvitationFindUniqueArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParentInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParentInvitationFindUniqueOrThrowArgs} args - Arguments to find a ParentInvitation
     * @example
     * // Get one ParentInvitation
     * const parentInvitation = await prisma.parentInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParentInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInvitationFindFirstArgs} args - Arguments to find a ParentInvitation
     * @example
     * // Get one ParentInvitation
     * const parentInvitation = await prisma.parentInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentInvitationFindFirstArgs>(args?: SelectSubset<T, ParentInvitationFindFirstArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParentInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInvitationFindFirstOrThrowArgs} args - Arguments to find a ParentInvitation
     * @example
     * // Get one ParentInvitation
     * const parentInvitation = await prisma.parentInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParentInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentInvitations
     * const parentInvitations = await prisma.parentInvitation.findMany()
     * 
     * // Get first 10 ParentInvitations
     * const parentInvitations = await prisma.parentInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentInvitationWithIdOnly = await prisma.parentInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentInvitationFindManyArgs>(args?: SelectSubset<T, ParentInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParentInvitation.
     * @param {ParentInvitationCreateArgs} args - Arguments to create a ParentInvitation.
     * @example
     * // Create one ParentInvitation
     * const ParentInvitation = await prisma.parentInvitation.create({
     *   data: {
     *     // ... data to create a ParentInvitation
     *   }
     * })
     * 
     */
    create<T extends ParentInvitationCreateArgs>(args: SelectSubset<T, ParentInvitationCreateArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParentInvitations.
     * @param {ParentInvitationCreateManyArgs} args - Arguments to create many ParentInvitations.
     * @example
     * // Create many ParentInvitations
     * const parentInvitation = await prisma.parentInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentInvitationCreateManyArgs>(args?: SelectSubset<T, ParentInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParentInvitations and returns the data saved in the database.
     * @param {ParentInvitationCreateManyAndReturnArgs} args - Arguments to create many ParentInvitations.
     * @example
     * // Create many ParentInvitations
     * const parentInvitation = await prisma.parentInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParentInvitations and only return the `id`
     * const parentInvitationWithIdOnly = await prisma.parentInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParentInvitation.
     * @param {ParentInvitationDeleteArgs} args - Arguments to delete one ParentInvitation.
     * @example
     * // Delete one ParentInvitation
     * const ParentInvitation = await prisma.parentInvitation.delete({
     *   where: {
     *     // ... filter to delete one ParentInvitation
     *   }
     * })
     * 
     */
    delete<T extends ParentInvitationDeleteArgs>(args: SelectSubset<T, ParentInvitationDeleteArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParentInvitation.
     * @param {ParentInvitationUpdateArgs} args - Arguments to update one ParentInvitation.
     * @example
     * // Update one ParentInvitation
     * const parentInvitation = await prisma.parentInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentInvitationUpdateArgs>(args: SelectSubset<T, ParentInvitationUpdateArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParentInvitations.
     * @param {ParentInvitationDeleteManyArgs} args - Arguments to filter ParentInvitations to delete.
     * @example
     * // Delete a few ParentInvitations
     * const { count } = await prisma.parentInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentInvitationDeleteManyArgs>(args?: SelectSubset<T, ParentInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentInvitations
     * const parentInvitation = await prisma.parentInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentInvitationUpdateManyArgs>(args: SelectSubset<T, ParentInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParentInvitation.
     * @param {ParentInvitationUpsertArgs} args - Arguments to update or create a ParentInvitation.
     * @example
     * // Update or create a ParentInvitation
     * const parentInvitation = await prisma.parentInvitation.upsert({
     *   create: {
     *     // ... data to create a ParentInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentInvitation we want to update
     *   }
     * })
     */
    upsert<T extends ParentInvitationUpsertArgs>(args: SelectSubset<T, ParentInvitationUpsertArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParentInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInvitationCountArgs} args - Arguments to filter ParentInvitations to count.
     * @example
     * // Count the number of ParentInvitations
     * const count = await prisma.parentInvitation.count({
     *   where: {
     *     // ... the filter for the ParentInvitations we want to count
     *   }
     * })
    **/
    count<T extends ParentInvitationCountArgs>(
      args?: Subset<T, ParentInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentInvitationAggregateArgs>(args: Subset<T, ParentInvitationAggregateArgs>): Prisma.PrismaPromise<GetParentInvitationAggregateType<T>>

    /**
     * Group by ParentInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentInvitationGroupByArgs['orderBy'] }
        : { orderBy?: ParentInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParentInvitation model
   */
  readonly fields: ParentInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    childLinks<T extends ParentInvitation$childLinksArgs<ExtArgs> = {}>(args?: Subset<T, ParentInvitation$childLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "findMany"> | Null>
    studentLinks<T extends ParentInvitation$studentLinksArgs<ExtArgs> = {}>(args?: Subset<T, ParentInvitation$studentLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentInvitationLinkPayload<ExtArgs>, T, "findMany"> | Null>
    redeemedByUser<T extends ParentInvitation$redeemedByUserArgs<ExtArgs> = {}>(args?: Subset<T, ParentInvitation$redeemedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParentInvitation model
   */ 
  interface ParentInvitationFieldRefs {
    readonly id: FieldRef<"ParentInvitation", 'String'>
    readonly schoolId: FieldRef<"ParentInvitation", 'String'>
    readonly accessCode: FieldRef<"ParentInvitation", 'String'>
    readonly magicToken: FieldRef<"ParentInvitation", 'String'>
    readonly parentEmail: FieldRef<"ParentInvitation", 'String'>
    readonly parentName: FieldRef<"ParentInvitation", 'String'>
    readonly status: FieldRef<"ParentInvitation", 'String'>
    readonly expiresAt: FieldRef<"ParentInvitation", 'DateTime'>
    readonly redeemedAt: FieldRef<"ParentInvitation", 'DateTime'>
    readonly redeemedByUserId: FieldRef<"ParentInvitation", 'String'>
    readonly createdById: FieldRef<"ParentInvitation", 'String'>
    readonly createdAt: FieldRef<"ParentInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParentInvitation findUnique
   */
  export type ParentInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvitation to fetch.
     */
    where: ParentInvitationWhereUniqueInput
  }

  /**
   * ParentInvitation findUniqueOrThrow
   */
  export type ParentInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvitation to fetch.
     */
    where: ParentInvitationWhereUniqueInput
  }

  /**
   * ParentInvitation findFirst
   */
  export type ParentInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvitation to fetch.
     */
    where?: ParentInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvitations to fetch.
     */
    orderBy?: ParentInvitationOrderByWithRelationInput | ParentInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentInvitations.
     */
    cursor?: ParentInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentInvitations.
     */
    distinct?: ParentInvitationScalarFieldEnum | ParentInvitationScalarFieldEnum[]
  }

  /**
   * ParentInvitation findFirstOrThrow
   */
  export type ParentInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvitation to fetch.
     */
    where?: ParentInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvitations to fetch.
     */
    orderBy?: ParentInvitationOrderByWithRelationInput | ParentInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentInvitations.
     */
    cursor?: ParentInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentInvitations.
     */
    distinct?: ParentInvitationScalarFieldEnum | ParentInvitationScalarFieldEnum[]
  }

  /**
   * ParentInvitation findMany
   */
  export type ParentInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvitations to fetch.
     */
    where?: ParentInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvitations to fetch.
     */
    orderBy?: ParentInvitationOrderByWithRelationInput | ParentInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentInvitations.
     */
    cursor?: ParentInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvitations.
     */
    skip?: number
    distinct?: ParentInvitationScalarFieldEnum | ParentInvitationScalarFieldEnum[]
  }

  /**
   * ParentInvitation create
   */
  export type ParentInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a ParentInvitation.
     */
    data: XOR<ParentInvitationCreateInput, ParentInvitationUncheckedCreateInput>
  }

  /**
   * ParentInvitation createMany
   */
  export type ParentInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParentInvitations.
     */
    data: ParentInvitationCreateManyInput | ParentInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParentInvitation createManyAndReturn
   */
  export type ParentInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParentInvitations.
     */
    data: ParentInvitationCreateManyInput | ParentInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParentInvitation update
   */
  export type ParentInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a ParentInvitation.
     */
    data: XOR<ParentInvitationUpdateInput, ParentInvitationUncheckedUpdateInput>
    /**
     * Choose, which ParentInvitation to update.
     */
    where: ParentInvitationWhereUniqueInput
  }

  /**
   * ParentInvitation updateMany
   */
  export type ParentInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParentInvitations.
     */
    data: XOR<ParentInvitationUpdateManyMutationInput, ParentInvitationUncheckedUpdateManyInput>
    /**
     * Filter which ParentInvitations to update
     */
    where?: ParentInvitationWhereInput
  }

  /**
   * ParentInvitation upsert
   */
  export type ParentInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the ParentInvitation to update in case it exists.
     */
    where: ParentInvitationWhereUniqueInput
    /**
     * In case the ParentInvitation found by the `where` argument doesn't exist, create a new ParentInvitation with this data.
     */
    create: XOR<ParentInvitationCreateInput, ParentInvitationUncheckedCreateInput>
    /**
     * In case the ParentInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentInvitationUpdateInput, ParentInvitationUncheckedUpdateInput>
  }

  /**
   * ParentInvitation delete
   */
  export type ParentInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
    /**
     * Filter which ParentInvitation to delete.
     */
    where: ParentInvitationWhereUniqueInput
  }

  /**
   * ParentInvitation deleteMany
   */
  export type ParentInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentInvitations to delete
     */
    where?: ParentInvitationWhereInput
  }

  /**
   * ParentInvitation.childLinks
   */
  export type ParentInvitation$childLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    where?: ChildInvitationLinkWhereInput
    orderBy?: ChildInvitationLinkOrderByWithRelationInput | ChildInvitationLinkOrderByWithRelationInput[]
    cursor?: ChildInvitationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildInvitationLinkScalarFieldEnum | ChildInvitationLinkScalarFieldEnum[]
  }

  /**
   * ParentInvitation.studentLinks
   */
  export type ParentInvitation$studentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentInvitationLink
     */
    select?: StudentInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInvitationLinkInclude<ExtArgs> | null
    where?: StudentInvitationLinkWhereInput
    orderBy?: StudentInvitationLinkOrderByWithRelationInput | StudentInvitationLinkOrderByWithRelationInput[]
    cursor?: StudentInvitationLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentInvitationLinkScalarFieldEnum | StudentInvitationLinkScalarFieldEnum[]
  }

  /**
   * ParentInvitation.redeemedByUser
   */
  export type ParentInvitation$redeemedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ParentInvitation without action
   */
  export type ParentInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvitation
     */
    select?: ParentInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInvitationInclude<ExtArgs> | null
  }


  /**
   * Model ChildInvitationLink
   */

  export type AggregateChildInvitationLink = {
    _count: ChildInvitationLinkCountAggregateOutputType | null
    _min: ChildInvitationLinkMinAggregateOutputType | null
    _max: ChildInvitationLinkMaxAggregateOutputType | null
  }

  export type ChildInvitationLinkMinAggregateOutputType = {
    id: string | null
    invitationId: string | null
    childName: string | null
    classId: string | null
  }

  export type ChildInvitationLinkMaxAggregateOutputType = {
    id: string | null
    invitationId: string | null
    childName: string | null
    classId: string | null
  }

  export type ChildInvitationLinkCountAggregateOutputType = {
    id: number
    invitationId: number
    childName: number
    classId: number
    _all: number
  }


  export type ChildInvitationLinkMinAggregateInputType = {
    id?: true
    invitationId?: true
    childName?: true
    classId?: true
  }

  export type ChildInvitationLinkMaxAggregateInputType = {
    id?: true
    invitationId?: true
    childName?: true
    classId?: true
  }

  export type ChildInvitationLinkCountAggregateInputType = {
    id?: true
    invitationId?: true
    childName?: true
    classId?: true
    _all?: true
  }

  export type ChildInvitationLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChildInvitationLink to aggregate.
     */
    where?: ChildInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildInvitationLinks to fetch.
     */
    orderBy?: ChildInvitationLinkOrderByWithRelationInput | ChildInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildInvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChildInvitationLinks
    **/
    _count?: true | ChildInvitationLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildInvitationLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildInvitationLinkMaxAggregateInputType
  }

  export type GetChildInvitationLinkAggregateType<T extends ChildInvitationLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateChildInvitationLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChildInvitationLink[P]>
      : GetScalarType<T[P], AggregateChildInvitationLink[P]>
  }




  export type ChildInvitationLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildInvitationLinkWhereInput
    orderBy?: ChildInvitationLinkOrderByWithAggregationInput | ChildInvitationLinkOrderByWithAggregationInput[]
    by: ChildInvitationLinkScalarFieldEnum[] | ChildInvitationLinkScalarFieldEnum
    having?: ChildInvitationLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildInvitationLinkCountAggregateInputType | true
    _min?: ChildInvitationLinkMinAggregateInputType
    _max?: ChildInvitationLinkMaxAggregateInputType
  }

  export type ChildInvitationLinkGroupByOutputType = {
    id: string
    invitationId: string
    childName: string
    classId: string
    _count: ChildInvitationLinkCountAggregateOutputType | null
    _min: ChildInvitationLinkMinAggregateOutputType | null
    _max: ChildInvitationLinkMaxAggregateOutputType | null
  }

  type GetChildInvitationLinkGroupByPayload<T extends ChildInvitationLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChildInvitationLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildInvitationLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildInvitationLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ChildInvitationLinkGroupByOutputType[P]>
        }
      >
    >


  export type ChildInvitationLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invitationId?: boolean
    childName?: boolean
    classId?: boolean
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["childInvitationLink"]>

  export type ChildInvitationLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invitationId?: boolean
    childName?: boolean
    classId?: boolean
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["childInvitationLink"]>

  export type ChildInvitationLinkSelectScalar = {
    id?: boolean
    invitationId?: boolean
    childName?: boolean
    classId?: boolean
  }

  export type ChildInvitationLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ChildInvitationLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | ParentInvitationDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ChildInvitationLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChildInvitationLink"
    objects: {
      invitation: Prisma.$ParentInvitationPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invitationId: string
      childName: string
      classId: string
    }, ExtArgs["result"]["childInvitationLink"]>
    composites: {}
  }

  type ChildInvitationLinkGetPayload<S extends boolean | null | undefined | ChildInvitationLinkDefaultArgs> = $Result.GetResult<Prisma.$ChildInvitationLinkPayload, S>

  type ChildInvitationLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChildInvitationLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChildInvitationLinkCountAggregateInputType | true
    }

  export interface ChildInvitationLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChildInvitationLink'], meta: { name: 'ChildInvitationLink' } }
    /**
     * Find zero or one ChildInvitationLink that matches the filter.
     * @param {ChildInvitationLinkFindUniqueArgs} args - Arguments to find a ChildInvitationLink
     * @example
     * // Get one ChildInvitationLink
     * const childInvitationLink = await prisma.childInvitationLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChildInvitationLinkFindUniqueArgs>(args: SelectSubset<T, ChildInvitationLinkFindUniqueArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChildInvitationLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChildInvitationLinkFindUniqueOrThrowArgs} args - Arguments to find a ChildInvitationLink
     * @example
     * // Get one ChildInvitationLink
     * const childInvitationLink = await prisma.childInvitationLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChildInvitationLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ChildInvitationLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChildInvitationLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildInvitationLinkFindFirstArgs} args - Arguments to find a ChildInvitationLink
     * @example
     * // Get one ChildInvitationLink
     * const childInvitationLink = await prisma.childInvitationLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChildInvitationLinkFindFirstArgs>(args?: SelectSubset<T, ChildInvitationLinkFindFirstArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChildInvitationLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildInvitationLinkFindFirstOrThrowArgs} args - Arguments to find a ChildInvitationLink
     * @example
     * // Get one ChildInvitationLink
     * const childInvitationLink = await prisma.childInvitationLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChildInvitationLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ChildInvitationLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChildInvitationLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildInvitationLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChildInvitationLinks
     * const childInvitationLinks = await prisma.childInvitationLink.findMany()
     * 
     * // Get first 10 ChildInvitationLinks
     * const childInvitationLinks = await prisma.childInvitationLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childInvitationLinkWithIdOnly = await prisma.childInvitationLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChildInvitationLinkFindManyArgs>(args?: SelectSubset<T, ChildInvitationLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChildInvitationLink.
     * @param {ChildInvitationLinkCreateArgs} args - Arguments to create a ChildInvitationLink.
     * @example
     * // Create one ChildInvitationLink
     * const ChildInvitationLink = await prisma.childInvitationLink.create({
     *   data: {
     *     // ... data to create a ChildInvitationLink
     *   }
     * })
     * 
     */
    create<T extends ChildInvitationLinkCreateArgs>(args: SelectSubset<T, ChildInvitationLinkCreateArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChildInvitationLinks.
     * @param {ChildInvitationLinkCreateManyArgs} args - Arguments to create many ChildInvitationLinks.
     * @example
     * // Create many ChildInvitationLinks
     * const childInvitationLink = await prisma.childInvitationLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChildInvitationLinkCreateManyArgs>(args?: SelectSubset<T, ChildInvitationLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChildInvitationLinks and returns the data saved in the database.
     * @param {ChildInvitationLinkCreateManyAndReturnArgs} args - Arguments to create many ChildInvitationLinks.
     * @example
     * // Create many ChildInvitationLinks
     * const childInvitationLink = await prisma.childInvitationLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChildInvitationLinks and only return the `id`
     * const childInvitationLinkWithIdOnly = await prisma.childInvitationLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChildInvitationLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ChildInvitationLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChildInvitationLink.
     * @param {ChildInvitationLinkDeleteArgs} args - Arguments to delete one ChildInvitationLink.
     * @example
     * // Delete one ChildInvitationLink
     * const ChildInvitationLink = await prisma.childInvitationLink.delete({
     *   where: {
     *     // ... filter to delete one ChildInvitationLink
     *   }
     * })
     * 
     */
    delete<T extends ChildInvitationLinkDeleteArgs>(args: SelectSubset<T, ChildInvitationLinkDeleteArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChildInvitationLink.
     * @param {ChildInvitationLinkUpdateArgs} args - Arguments to update one ChildInvitationLink.
     * @example
     * // Update one ChildInvitationLink
     * const childInvitationLink = await prisma.childInvitationLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChildInvitationLinkUpdateArgs>(args: SelectSubset<T, ChildInvitationLinkUpdateArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChildInvitationLinks.
     * @param {ChildInvitationLinkDeleteManyArgs} args - Arguments to filter ChildInvitationLinks to delete.
     * @example
     * // Delete a few ChildInvitationLinks
     * const { count } = await prisma.childInvitationLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChildInvitationLinkDeleteManyArgs>(args?: SelectSubset<T, ChildInvitationLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChildInvitationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildInvitationLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChildInvitationLinks
     * const childInvitationLink = await prisma.childInvitationLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChildInvitationLinkUpdateManyArgs>(args: SelectSubset<T, ChildInvitationLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChildInvitationLink.
     * @param {ChildInvitationLinkUpsertArgs} args - Arguments to update or create a ChildInvitationLink.
     * @example
     * // Update or create a ChildInvitationLink
     * const childInvitationLink = await prisma.childInvitationLink.upsert({
     *   create: {
     *     // ... data to create a ChildInvitationLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChildInvitationLink we want to update
     *   }
     * })
     */
    upsert<T extends ChildInvitationLinkUpsertArgs>(args: SelectSubset<T, ChildInvitationLinkUpsertArgs<ExtArgs>>): Prisma__ChildInvitationLinkClient<$Result.GetResult<Prisma.$ChildInvitationLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChildInvitationLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildInvitationLinkCountArgs} args - Arguments to filter ChildInvitationLinks to count.
     * @example
     * // Count the number of ChildInvitationLinks
     * const count = await prisma.childInvitationLink.count({
     *   where: {
     *     // ... the filter for the ChildInvitationLinks we want to count
     *   }
     * })
    **/
    count<T extends ChildInvitationLinkCountArgs>(
      args?: Subset<T, ChildInvitationLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildInvitationLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChildInvitationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildInvitationLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildInvitationLinkAggregateArgs>(args: Subset<T, ChildInvitationLinkAggregateArgs>): Prisma.PrismaPromise<GetChildInvitationLinkAggregateType<T>>

    /**
     * Group by ChildInvitationLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildInvitationLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildInvitationLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildInvitationLinkGroupByArgs['orderBy'] }
        : { orderBy?: ChildInvitationLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildInvitationLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildInvitationLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChildInvitationLink model
   */
  readonly fields: ChildInvitationLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChildInvitationLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChildInvitationLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitation<T extends ParentInvitationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentInvitationDefaultArgs<ExtArgs>>): Prisma__ParentInvitationClient<$Result.GetResult<Prisma.$ParentInvitationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChildInvitationLink model
   */ 
  interface ChildInvitationLinkFieldRefs {
    readonly id: FieldRef<"ChildInvitationLink", 'String'>
    readonly invitationId: FieldRef<"ChildInvitationLink", 'String'>
    readonly childName: FieldRef<"ChildInvitationLink", 'String'>
    readonly classId: FieldRef<"ChildInvitationLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChildInvitationLink findUnique
   */
  export type ChildInvitationLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which ChildInvitationLink to fetch.
     */
    where: ChildInvitationLinkWhereUniqueInput
  }

  /**
   * ChildInvitationLink findUniqueOrThrow
   */
  export type ChildInvitationLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which ChildInvitationLink to fetch.
     */
    where: ChildInvitationLinkWhereUniqueInput
  }

  /**
   * ChildInvitationLink findFirst
   */
  export type ChildInvitationLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which ChildInvitationLink to fetch.
     */
    where?: ChildInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildInvitationLinks to fetch.
     */
    orderBy?: ChildInvitationLinkOrderByWithRelationInput | ChildInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildInvitationLinks.
     */
    cursor?: ChildInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildInvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildInvitationLinks.
     */
    distinct?: ChildInvitationLinkScalarFieldEnum | ChildInvitationLinkScalarFieldEnum[]
  }

  /**
   * ChildInvitationLink findFirstOrThrow
   */
  export type ChildInvitationLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which ChildInvitationLink to fetch.
     */
    where?: ChildInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildInvitationLinks to fetch.
     */
    orderBy?: ChildInvitationLinkOrderByWithRelationInput | ChildInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildInvitationLinks.
     */
    cursor?: ChildInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildInvitationLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildInvitationLinks.
     */
    distinct?: ChildInvitationLinkScalarFieldEnum | ChildInvitationLinkScalarFieldEnum[]
  }

  /**
   * ChildInvitationLink findMany
   */
  export type ChildInvitationLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter, which ChildInvitationLinks to fetch.
     */
    where?: ChildInvitationLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildInvitationLinks to fetch.
     */
    orderBy?: ChildInvitationLinkOrderByWithRelationInput | ChildInvitationLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChildInvitationLinks.
     */
    cursor?: ChildInvitationLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildInvitationLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildInvitationLinks.
     */
    skip?: number
    distinct?: ChildInvitationLinkScalarFieldEnum | ChildInvitationLinkScalarFieldEnum[]
  }

  /**
   * ChildInvitationLink create
   */
  export type ChildInvitationLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ChildInvitationLink.
     */
    data: XOR<ChildInvitationLinkCreateInput, ChildInvitationLinkUncheckedCreateInput>
  }

  /**
   * ChildInvitationLink createMany
   */
  export type ChildInvitationLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChildInvitationLinks.
     */
    data: ChildInvitationLinkCreateManyInput | ChildInvitationLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChildInvitationLink createManyAndReturn
   */
  export type ChildInvitationLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChildInvitationLinks.
     */
    data: ChildInvitationLinkCreateManyInput | ChildInvitationLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChildInvitationLink update
   */
  export type ChildInvitationLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ChildInvitationLink.
     */
    data: XOR<ChildInvitationLinkUpdateInput, ChildInvitationLinkUncheckedUpdateInput>
    /**
     * Choose, which ChildInvitationLink to update.
     */
    where: ChildInvitationLinkWhereUniqueInput
  }

  /**
   * ChildInvitationLink updateMany
   */
  export type ChildInvitationLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChildInvitationLinks.
     */
    data: XOR<ChildInvitationLinkUpdateManyMutationInput, ChildInvitationLinkUncheckedUpdateManyInput>
    /**
     * Filter which ChildInvitationLinks to update
     */
    where?: ChildInvitationLinkWhereInput
  }

  /**
   * ChildInvitationLink upsert
   */
  export type ChildInvitationLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ChildInvitationLink to update in case it exists.
     */
    where: ChildInvitationLinkWhereUniqueInput
    /**
     * In case the ChildInvitationLink found by the `where` argument doesn't exist, create a new ChildInvitationLink with this data.
     */
    create: XOR<ChildInvitationLinkCreateInput, ChildInvitationLinkUncheckedCreateInput>
    /**
     * In case the ChildInvitationLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildInvitationLinkUpdateInput, ChildInvitationLinkUncheckedUpdateInput>
  }

  /**
   * ChildInvitationLink delete
   */
  export type ChildInvitationLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
    /**
     * Filter which ChildInvitationLink to delete.
     */
    where: ChildInvitationLinkWhereUniqueInput
  }

  /**
   * ChildInvitationLink deleteMany
   */
  export type ChildInvitationLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChildInvitationLinks to delete
     */
    where?: ChildInvitationLinkWhereInput
  }

  /**
   * ChildInvitationLink without action
   */
  export type ChildInvitationLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildInvitationLink
     */
    select?: ChildInvitationLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInvitationLinkInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: $Enums.AuditAction | null
    resourceType: $Enums.AuditResourceType | null
    resourceId: string | null
    schoolId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: $Enums.AuditAction | null
    resourceType: $Enums.AuditResourceType | null
    resourceId: string | null
    schoolId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    action: number
    resourceType: number
    resourceId: number
    metadata: number
    schoolId: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    resourceType?: true
    resourceId?: true
    schoolId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    resourceType?: true
    resourceId?: true
    schoolId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    resourceType?: true
    resourceId?: true
    metadata?: true
    schoolId?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata: JsonValue | null
    schoolId: string
    ipAddress: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    metadata?: boolean
    schoolId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    metadata?: boolean
    schoolId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    metadata?: boolean
    schoolId?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string
      action: $Enums.AuditAction
      resourceType: $Enums.AuditResourceType
      resourceId: string
      metadata: Prisma.JsonValue | null
      schoolId: string
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly userName: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly resourceType: FieldRef<"AuditLog", 'AuditResourceType'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly schoolId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    resourceType: string | null
    resourceId: string | null
    read: boolean | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    resourceType: string | null
    resourceId: string | null
    read: boolean | null
    schoolId: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    body: number
    resourceType: number
    resourceId: number
    data: number
    read: number
    schoolId: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    resourceType?: true
    resourceId?: true
    read?: true
    schoolId?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    resourceType?: true
    resourceId?: true
    read?: true
    schoolId?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    resourceType?: true
    resourceId?: true
    data?: true
    read?: true
    schoolId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    body: string
    resourceType: string | null
    resourceId: string | null
    data: JsonValue | null
    read: boolean
    schoolId: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    resourceType?: boolean
    resourceId?: boolean
    data?: boolean
    read?: boolean
    schoolId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    resourceType?: boolean
    resourceId?: boolean
    data?: boolean
    read?: boolean
    schoolId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    resourceType?: boolean
    resourceId?: boolean
    data?: boolean
    read?: boolean
    schoolId?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      body: string
      resourceType: string | null
      resourceId: string | null
      data: Prisma.JsonValue | null
      read: boolean
      schoolId: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly resourceType: FieldRef<"Notification", 'String'>
    readonly resourceId: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly schoolId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model DeviceToken
   */

  export type AggregateDeviceToken = {
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  export type DeviceTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    platform: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceToken to aggregate.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTokens
    **/
    _count?: true | DeviceTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type GetDeviceTokenAggregateType<T extends DeviceTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceToken[P]>
      : GetScalarType<T[P], AggregateDeviceToken[P]>
  }




  export type DeviceTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithAggregationInput | DeviceTokenOrderByWithAggregationInput[]
    by: DeviceTokenScalarFieldEnum[] | DeviceTokenScalarFieldEnum
    having?: DeviceTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTokenCountAggregateInputType | true
    _min?: DeviceTokenMinAggregateInputType
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type DeviceTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    platform: string
    createdAt: Date
    updatedAt: Date
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  type GetDeviceTokenGroupByPayload<T extends DeviceTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeviceTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      platform: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deviceToken"]>
    composites: {}
  }

  type DeviceTokenGetPayload<S extends boolean | null | undefined | DeviceTokenDefaultArgs> = $Result.GetResult<Prisma.$DeviceTokenPayload, S>

  type DeviceTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceTokenCountAggregateInputType | true
    }

  export interface DeviceTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceToken'], meta: { name: 'DeviceToken' } }
    /**
     * Find zero or one DeviceToken that matches the filter.
     * @param {DeviceTokenFindUniqueArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTokenFindUniqueArgs>(args: SelectSubset<T, DeviceTokenFindUniqueArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeviceToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceTokenFindUniqueOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeviceToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTokenFindFirstArgs>(args?: SelectSubset<T, DeviceTokenFindFirstArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeviceToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeviceTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany()
     * 
     * // Get first 10 DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTokenFindManyArgs>(args?: SelectSubset<T, DeviceTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeviceToken.
     * @param {DeviceTokenCreateArgs} args - Arguments to create a DeviceToken.
     * @example
     * // Create one DeviceToken
     * const DeviceToken = await prisma.deviceToken.create({
     *   data: {
     *     // ... data to create a DeviceToken
     *   }
     * })
     * 
     */
    create<T extends DeviceTokenCreateArgs>(args: SelectSubset<T, DeviceTokenCreateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeviceTokens.
     * @param {DeviceTokenCreateManyArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTokenCreateManyArgs>(args?: SelectSubset<T, DeviceTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTokens and returns the data saved in the database.
     * @param {DeviceTokenCreateManyAndReturnArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeviceToken.
     * @param {DeviceTokenDeleteArgs} args - Arguments to delete one DeviceToken.
     * @example
     * // Delete one DeviceToken
     * const DeviceToken = await prisma.deviceToken.delete({
     *   where: {
     *     // ... filter to delete one DeviceToken
     *   }
     * })
     * 
     */
    delete<T extends DeviceTokenDeleteArgs>(args: SelectSubset<T, DeviceTokenDeleteArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeviceToken.
     * @param {DeviceTokenUpdateArgs} args - Arguments to update one DeviceToken.
     * @example
     * // Update one DeviceToken
     * const deviceToken = await prisma.deviceToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTokenUpdateArgs>(args: SelectSubset<T, DeviceTokenUpdateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeviceTokens.
     * @param {DeviceTokenDeleteManyArgs} args - Arguments to filter DeviceTokens to delete.
     * @example
     * // Delete a few DeviceTokens
     * const { count } = await prisma.deviceToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTokenDeleteManyArgs>(args?: SelectSubset<T, DeviceTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTokenUpdateManyArgs>(args: SelectSubset<T, DeviceTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceToken.
     * @param {DeviceTokenUpsertArgs} args - Arguments to update or create a DeviceToken.
     * @example
     * // Update or create a DeviceToken
     * const deviceToken = await prisma.deviceToken.upsert({
     *   create: {
     *     // ... data to create a DeviceToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceToken we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTokenUpsertArgs>(args: SelectSubset<T, DeviceTokenUpsertArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenCountArgs} args - Arguments to filter DeviceTokens to count.
     * @example
     * // Count the number of DeviceTokens
     * const count = await prisma.deviceToken.count({
     *   where: {
     *     // ... the filter for the DeviceTokens we want to count
     *   }
     * })
    **/
    count<T extends DeviceTokenCountArgs>(
      args?: Subset<T, DeviceTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTokenAggregateArgs>(args: Subset<T, DeviceTokenAggregateArgs>): Prisma.PrismaPromise<GetDeviceTokenAggregateType<T>>

    /**
     * Group by DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTokenGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceToken model
   */
  readonly fields: DeviceTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceToken model
   */ 
  interface DeviceTokenFieldRefs {
    readonly id: FieldRef<"DeviceToken", 'String'>
    readonly userId: FieldRef<"DeviceToken", 'String'>
    readonly token: FieldRef<"DeviceToken", 'String'>
    readonly platform: FieldRef<"DeviceToken", 'String'>
    readonly createdAt: FieldRef<"DeviceToken", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceToken findUnique
   */
  export type DeviceTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findUniqueOrThrow
   */
  export type DeviceTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findFirst
   */
  export type DeviceTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findFirstOrThrow
   */
  export type DeviceTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findMany
   */
  export type DeviceTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTokens to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken create
   */
  export type DeviceTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceToken.
     */
    data: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
  }

  /**
   * DeviceToken createMany
   */
  export type DeviceTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceToken createManyAndReturn
   */
  export type DeviceTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken update
   */
  export type DeviceTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceToken.
     */
    data: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
    /**
     * Choose, which DeviceToken to update.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken updateMany
   */
  export type DeviceTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
  }

  /**
   * DeviceToken upsert
   */
  export type DeviceTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceToken to update in case it exists.
     */
    where: DeviceTokenWhereUniqueInput
    /**
     * In case the DeviceToken found by the `where` argument doesn't exist, create a new DeviceToken with this data.
     */
    create: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
    /**
     * In case the DeviceToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
  }

  /**
   * DeviceToken delete
   */
  export type DeviceTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter which DeviceToken to delete.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken deleteMany
   */
  export type DeviceTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTokens to delete
     */
    where?: DeviceTokenWhereInput
  }

  /**
   * DeviceToken without action
   */
  export type DeviceTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
  }


  /**
   * Model MagicLinkToken
   */

  export type AggregateMagicLinkToken = {
    _count: MagicLinkTokenCountAggregateOutputType | null
    _min: MagicLinkTokenMinAggregateOutputType | null
    _max: MagicLinkTokenMaxAggregateOutputType | null
  }

  export type MagicLinkTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    email: string | null
    schoolId: string | null
    type: string | null
    invitationId: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type MagicLinkTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    email: string | null
    schoolId: string | null
    type: string | null
    invitationId: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type MagicLinkTokenCountAggregateOutputType = {
    id: number
    token: number
    email: number
    schoolId: number
    type: number
    invitationId: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type MagicLinkTokenMinAggregateInputType = {
    id?: true
    token?: true
    email?: true
    schoolId?: true
    type?: true
    invitationId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type MagicLinkTokenMaxAggregateInputType = {
    id?: true
    token?: true
    email?: true
    schoolId?: true
    type?: true
    invitationId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type MagicLinkTokenCountAggregateInputType = {
    id?: true
    token?: true
    email?: true
    schoolId?: true
    type?: true
    invitationId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MagicLinkTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicLinkToken to aggregate.
     */
    where?: MagicLinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicLinkTokens to fetch.
     */
    orderBy?: MagicLinkTokenOrderByWithRelationInput | MagicLinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicLinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicLinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicLinkTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicLinkTokens
    **/
    _count?: true | MagicLinkTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicLinkTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicLinkTokenMaxAggregateInputType
  }

  export type GetMagicLinkTokenAggregateType<T extends MagicLinkTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicLinkToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicLinkToken[P]>
      : GetScalarType<T[P], AggregateMagicLinkToken[P]>
  }




  export type MagicLinkTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicLinkTokenWhereInput
    orderBy?: MagicLinkTokenOrderByWithAggregationInput | MagicLinkTokenOrderByWithAggregationInput[]
    by: MagicLinkTokenScalarFieldEnum[] | MagicLinkTokenScalarFieldEnum
    having?: MagicLinkTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicLinkTokenCountAggregateInputType | true
    _min?: MagicLinkTokenMinAggregateInputType
    _max?: MagicLinkTokenMaxAggregateInputType
  }

  export type MagicLinkTokenGroupByOutputType = {
    id: string
    token: string
    email: string
    schoolId: string
    type: string
    invitationId: string | null
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: MagicLinkTokenCountAggregateOutputType | null
    _min: MagicLinkTokenMinAggregateOutputType | null
    _max: MagicLinkTokenMaxAggregateOutputType | null
  }

  type GetMagicLinkTokenGroupByPayload<T extends MagicLinkTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicLinkTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicLinkTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicLinkTokenGroupByOutputType[P]>
            : GetScalarType<T[P], MagicLinkTokenGroupByOutputType[P]>
        }
      >
    >


  export type MagicLinkTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    schoolId?: boolean
    type?: boolean
    invitationId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["magicLinkToken"]>

  export type MagicLinkTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    schoolId?: boolean
    type?: boolean
    invitationId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["magicLinkToken"]>

  export type MagicLinkTokenSelectScalar = {
    id?: boolean
    token?: boolean
    email?: boolean
    schoolId?: boolean
    type?: boolean
    invitationId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }


  export type $MagicLinkTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicLinkToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      email: string
      schoolId: string
      type: string
      invitationId: string | null
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["magicLinkToken"]>
    composites: {}
  }

  type MagicLinkTokenGetPayload<S extends boolean | null | undefined | MagicLinkTokenDefaultArgs> = $Result.GetResult<Prisma.$MagicLinkTokenPayload, S>

  type MagicLinkTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MagicLinkTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MagicLinkTokenCountAggregateInputType | true
    }

  export interface MagicLinkTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicLinkToken'], meta: { name: 'MagicLinkToken' } }
    /**
     * Find zero or one MagicLinkToken that matches the filter.
     * @param {MagicLinkTokenFindUniqueArgs} args - Arguments to find a MagicLinkToken
     * @example
     * // Get one MagicLinkToken
     * const magicLinkToken = await prisma.magicLinkToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicLinkTokenFindUniqueArgs>(args: SelectSubset<T, MagicLinkTokenFindUniqueArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MagicLinkToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MagicLinkTokenFindUniqueOrThrowArgs} args - Arguments to find a MagicLinkToken
     * @example
     * // Get one MagicLinkToken
     * const magicLinkToken = await prisma.magicLinkToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicLinkTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicLinkTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MagicLinkToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicLinkTokenFindFirstArgs} args - Arguments to find a MagicLinkToken
     * @example
     * // Get one MagicLinkToken
     * const magicLinkToken = await prisma.magicLinkToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicLinkTokenFindFirstArgs>(args?: SelectSubset<T, MagicLinkTokenFindFirstArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MagicLinkToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicLinkTokenFindFirstOrThrowArgs} args - Arguments to find a MagicLinkToken
     * @example
     * // Get one MagicLinkToken
     * const magicLinkToken = await prisma.magicLinkToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicLinkTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicLinkTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MagicLinkTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicLinkTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicLinkTokens
     * const magicLinkTokens = await prisma.magicLinkToken.findMany()
     * 
     * // Get first 10 MagicLinkTokens
     * const magicLinkTokens = await prisma.magicLinkToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magicLinkTokenWithIdOnly = await prisma.magicLinkToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MagicLinkTokenFindManyArgs>(args?: SelectSubset<T, MagicLinkTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MagicLinkToken.
     * @param {MagicLinkTokenCreateArgs} args - Arguments to create a MagicLinkToken.
     * @example
     * // Create one MagicLinkToken
     * const MagicLinkToken = await prisma.magicLinkToken.create({
     *   data: {
     *     // ... data to create a MagicLinkToken
     *   }
     * })
     * 
     */
    create<T extends MagicLinkTokenCreateArgs>(args: SelectSubset<T, MagicLinkTokenCreateArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MagicLinkTokens.
     * @param {MagicLinkTokenCreateManyArgs} args - Arguments to create many MagicLinkTokens.
     * @example
     * // Create many MagicLinkTokens
     * const magicLinkToken = await prisma.magicLinkToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicLinkTokenCreateManyArgs>(args?: SelectSubset<T, MagicLinkTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicLinkTokens and returns the data saved in the database.
     * @param {MagicLinkTokenCreateManyAndReturnArgs} args - Arguments to create many MagicLinkTokens.
     * @example
     * // Create many MagicLinkTokens
     * const magicLinkToken = await prisma.magicLinkToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicLinkTokens and only return the `id`
     * const magicLinkTokenWithIdOnly = await prisma.magicLinkToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicLinkTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicLinkTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MagicLinkToken.
     * @param {MagicLinkTokenDeleteArgs} args - Arguments to delete one MagicLinkToken.
     * @example
     * // Delete one MagicLinkToken
     * const MagicLinkToken = await prisma.magicLinkToken.delete({
     *   where: {
     *     // ... filter to delete one MagicLinkToken
     *   }
     * })
     * 
     */
    delete<T extends MagicLinkTokenDeleteArgs>(args: SelectSubset<T, MagicLinkTokenDeleteArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MagicLinkToken.
     * @param {MagicLinkTokenUpdateArgs} args - Arguments to update one MagicLinkToken.
     * @example
     * // Update one MagicLinkToken
     * const magicLinkToken = await prisma.magicLinkToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicLinkTokenUpdateArgs>(args: SelectSubset<T, MagicLinkTokenUpdateArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MagicLinkTokens.
     * @param {MagicLinkTokenDeleteManyArgs} args - Arguments to filter MagicLinkTokens to delete.
     * @example
     * // Delete a few MagicLinkTokens
     * const { count } = await prisma.magicLinkToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicLinkTokenDeleteManyArgs>(args?: SelectSubset<T, MagicLinkTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicLinkTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicLinkTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicLinkTokens
     * const magicLinkToken = await prisma.magicLinkToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicLinkTokenUpdateManyArgs>(args: SelectSubset<T, MagicLinkTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MagicLinkToken.
     * @param {MagicLinkTokenUpsertArgs} args - Arguments to update or create a MagicLinkToken.
     * @example
     * // Update or create a MagicLinkToken
     * const magicLinkToken = await prisma.magicLinkToken.upsert({
     *   create: {
     *     // ... data to create a MagicLinkToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicLinkToken we want to update
     *   }
     * })
     */
    upsert<T extends MagicLinkTokenUpsertArgs>(args: SelectSubset<T, MagicLinkTokenUpsertArgs<ExtArgs>>): Prisma__MagicLinkTokenClient<$Result.GetResult<Prisma.$MagicLinkTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MagicLinkTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicLinkTokenCountArgs} args - Arguments to filter MagicLinkTokens to count.
     * @example
     * // Count the number of MagicLinkTokens
     * const count = await prisma.magicLinkToken.count({
     *   where: {
     *     // ... the filter for the MagicLinkTokens we want to count
     *   }
     * })
    **/
    count<T extends MagicLinkTokenCountArgs>(
      args?: Subset<T, MagicLinkTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicLinkTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicLinkToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicLinkTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicLinkTokenAggregateArgs>(args: Subset<T, MagicLinkTokenAggregateArgs>): Prisma.PrismaPromise<GetMagicLinkTokenAggregateType<T>>

    /**
     * Group by MagicLinkToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicLinkTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicLinkTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicLinkTokenGroupByArgs['orderBy'] }
        : { orderBy?: MagicLinkTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicLinkTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicLinkTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicLinkToken model
   */
  readonly fields: MagicLinkTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicLinkToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicLinkTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicLinkToken model
   */ 
  interface MagicLinkTokenFieldRefs {
    readonly id: FieldRef<"MagicLinkToken", 'String'>
    readonly token: FieldRef<"MagicLinkToken", 'String'>
    readonly email: FieldRef<"MagicLinkToken", 'String'>
    readonly schoolId: FieldRef<"MagicLinkToken", 'String'>
    readonly type: FieldRef<"MagicLinkToken", 'String'>
    readonly invitationId: FieldRef<"MagicLinkToken", 'String'>
    readonly expiresAt: FieldRef<"MagicLinkToken", 'DateTime'>
    readonly usedAt: FieldRef<"MagicLinkToken", 'DateTime'>
    readonly createdAt: FieldRef<"MagicLinkToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MagicLinkToken findUnique
   */
  export type MagicLinkTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * Filter, which MagicLinkToken to fetch.
     */
    where: MagicLinkTokenWhereUniqueInput
  }

  /**
   * MagicLinkToken findUniqueOrThrow
   */
  export type MagicLinkTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * Filter, which MagicLinkToken to fetch.
     */
    where: MagicLinkTokenWhereUniqueInput
  }

  /**
   * MagicLinkToken findFirst
   */
  export type MagicLinkTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * Filter, which MagicLinkToken to fetch.
     */
    where?: MagicLinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicLinkTokens to fetch.
     */
    orderBy?: MagicLinkTokenOrderByWithRelationInput | MagicLinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicLinkTokens.
     */
    cursor?: MagicLinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicLinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicLinkTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicLinkTokens.
     */
    distinct?: MagicLinkTokenScalarFieldEnum | MagicLinkTokenScalarFieldEnum[]
  }

  /**
   * MagicLinkToken findFirstOrThrow
   */
  export type MagicLinkTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * Filter, which MagicLinkToken to fetch.
     */
    where?: MagicLinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicLinkTokens to fetch.
     */
    orderBy?: MagicLinkTokenOrderByWithRelationInput | MagicLinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicLinkTokens.
     */
    cursor?: MagicLinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicLinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicLinkTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicLinkTokens.
     */
    distinct?: MagicLinkTokenScalarFieldEnum | MagicLinkTokenScalarFieldEnum[]
  }

  /**
   * MagicLinkToken findMany
   */
  export type MagicLinkTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * Filter, which MagicLinkTokens to fetch.
     */
    where?: MagicLinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicLinkTokens to fetch.
     */
    orderBy?: MagicLinkTokenOrderByWithRelationInput | MagicLinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicLinkTokens.
     */
    cursor?: MagicLinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicLinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicLinkTokens.
     */
    skip?: number
    distinct?: MagicLinkTokenScalarFieldEnum | MagicLinkTokenScalarFieldEnum[]
  }

  /**
   * MagicLinkToken create
   */
  export type MagicLinkTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a MagicLinkToken.
     */
    data: XOR<MagicLinkTokenCreateInput, MagicLinkTokenUncheckedCreateInput>
  }

  /**
   * MagicLinkToken createMany
   */
  export type MagicLinkTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicLinkTokens.
     */
    data: MagicLinkTokenCreateManyInput | MagicLinkTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicLinkToken createManyAndReturn
   */
  export type MagicLinkTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MagicLinkTokens.
     */
    data: MagicLinkTokenCreateManyInput | MagicLinkTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicLinkToken update
   */
  export type MagicLinkTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a MagicLinkToken.
     */
    data: XOR<MagicLinkTokenUpdateInput, MagicLinkTokenUncheckedUpdateInput>
    /**
     * Choose, which MagicLinkToken to update.
     */
    where: MagicLinkTokenWhereUniqueInput
  }

  /**
   * MagicLinkToken updateMany
   */
  export type MagicLinkTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicLinkTokens.
     */
    data: XOR<MagicLinkTokenUpdateManyMutationInput, MagicLinkTokenUncheckedUpdateManyInput>
    /**
     * Filter which MagicLinkTokens to update
     */
    where?: MagicLinkTokenWhereInput
  }

  /**
   * MagicLinkToken upsert
   */
  export type MagicLinkTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the MagicLinkToken to update in case it exists.
     */
    where: MagicLinkTokenWhereUniqueInput
    /**
     * In case the MagicLinkToken found by the `where` argument doesn't exist, create a new MagicLinkToken with this data.
     */
    create: XOR<MagicLinkTokenCreateInput, MagicLinkTokenUncheckedCreateInput>
    /**
     * In case the MagicLinkToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicLinkTokenUpdateInput, MagicLinkTokenUncheckedUpdateInput>
  }

  /**
   * MagicLinkToken delete
   */
  export type MagicLinkTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
    /**
     * Filter which MagicLinkToken to delete.
     */
    where: MagicLinkTokenWhereUniqueInput
  }

  /**
   * MagicLinkToken deleteMany
   */
  export type MagicLinkTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicLinkTokens to delete
     */
    where?: MagicLinkTokenWhereInput
  }

  /**
   * MagicLinkToken without action
   */
  export type MagicLinkTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicLinkToken
     */
    select?: MagicLinkTokenSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    city: 'city',
    academicYear: 'academicYear',
    brandColor: 'brandColor',
    accentColor: 'accentColor',
    tagline: 'tagline',
    logoUrl: 'logoUrl',
    logoIconUrl: 'logoIconUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    schoolId: 'schoolId',
    googleId: 'googleId',
    microsoftId: 'microsoftId',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const ChildScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    classId: 'classId'
  };

  export type ChildScalarFieldEnum = (typeof ChildScalarFieldEnum)[keyof typeof ChildScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    externalId: 'externalId',
    schoolId: 'schoolId',
    classId: 'classId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ParentStudentLinkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentId: 'studentId',
    createdAt: 'createdAt'
  };

  export type ParentStudentLinkScalarFieldEnum = (typeof ParentStudentLinkScalarFieldEnum)[keyof typeof ParentStudentLinkScalarFieldEnum]


  export const StudentInvitationLinkScalarFieldEnum: {
    id: 'id',
    invitationId: 'invitationId',
    studentId: 'studentId'
  };

  export type StudentInvitationLinkScalarFieldEnum = (typeof StudentInvitationLinkScalarFieldEnum)[keyof typeof StudentInvitationLinkScalarFieldEnum]


  export const YearGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YearGroupScalarFieldEnum = (typeof YearGroupScalarFieldEnum)[keyof typeof YearGroupScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    colorBg: 'colorBg',
    colorText: 'colorText',
    schoolId: 'schoolId',
    yearGroupId: 'yearGroupId'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const StaffClassAssignmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    classId: 'classId',
    createdAt: 'createdAt'
  };

  export type StaffClassAssignmentScalarFieldEnum = (typeof StaffClassAssignmentScalarFieldEnum)[keyof typeof StaffClassAssignmentScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    targetClass: 'targetClass',
    classId: 'classId',
    yearGroupId: 'yearGroupId',
    schoolId: 'schoolId',
    senderId: 'senderId',
    senderName: 'senderName',
    actionType: 'actionType',
    actionLabel: 'actionLabel',
    actionDueDate: 'actionDueDate',
    actionAmount: 'actionAmount',
    isPinned: 'isPinned',
    isUrgent: 'isUrgent',
    expiresAt: 'expiresAt',
    formId: 'formId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageAcknowledgmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type MessageAcknowledgmentScalarFieldEnum = (typeof MessageAcknowledgmentScalarFieldEnum)[keyof typeof MessageAcknowledgmentScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time',
    location: 'location',
    targetClass: 'targetClass',
    classId: 'classId',
    yearGroupId: 'yearGroupId',
    schoolId: 'schoolId',
    requiresRsvp: 'requiresRsvp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventRsvpScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type EventRsvpScalarFieldEnum = (typeof EventRsvpScalarFieldEnum)[keyof typeof EventRsvpScalarFieldEnum]


  export const TermDateScalarFieldEnum: {
    id: 'id',
    term: 'term',
    termName: 'termName',
    label: 'label',
    sublabel: 'sublabel',
    date: 'date',
    endDate: 'endDate',
    type: 'type',
    color: 'color',
    schoolId: 'schoolId'
  };

  export type TermDateScalarFieldEnum = (typeof TermDateScalarFieldEnum)[keyof typeof TermDateScalarFieldEnum]


  export const ScheduleItemScalarFieldEnum: {
    id: 'id',
    targetClass: 'targetClass',
    classId: 'classId',
    yearGroupId: 'yearGroupId',
    schoolId: 'schoolId',
    isRecurring: 'isRecurring',
    dayOfWeek: 'dayOfWeek',
    active: 'active',
    date: 'date',
    type: 'type',
    label: 'label',
    description: 'description',
    icon: 'icon',
    createdAt: 'createdAt'
  };

  export type ScheduleItemScalarFieldEnum = (typeof ScheduleItemScalarFieldEnum)[keyof typeof ScheduleItemScalarFieldEnum]


  export const WeeklyMessageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    weekOf: 'weekOf',
    isCurrent: 'isCurrent',
    schoolId: 'schoolId',
    createdAt: 'createdAt'
  };

  export type WeeklyMessageScalarFieldEnum = (typeof WeeklyMessageScalarFieldEnum)[keyof typeof WeeklyMessageScalarFieldEnum]


  export const WeeklyMessageHeartScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type WeeklyMessageHeartScalarFieldEnum = (typeof WeeklyMessageHeartScalarFieldEnum)[keyof typeof WeeklyMessageHeartScalarFieldEnum]


  export const KnowledgeCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    color: 'color',
    order: 'order',
    schoolId: 'schoolId'
  };

  export type KnowledgeCategoryScalarFieldEnum = (typeof KnowledgeCategoryScalarFieldEnum)[keyof typeof KnowledgeCategoryScalarFieldEnum]


  export const KnowledgeArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    categoryId: 'categoryId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type KnowledgeArticleScalarFieldEnum = (typeof KnowledgeArticleScalarFieldEnum)[keyof typeof KnowledgeArticleScalarFieldEnum]


  export const PulseSurveyScalarFieldEnum: {
    id: 'id',
    halfTermName: 'halfTermName',
    status: 'status',
    opensAt: 'opensAt',
    closesAt: 'closesAt',
    additionalQuestionKey: 'additionalQuestionKey',
    schoolId: 'schoolId',
    createdAt: 'createdAt'
  };

  export type PulseSurveyScalarFieldEnum = (typeof PulseSurveyScalarFieldEnum)[keyof typeof PulseSurveyScalarFieldEnum]


  export const PulseResponseScalarFieldEnum: {
    id: 'id',
    pulseId: 'pulseId',
    userId: 'userId',
    answers: 'answers',
    createdAt: 'createdAt'
  };

  export type PulseResponseScalarFieldEnum = (typeof PulseResponseScalarFieldEnum)[keyof typeof PulseResponseScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fileUrl: 'fileUrl',
    fileSize: 'fileSize',
    schoolId: 'schoolId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const FileFolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    color: 'color',
    parentId: 'parentId',
    schoolId: 'schoolId',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type FileFolderScalarFieldEnum = (typeof FileFolderScalarFieldEnum)[keyof typeof FileFolderScalarFieldEnum]


  export const SchoolFileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    folderId: 'folderId',
    schoolId: 'schoolId',
    uploadedAt: 'uploadedAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolFileScalarFieldEnum = (typeof SchoolFileScalarFieldEnum)[keyof typeof SchoolFileScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    fields: 'fields',
    targetClass: 'targetClass',
    classIds: 'classIds',
    yearGroupIds: 'yearGroupIds',
    schoolId: 'schoolId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const FormResponseScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    userId: 'userId',
    answers: 'answers',
    createdAt: 'createdAt'
  };

  export type FormResponseScalarFieldEnum = (typeof FormResponseScalarFieldEnum)[keyof typeof FormResponseScalarFieldEnum]


  export const ParentInvitationScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    accessCode: 'accessCode',
    magicToken: 'magicToken',
    parentEmail: 'parentEmail',
    parentName: 'parentName',
    status: 'status',
    expiresAt: 'expiresAt',
    redeemedAt: 'redeemedAt',
    redeemedByUserId: 'redeemedByUserId',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type ParentInvitationScalarFieldEnum = (typeof ParentInvitationScalarFieldEnum)[keyof typeof ParentInvitationScalarFieldEnum]


  export const ChildInvitationLinkScalarFieldEnum: {
    id: 'id',
    invitationId: 'invitationId',
    childName: 'childName',
    classId: 'classId'
  };

  export type ChildInvitationLinkScalarFieldEnum = (typeof ChildInvitationLinkScalarFieldEnum)[keyof typeof ChildInvitationLinkScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    action: 'action',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    metadata: 'metadata',
    schoolId: 'schoolId',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    body: 'body',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    data: 'data',
    read: 'read',
    schoolId: 'schoolId',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DeviceTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    platform: 'platform',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceTokenScalarFieldEnum = (typeof DeviceTokenScalarFieldEnum)[keyof typeof DeviceTokenScalarFieldEnum]


  export const MagicLinkTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    email: 'email',
    schoolId: 'schoolId',
    type: 'type',
    invitationId: 'invitationId',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type MagicLinkTokenScalarFieldEnum = (typeof MagicLinkTokenScalarFieldEnum)[keyof typeof MagicLinkTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'AuditResourceType'
   */
  export type EnumAuditResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditResourceType'>
    


  /**
   * Reference to a field of type 'AuditResourceType[]'
   */
  export type ListEnumAuditResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditResourceType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    shortName?: StringFilter<"School"> | string
    city?: StringFilter<"School"> | string
    academicYear?: StringFilter<"School"> | string
    brandColor?: StringFilter<"School"> | string
    accentColor?: StringFilter<"School"> | string
    tagline?: StringNullableFilter<"School"> | string | null
    logoUrl?: StringNullableFilter<"School"> | string | null
    logoIconUrl?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    yearGroups?: YearGroupListRelationFilter
    classes?: ClassListRelationFilter
    students?: StudentListRelationFilter
    messages?: MessageListRelationFilter
    forms?: FormListRelationFilter
    events?: EventListRelationFilter
    termDates?: TermDateListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
    weeklyMessages?: WeeklyMessageListRelationFilter
    knowledgeCategories?: KnowledgeCategoryListRelationFilter
    pulseSurveys?: PulseSurveyListRelationFilter
    policies?: PolicyListRelationFilter
    folders?: FileFolderListRelationFilter
    files?: SchoolFileListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    invitations?: ParentInvitationListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    logoIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    yearGroups?: YearGroupOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    forms?: FormOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    termDates?: TermDateOrderByRelationAggregateInput
    scheduleItems?: ScheduleItemOrderByRelationAggregateInput
    weeklyMessages?: WeeklyMessageOrderByRelationAggregateInput
    knowledgeCategories?: KnowledgeCategoryOrderByRelationAggregateInput
    pulseSurveys?: PulseSurveyOrderByRelationAggregateInput
    policies?: PolicyOrderByRelationAggregateInput
    folders?: FileFolderOrderByRelationAggregateInput
    files?: SchoolFileOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    invitations?: ParentInvitationOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    shortName?: StringFilter<"School"> | string
    city?: StringFilter<"School"> | string
    academicYear?: StringFilter<"School"> | string
    brandColor?: StringFilter<"School"> | string
    accentColor?: StringFilter<"School"> | string
    tagline?: StringNullableFilter<"School"> | string | null
    logoUrl?: StringNullableFilter<"School"> | string | null
    logoIconUrl?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    yearGroups?: YearGroupListRelationFilter
    classes?: ClassListRelationFilter
    students?: StudentListRelationFilter
    messages?: MessageListRelationFilter
    forms?: FormListRelationFilter
    events?: EventListRelationFilter
    termDates?: TermDateListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
    weeklyMessages?: WeeklyMessageListRelationFilter
    knowledgeCategories?: KnowledgeCategoryListRelationFilter
    pulseSurveys?: PulseSurveyListRelationFilter
    policies?: PolicyListRelationFilter
    folders?: FileFolderListRelationFilter
    files?: SchoolFileListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    invitations?: ParentInvitationListRelationFilter
  }, "id">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    logoIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    shortName?: StringWithAggregatesFilter<"School"> | string
    city?: StringWithAggregatesFilter<"School"> | string
    academicYear?: StringWithAggregatesFilter<"School"> | string
    brandColor?: StringWithAggregatesFilter<"School"> | string
    accentColor?: StringWithAggregatesFilter<"School"> | string
    tagline?: StringNullableWithAggregatesFilter<"School"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"School"> | string | null
    logoIconUrl?: StringNullableWithAggregatesFilter<"School"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    googleId?: StringNullableFilter<"User"> | string | null
    microsoftId?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    children?: ChildListRelationFilter
    studentLinks?: ParentStudentLinkListRelationFilter
    assignedClasses?: StaffClassAssignmentListRelationFilter
    sentMessages?: MessageListRelationFilter
    messageAcks?: MessageAcknowledgmentListRelationFilter
    formResponses?: FormResponseListRelationFilter
    eventRsvps?: EventRsvpListRelationFilter
    pulseResponses?: PulseResponseListRelationFilter
    weeklyHearts?: WeeklyMessageHeartListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    createdInvitations?: ParentInvitationListRelationFilter
    redeemedInvitations?: ParentInvitationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrderInput | SortOrder
    microsoftId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    children?: ChildOrderByRelationAggregateInput
    studentLinks?: ParentStudentLinkOrderByRelationAggregateInput
    assignedClasses?: StaffClassAssignmentOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    messageAcks?: MessageAcknowledgmentOrderByRelationAggregateInput
    formResponses?: FormResponseOrderByRelationAggregateInput
    eventRsvps?: EventRsvpOrderByRelationAggregateInput
    pulseResponses?: PulseResponseOrderByRelationAggregateInput
    weeklyHearts?: WeeklyMessageHeartOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    deviceTokens?: DeviceTokenOrderByRelationAggregateInput
    createdInvitations?: ParentInvitationOrderByRelationAggregateInput
    redeemedInvitations?: ParentInvitationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    microsoftId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    children?: ChildListRelationFilter
    studentLinks?: ParentStudentLinkListRelationFilter
    assignedClasses?: StaffClassAssignmentListRelationFilter
    sentMessages?: MessageListRelationFilter
    messageAcks?: MessageAcknowledgmentListRelationFilter
    formResponses?: FormResponseListRelationFilter
    eventRsvps?: EventRsvpListRelationFilter
    pulseResponses?: PulseResponseListRelationFilter
    weeklyHearts?: WeeklyMessageHeartListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    createdInvitations?: ParentInvitationListRelationFilter
    redeemedInvitations?: ParentInvitationListRelationFilter
  }, "id" | "email" | "googleId" | "microsoftId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrderInput | SortOrder
    microsoftId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    schoolId?: StringWithAggregatesFilter<"User"> | string
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    microsoftId?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type ChildWhereInput = {
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    id?: StringFilter<"Child"> | string
    name?: StringFilter<"Child"> | string
    parentId?: StringFilter<"Child"> | string
    classId?: StringFilter<"Child"> | string
    parent?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type ChildOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
    parent?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type ChildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    name?: StringFilter<"Child"> | string
    parentId?: StringFilter<"Child"> | string
    classId?: StringFilter<"Child"> | string
    parent?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "id">

  export type ChildOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
    _count?: ChildCountOrderByAggregateInput
    _max?: ChildMaxOrderByAggregateInput
    _min?: ChildMinOrderByAggregateInput
  }

  export type ChildScalarWhereWithAggregatesInput = {
    AND?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    OR?: ChildScalarWhereWithAggregatesInput[]
    NOT?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Child"> | string
    name?: StringWithAggregatesFilter<"Child"> | string
    parentId?: StringWithAggregatesFilter<"Child"> | string
    classId?: StringWithAggregatesFilter<"Child"> | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    externalId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    classId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    parentLinks?: ParentStudentLinkListRelationFilter
    invitationLinks?: StudentInvitationLinkListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    externalId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    parentLinks?: ParentStudentLinkOrderByRelationAggregateInput
    invitationLinks?: StudentInvitationLinkOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_externalId?: StudentSchoolIdExternalIdCompoundUniqueInput
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    externalId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    classId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    parentLinks?: ParentStudentLinkListRelationFilter
    invitationLinks?: StudentInvitationLinkListRelationFilter
  }, "id" | "schoolId_externalId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    externalId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    externalId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    schoolId?: StringWithAggregatesFilter<"Student"> | string
    classId?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ParentStudentLinkWhereInput = {
    AND?: ParentStudentLinkWhereInput | ParentStudentLinkWhereInput[]
    OR?: ParentStudentLinkWhereInput[]
    NOT?: ParentStudentLinkWhereInput | ParentStudentLinkWhereInput[]
    id?: StringFilter<"ParentStudentLink"> | string
    userId?: StringFilter<"ParentStudentLink"> | string
    studentId?: StringFilter<"ParentStudentLink"> | string
    createdAt?: DateTimeFilter<"ParentStudentLink"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type ParentStudentLinkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type ParentStudentLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_studentId?: ParentStudentLinkUserIdStudentIdCompoundUniqueInput
    AND?: ParentStudentLinkWhereInput | ParentStudentLinkWhereInput[]
    OR?: ParentStudentLinkWhereInput[]
    NOT?: ParentStudentLinkWhereInput | ParentStudentLinkWhereInput[]
    userId?: StringFilter<"ParentStudentLink"> | string
    studentId?: StringFilter<"ParentStudentLink"> | string
    createdAt?: DateTimeFilter<"ParentStudentLink"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "userId_studentId">

  export type ParentStudentLinkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    _count?: ParentStudentLinkCountOrderByAggregateInput
    _max?: ParentStudentLinkMaxOrderByAggregateInput
    _min?: ParentStudentLinkMinOrderByAggregateInput
  }

  export type ParentStudentLinkScalarWhereWithAggregatesInput = {
    AND?: ParentStudentLinkScalarWhereWithAggregatesInput | ParentStudentLinkScalarWhereWithAggregatesInput[]
    OR?: ParentStudentLinkScalarWhereWithAggregatesInput[]
    NOT?: ParentStudentLinkScalarWhereWithAggregatesInput | ParentStudentLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParentStudentLink"> | string
    userId?: StringWithAggregatesFilter<"ParentStudentLink"> | string
    studentId?: StringWithAggregatesFilter<"ParentStudentLink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParentStudentLink"> | Date | string
  }

  export type StudentInvitationLinkWhereInput = {
    AND?: StudentInvitationLinkWhereInput | StudentInvitationLinkWhereInput[]
    OR?: StudentInvitationLinkWhereInput[]
    NOT?: StudentInvitationLinkWhereInput | StudentInvitationLinkWhereInput[]
    id?: StringFilter<"StudentInvitationLink"> | string
    invitationId?: StringFilter<"StudentInvitationLink"> | string
    studentId?: StringFilter<"StudentInvitationLink"> | string
    invitation?: XOR<ParentInvitationRelationFilter, ParentInvitationWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type StudentInvitationLinkOrderByWithRelationInput = {
    id?: SortOrder
    invitationId?: SortOrder
    studentId?: SortOrder
    invitation?: ParentInvitationOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type StudentInvitationLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invitationId_studentId?: StudentInvitationLinkInvitationIdStudentIdCompoundUniqueInput
    AND?: StudentInvitationLinkWhereInput | StudentInvitationLinkWhereInput[]
    OR?: StudentInvitationLinkWhereInput[]
    NOT?: StudentInvitationLinkWhereInput | StudentInvitationLinkWhereInput[]
    invitationId?: StringFilter<"StudentInvitationLink"> | string
    studentId?: StringFilter<"StudentInvitationLink"> | string
    invitation?: XOR<ParentInvitationRelationFilter, ParentInvitationWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "invitationId_studentId">

  export type StudentInvitationLinkOrderByWithAggregationInput = {
    id?: SortOrder
    invitationId?: SortOrder
    studentId?: SortOrder
    _count?: StudentInvitationLinkCountOrderByAggregateInput
    _max?: StudentInvitationLinkMaxOrderByAggregateInput
    _min?: StudentInvitationLinkMinOrderByAggregateInput
  }

  export type StudentInvitationLinkScalarWhereWithAggregatesInput = {
    AND?: StudentInvitationLinkScalarWhereWithAggregatesInput | StudentInvitationLinkScalarWhereWithAggregatesInput[]
    OR?: StudentInvitationLinkScalarWhereWithAggregatesInput[]
    NOT?: StudentInvitationLinkScalarWhereWithAggregatesInput | StudentInvitationLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentInvitationLink"> | string
    invitationId?: StringWithAggregatesFilter<"StudentInvitationLink"> | string
    studentId?: StringWithAggregatesFilter<"StudentInvitationLink"> | string
  }

  export type YearGroupWhereInput = {
    AND?: YearGroupWhereInput | YearGroupWhereInput[]
    OR?: YearGroupWhereInput[]
    NOT?: YearGroupWhereInput | YearGroupWhereInput[]
    id?: StringFilter<"YearGroup"> | string
    name?: StringFilter<"YearGroup"> | string
    order?: IntFilter<"YearGroup"> | number
    schoolId?: StringFilter<"YearGroup"> | string
    createdAt?: DateTimeFilter<"YearGroup"> | Date | string
    updatedAt?: DateTimeFilter<"YearGroup"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    classes?: ClassListRelationFilter
    messages?: MessageListRelationFilter
    events?: EventListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
  }

  export type YearGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    classes?: ClassOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    scheduleItems?: ScheduleItemOrderByRelationAggregateInput
  }

  export type YearGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: YearGroupSchoolIdNameCompoundUniqueInput
    AND?: YearGroupWhereInput | YearGroupWhereInput[]
    OR?: YearGroupWhereInput[]
    NOT?: YearGroupWhereInput | YearGroupWhereInput[]
    name?: StringFilter<"YearGroup"> | string
    order?: IntFilter<"YearGroup"> | number
    schoolId?: StringFilter<"YearGroup"> | string
    createdAt?: DateTimeFilter<"YearGroup"> | Date | string
    updatedAt?: DateTimeFilter<"YearGroup"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    classes?: ClassListRelationFilter
    messages?: MessageListRelationFilter
    events?: EventListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
  }, "id" | "schoolId_name">

  export type YearGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YearGroupCountOrderByAggregateInput
    _avg?: YearGroupAvgOrderByAggregateInput
    _max?: YearGroupMaxOrderByAggregateInput
    _min?: YearGroupMinOrderByAggregateInput
    _sum?: YearGroupSumOrderByAggregateInput
  }

  export type YearGroupScalarWhereWithAggregatesInput = {
    AND?: YearGroupScalarWhereWithAggregatesInput | YearGroupScalarWhereWithAggregatesInput[]
    OR?: YearGroupScalarWhereWithAggregatesInput[]
    NOT?: YearGroupScalarWhereWithAggregatesInput | YearGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"YearGroup"> | string
    name?: StringWithAggregatesFilter<"YearGroup"> | string
    order?: IntWithAggregatesFilter<"YearGroup"> | number
    schoolId?: StringWithAggregatesFilter<"YearGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"YearGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearGroup"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    colorBg?: StringFilter<"Class"> | string
    colorText?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    yearGroupId?: StringNullableFilter<"Class"> | string | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    children?: ChildListRelationFilter
    students?: StudentListRelationFilter
    messages?: MessageListRelationFilter
    events?: EventListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
    assignedStaff?: StaffClassAssignmentListRelationFilter
    childInvitationLinks?: ChildInvitationLinkListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    school?: SchoolOrderByWithRelationInput
    yearGroup?: YearGroupOrderByWithRelationInput
    children?: ChildOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    scheduleItems?: ScheduleItemOrderByRelationAggregateInput
    assignedStaff?: StaffClassAssignmentOrderByRelationAggregateInput
    childInvitationLinks?: ChildInvitationLinkOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: ClassSchoolIdNameCompoundUniqueInput
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    colorBg?: StringFilter<"Class"> | string
    colorText?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    yearGroupId?: StringNullableFilter<"Class"> | string | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    children?: ChildListRelationFilter
    students?: StudentListRelationFilter
    messages?: MessageListRelationFilter
    events?: EventListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
    assignedStaff?: StaffClassAssignmentListRelationFilter
    childInvitationLinks?: ChildInvitationLinkListRelationFilter
  }, "id" | "schoolId_name">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    colorBg?: StringWithAggregatesFilter<"Class"> | string
    colorText?: StringWithAggregatesFilter<"Class"> | string
    schoolId?: StringWithAggregatesFilter<"Class"> | string
    yearGroupId?: StringNullableWithAggregatesFilter<"Class"> | string | null
  }

  export type StaffClassAssignmentWhereInput = {
    AND?: StaffClassAssignmentWhereInput | StaffClassAssignmentWhereInput[]
    OR?: StaffClassAssignmentWhereInput[]
    NOT?: StaffClassAssignmentWhereInput | StaffClassAssignmentWhereInput[]
    id?: StringFilter<"StaffClassAssignment"> | string
    userId?: StringFilter<"StaffClassAssignment"> | string
    classId?: StringFilter<"StaffClassAssignment"> | string
    createdAt?: DateTimeFilter<"StaffClassAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type StaffClassAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type StaffClassAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_classId?: StaffClassAssignmentUserIdClassIdCompoundUniqueInput
    AND?: StaffClassAssignmentWhereInput | StaffClassAssignmentWhereInput[]
    OR?: StaffClassAssignmentWhereInput[]
    NOT?: StaffClassAssignmentWhereInput | StaffClassAssignmentWhereInput[]
    userId?: StringFilter<"StaffClassAssignment"> | string
    classId?: StringFilter<"StaffClassAssignment"> | string
    createdAt?: DateTimeFilter<"StaffClassAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "id" | "userId_classId">

  export type StaffClassAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    _count?: StaffClassAssignmentCountOrderByAggregateInput
    _max?: StaffClassAssignmentMaxOrderByAggregateInput
    _min?: StaffClassAssignmentMinOrderByAggregateInput
  }

  export type StaffClassAssignmentScalarWhereWithAggregatesInput = {
    AND?: StaffClassAssignmentScalarWhereWithAggregatesInput | StaffClassAssignmentScalarWhereWithAggregatesInput[]
    OR?: StaffClassAssignmentScalarWhereWithAggregatesInput[]
    NOT?: StaffClassAssignmentScalarWhereWithAggregatesInput | StaffClassAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffClassAssignment"> | string
    userId?: StringWithAggregatesFilter<"StaffClassAssignment"> | string
    classId?: StringWithAggregatesFilter<"StaffClassAssignment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StaffClassAssignment"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    title?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    targetClass?: StringFilter<"Message"> | string
    classId?: StringNullableFilter<"Message"> | string | null
    yearGroupId?: StringNullableFilter<"Message"> | string | null
    schoolId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderName?: StringFilter<"Message"> | string
    actionType?: StringNullableFilter<"Message"> | string | null
    actionLabel?: StringNullableFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    isUrgent?: BoolFilter<"Message"> | boolean
    expiresAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    formId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    form?: XOR<FormNullableRelationFilter, FormWhereInput> | null
    acknowledgments?: MessageAcknowledgmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    actionDueDate?: SortOrderInput | SortOrder
    actionAmount?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    formId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    yearGroup?: YearGroupOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    form?: FormOrderByWithRelationInput
    acknowledgments?: MessageAcknowledgmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    formId?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    title?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    targetClass?: StringFilter<"Message"> | string
    classId?: StringNullableFilter<"Message"> | string | null
    yearGroupId?: StringNullableFilter<"Message"> | string | null
    schoolId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderName?: StringFilter<"Message"> | string
    actionType?: StringNullableFilter<"Message"> | string | null
    actionLabel?: StringNullableFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    isUrgent?: BoolFilter<"Message"> | boolean
    expiresAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    form?: XOR<FormNullableRelationFilter, FormWhereInput> | null
    acknowledgments?: MessageAcknowledgmentListRelationFilter
  }, "id" | "formId">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    actionDueDate?: SortOrderInput | SortOrder
    actionAmount?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    formId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    title?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    targetClass?: StringWithAggregatesFilter<"Message"> | string
    classId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    yearGroupId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    schoolId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    senderName?: StringWithAggregatesFilter<"Message"> | string
    actionType?: StringNullableWithAggregatesFilter<"Message"> | string | null
    actionLabel?: StringNullableWithAggregatesFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableWithAggregatesFilter<"Message"> | string | null
    isPinned?: BoolWithAggregatesFilter<"Message"> | boolean
    isUrgent?: BoolWithAggregatesFilter<"Message"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    formId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type MessageAcknowledgmentWhereInput = {
    AND?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    OR?: MessageAcknowledgmentWhereInput[]
    NOT?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    id?: StringFilter<"MessageAcknowledgment"> | string
    messageId?: StringFilter<"MessageAcknowledgment"> | string
    userId?: StringFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeFilter<"MessageAcknowledgment"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageAcknowledgmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageAcknowledgmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageAcknowledgmentMessageIdUserIdCompoundUniqueInput
    AND?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    OR?: MessageAcknowledgmentWhereInput[]
    NOT?: MessageAcknowledgmentWhereInput | MessageAcknowledgmentWhereInput[]
    messageId?: StringFilter<"MessageAcknowledgment"> | string
    userId?: StringFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeFilter<"MessageAcknowledgment"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId">

  export type MessageAcknowledgmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: MessageAcknowledgmentCountOrderByAggregateInput
    _max?: MessageAcknowledgmentMaxOrderByAggregateInput
    _min?: MessageAcknowledgmentMinOrderByAggregateInput
  }

  export type MessageAcknowledgmentScalarWhereWithAggregatesInput = {
    AND?: MessageAcknowledgmentScalarWhereWithAggregatesInput | MessageAcknowledgmentScalarWhereWithAggregatesInput[]
    OR?: MessageAcknowledgmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAcknowledgmentScalarWhereWithAggregatesInput | MessageAcknowledgmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAcknowledgment"> | string
    messageId?: StringWithAggregatesFilter<"MessageAcknowledgment"> | string
    userId?: StringWithAggregatesFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageAcknowledgment"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    targetClass?: StringFilter<"Event"> | string
    classId?: StringNullableFilter<"Event"> | string | null
    yearGroupId?: StringNullableFilter<"Event"> | string | null
    schoolId?: StringFilter<"Event"> | string
    requiresRsvp?: BoolFilter<"Event"> | boolean
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    rsvps?: EventRsvpListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    yearGroup?: YearGroupOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    rsvps?: EventRsvpOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    targetClass?: StringFilter<"Event"> | string
    classId?: StringNullableFilter<"Event"> | string | null
    yearGroupId?: StringNullableFilter<"Event"> | string | null
    schoolId?: StringFilter<"Event"> | string
    requiresRsvp?: BoolFilter<"Event"> | boolean
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    rsvps?: EventRsvpListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    time?: StringNullableWithAggregatesFilter<"Event"> | string | null
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    targetClass?: StringWithAggregatesFilter<"Event"> | string
    classId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    yearGroupId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    schoolId?: StringWithAggregatesFilter<"Event"> | string
    requiresRsvp?: BoolWithAggregatesFilter<"Event"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventRsvpWhereInput = {
    AND?: EventRsvpWhereInput | EventRsvpWhereInput[]
    OR?: EventRsvpWhereInput[]
    NOT?: EventRsvpWhereInput | EventRsvpWhereInput[]
    id?: StringFilter<"EventRsvp"> | string
    eventId?: StringFilter<"EventRsvp"> | string
    userId?: StringFilter<"EventRsvp"> | string
    status?: StringFilter<"EventRsvp"> | string
    createdAt?: DateTimeFilter<"EventRsvp"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EventRsvpOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventRsvpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventRsvpEventIdUserIdCompoundUniqueInput
    AND?: EventRsvpWhereInput | EventRsvpWhereInput[]
    OR?: EventRsvpWhereInput[]
    NOT?: EventRsvpWhereInput | EventRsvpWhereInput[]
    eventId?: StringFilter<"EventRsvp"> | string
    userId?: StringFilter<"EventRsvp"> | string
    status?: StringFilter<"EventRsvp"> | string
    createdAt?: DateTimeFilter<"EventRsvp"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "eventId_userId">

  export type EventRsvpOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: EventRsvpCountOrderByAggregateInput
    _max?: EventRsvpMaxOrderByAggregateInput
    _min?: EventRsvpMinOrderByAggregateInput
  }

  export type EventRsvpScalarWhereWithAggregatesInput = {
    AND?: EventRsvpScalarWhereWithAggregatesInput | EventRsvpScalarWhereWithAggregatesInput[]
    OR?: EventRsvpScalarWhereWithAggregatesInput[]
    NOT?: EventRsvpScalarWhereWithAggregatesInput | EventRsvpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventRsvp"> | string
    eventId?: StringWithAggregatesFilter<"EventRsvp"> | string
    userId?: StringWithAggregatesFilter<"EventRsvp"> | string
    status?: StringWithAggregatesFilter<"EventRsvp"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventRsvp"> | Date | string
  }

  export type TermDateWhereInput = {
    AND?: TermDateWhereInput | TermDateWhereInput[]
    OR?: TermDateWhereInput[]
    NOT?: TermDateWhereInput | TermDateWhereInput[]
    id?: StringFilter<"TermDate"> | string
    term?: IntFilter<"TermDate"> | number
    termName?: StringFilter<"TermDate"> | string
    label?: StringFilter<"TermDate"> | string
    sublabel?: StringNullableFilter<"TermDate"> | string | null
    date?: DateTimeFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableFilter<"TermDate"> | Date | string | null
    type?: StringFilter<"TermDate"> | string
    color?: StringFilter<"TermDate"> | string
    schoolId?: StringFilter<"TermDate"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type TermDateOrderByWithRelationInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrderInput | SortOrder
    date?: SortOrder
    endDate?: SortOrderInput | SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type TermDateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TermDateWhereInput | TermDateWhereInput[]
    OR?: TermDateWhereInput[]
    NOT?: TermDateWhereInput | TermDateWhereInput[]
    term?: IntFilter<"TermDate"> | number
    termName?: StringFilter<"TermDate"> | string
    label?: StringFilter<"TermDate"> | string
    sublabel?: StringNullableFilter<"TermDate"> | string | null
    date?: DateTimeFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableFilter<"TermDate"> | Date | string | null
    type?: StringFilter<"TermDate"> | string
    color?: StringFilter<"TermDate"> | string
    schoolId?: StringFilter<"TermDate"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type TermDateOrderByWithAggregationInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrderInput | SortOrder
    date?: SortOrder
    endDate?: SortOrderInput | SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
    _count?: TermDateCountOrderByAggregateInput
    _avg?: TermDateAvgOrderByAggregateInput
    _max?: TermDateMaxOrderByAggregateInput
    _min?: TermDateMinOrderByAggregateInput
    _sum?: TermDateSumOrderByAggregateInput
  }

  export type TermDateScalarWhereWithAggregatesInput = {
    AND?: TermDateScalarWhereWithAggregatesInput | TermDateScalarWhereWithAggregatesInput[]
    OR?: TermDateScalarWhereWithAggregatesInput[]
    NOT?: TermDateScalarWhereWithAggregatesInput | TermDateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TermDate"> | string
    term?: IntWithAggregatesFilter<"TermDate"> | number
    termName?: StringWithAggregatesFilter<"TermDate"> | string
    label?: StringWithAggregatesFilter<"TermDate"> | string
    sublabel?: StringNullableWithAggregatesFilter<"TermDate"> | string | null
    date?: DateTimeWithAggregatesFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"TermDate"> | Date | string | null
    type?: StringWithAggregatesFilter<"TermDate"> | string
    color?: StringWithAggregatesFilter<"TermDate"> | string
    schoolId?: StringWithAggregatesFilter<"TermDate"> | string
  }

  export type ScheduleItemWhereInput = {
    AND?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    OR?: ScheduleItemWhereInput[]
    NOT?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    id?: StringFilter<"ScheduleItem"> | string
    targetClass?: StringFilter<"ScheduleItem"> | string
    classId?: StringNullableFilter<"ScheduleItem"> | string | null
    yearGroupId?: StringNullableFilter<"ScheduleItem"> | string | null
    schoolId?: StringFilter<"ScheduleItem"> | string
    isRecurring?: BoolFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableFilter<"ScheduleItem"> | number | null
    active?: BoolFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableFilter<"ScheduleItem"> | Date | string | null
    type?: StringFilter<"ScheduleItem"> | string
    label?: StringFilter<"ScheduleItem"> | string
    description?: StringNullableFilter<"ScheduleItem"> | string | null
    icon?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type ScheduleItemOrderByWithRelationInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    active?: SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    yearGroup?: YearGroupOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type ScheduleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    OR?: ScheduleItemWhereInput[]
    NOT?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    targetClass?: StringFilter<"ScheduleItem"> | string
    classId?: StringNullableFilter<"ScheduleItem"> | string | null
    yearGroupId?: StringNullableFilter<"ScheduleItem"> | string | null
    schoolId?: StringFilter<"ScheduleItem"> | string
    isRecurring?: BoolFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableFilter<"ScheduleItem"> | number | null
    active?: BoolFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableFilter<"ScheduleItem"> | Date | string | null
    type?: StringFilter<"ScheduleItem"> | string
    label?: StringFilter<"ScheduleItem"> | string
    description?: StringNullableFilter<"ScheduleItem"> | string | null
    icon?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    yearGroup?: XOR<YearGroupNullableRelationFilter, YearGroupWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type ScheduleItemOrderByWithAggregationInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrderInput | SortOrder
    yearGroupId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    active?: SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ScheduleItemCountOrderByAggregateInput
    _avg?: ScheduleItemAvgOrderByAggregateInput
    _max?: ScheduleItemMaxOrderByAggregateInput
    _min?: ScheduleItemMinOrderByAggregateInput
    _sum?: ScheduleItemSumOrderByAggregateInput
  }

  export type ScheduleItemScalarWhereWithAggregatesInput = {
    AND?: ScheduleItemScalarWhereWithAggregatesInput | ScheduleItemScalarWhereWithAggregatesInput[]
    OR?: ScheduleItemScalarWhereWithAggregatesInput[]
    NOT?: ScheduleItemScalarWhereWithAggregatesInput | ScheduleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleItem"> | string
    targetClass?: StringWithAggregatesFilter<"ScheduleItem"> | string
    classId?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    yearGroupId?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    schoolId?: StringWithAggregatesFilter<"ScheduleItem"> | string
    isRecurring?: BoolWithAggregatesFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableWithAggregatesFilter<"ScheduleItem"> | number | null
    active?: BoolWithAggregatesFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableWithAggregatesFilter<"ScheduleItem"> | Date | string | null
    type?: StringWithAggregatesFilter<"ScheduleItem"> | string
    label?: StringWithAggregatesFilter<"ScheduleItem"> | string
    description?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleItem"> | Date | string
  }

  export type WeeklyMessageWhereInput = {
    AND?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    OR?: WeeklyMessageWhereInput[]
    NOT?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    id?: StringFilter<"WeeklyMessage"> | string
    title?: StringFilter<"WeeklyMessage"> | string
    content?: StringFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolFilter<"WeeklyMessage"> | boolean
    schoolId?: StringFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeFilter<"WeeklyMessage"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    hearts?: WeeklyMessageHeartListRelationFilter
  }

  export type WeeklyMessageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    hearts?: WeeklyMessageHeartOrderByRelationAggregateInput
  }

  export type WeeklyMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    OR?: WeeklyMessageWhereInput[]
    NOT?: WeeklyMessageWhereInput | WeeklyMessageWhereInput[]
    title?: StringFilter<"WeeklyMessage"> | string
    content?: StringFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolFilter<"WeeklyMessage"> | boolean
    schoolId?: StringFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeFilter<"WeeklyMessage"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    hearts?: WeeklyMessageHeartListRelationFilter
  }, "id">

  export type WeeklyMessageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    _count?: WeeklyMessageCountOrderByAggregateInput
    _max?: WeeklyMessageMaxOrderByAggregateInput
    _min?: WeeklyMessageMinOrderByAggregateInput
  }

  export type WeeklyMessageScalarWhereWithAggregatesInput = {
    AND?: WeeklyMessageScalarWhereWithAggregatesInput | WeeklyMessageScalarWhereWithAggregatesInput[]
    OR?: WeeklyMessageScalarWhereWithAggregatesInput[]
    NOT?: WeeklyMessageScalarWhereWithAggregatesInput | WeeklyMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    title?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    content?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeWithAggregatesFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolWithAggregatesFilter<"WeeklyMessage"> | boolean
    schoolId?: StringWithAggregatesFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyMessage"> | Date | string
  }

  export type WeeklyMessageHeartWhereInput = {
    AND?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    OR?: WeeklyMessageHeartWhereInput[]
    NOT?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    id?: StringFilter<"WeeklyMessageHeart"> | string
    messageId?: StringFilter<"WeeklyMessageHeart"> | string
    userId?: StringFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeFilter<"WeeklyMessageHeart"> | Date | string
    message?: XOR<WeeklyMessageRelationFilter, WeeklyMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WeeklyMessageHeartOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    message?: WeeklyMessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WeeklyMessageHeartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: WeeklyMessageHeartMessageIdUserIdCompoundUniqueInput
    AND?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    OR?: WeeklyMessageHeartWhereInput[]
    NOT?: WeeklyMessageHeartWhereInput | WeeklyMessageHeartWhereInput[]
    messageId?: StringFilter<"WeeklyMessageHeart"> | string
    userId?: StringFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeFilter<"WeeklyMessageHeart"> | Date | string
    message?: XOR<WeeklyMessageRelationFilter, WeeklyMessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId">

  export type WeeklyMessageHeartOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: WeeklyMessageHeartCountOrderByAggregateInput
    _max?: WeeklyMessageHeartMaxOrderByAggregateInput
    _min?: WeeklyMessageHeartMinOrderByAggregateInput
  }

  export type WeeklyMessageHeartScalarWhereWithAggregatesInput = {
    AND?: WeeklyMessageHeartScalarWhereWithAggregatesInput | WeeklyMessageHeartScalarWhereWithAggregatesInput[]
    OR?: WeeklyMessageHeartScalarWhereWithAggregatesInput[]
    NOT?: WeeklyMessageHeartScalarWhereWithAggregatesInput | WeeklyMessageHeartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyMessageHeart"> | string
    messageId?: StringWithAggregatesFilter<"WeeklyMessageHeart"> | string
    userId?: StringWithAggregatesFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyMessageHeart"> | Date | string
  }

  export type KnowledgeCategoryWhereInput = {
    AND?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    OR?: KnowledgeCategoryWhereInput[]
    NOT?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    id?: StringFilter<"KnowledgeCategory"> | string
    name?: StringFilter<"KnowledgeCategory"> | string
    icon?: StringFilter<"KnowledgeCategory"> | string
    color?: StringFilter<"KnowledgeCategory"> | string
    order?: IntFilter<"KnowledgeCategory"> | number
    schoolId?: StringFilter<"KnowledgeCategory"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    articles?: KnowledgeArticleListRelationFilter
  }

  export type KnowledgeCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    school?: SchoolOrderByWithRelationInput
    articles?: KnowledgeArticleOrderByRelationAggregateInput
  }

  export type KnowledgeCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    OR?: KnowledgeCategoryWhereInput[]
    NOT?: KnowledgeCategoryWhereInput | KnowledgeCategoryWhereInput[]
    name?: StringFilter<"KnowledgeCategory"> | string
    icon?: StringFilter<"KnowledgeCategory"> | string
    color?: StringFilter<"KnowledgeCategory"> | string
    order?: IntFilter<"KnowledgeCategory"> | number
    schoolId?: StringFilter<"KnowledgeCategory"> | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    articles?: KnowledgeArticleListRelationFilter
  }, "id">

  export type KnowledgeCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    _count?: KnowledgeCategoryCountOrderByAggregateInput
    _avg?: KnowledgeCategoryAvgOrderByAggregateInput
    _max?: KnowledgeCategoryMaxOrderByAggregateInput
    _min?: KnowledgeCategoryMinOrderByAggregateInput
    _sum?: KnowledgeCategorySumOrderByAggregateInput
  }

  export type KnowledgeCategoryScalarWhereWithAggregatesInput = {
    AND?: KnowledgeCategoryScalarWhereWithAggregatesInput | KnowledgeCategoryScalarWhereWithAggregatesInput[]
    OR?: KnowledgeCategoryScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeCategoryScalarWhereWithAggregatesInput | KnowledgeCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    name?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    icon?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    color?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
    order?: IntWithAggregatesFilter<"KnowledgeCategory"> | number
    schoolId?: StringWithAggregatesFilter<"KnowledgeCategory"> | string
  }

  export type KnowledgeArticleWhereInput = {
    AND?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    OR?: KnowledgeArticleWhereInput[]
    NOT?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    id?: StringFilter<"KnowledgeArticle"> | string
    title?: StringFilter<"KnowledgeArticle"> | string
    content?: StringFilter<"KnowledgeArticle"> | string
    categoryId?: StringFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    category?: XOR<KnowledgeCategoryRelationFilter, KnowledgeCategoryWhereInput>
  }

  export type KnowledgeArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    category?: KnowledgeCategoryOrderByWithRelationInput
  }

  export type KnowledgeArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    OR?: KnowledgeArticleWhereInput[]
    NOT?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    title?: StringFilter<"KnowledgeArticle"> | string
    content?: StringFilter<"KnowledgeArticle"> | string
    categoryId?: StringFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    category?: XOR<KnowledgeCategoryRelationFilter, KnowledgeCategoryWhereInput>
  }, "id">

  export type KnowledgeArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: KnowledgeArticleCountOrderByAggregateInput
    _max?: KnowledgeArticleMaxOrderByAggregateInput
    _min?: KnowledgeArticleMinOrderByAggregateInput
  }

  export type KnowledgeArticleScalarWhereWithAggregatesInput = {
    AND?: KnowledgeArticleScalarWhereWithAggregatesInput | KnowledgeArticleScalarWhereWithAggregatesInput[]
    OR?: KnowledgeArticleScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeArticleScalarWhereWithAggregatesInput | KnowledgeArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    title?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    content?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    categoryId?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeArticle"> | Date | string
  }

  export type PulseSurveyWhereInput = {
    AND?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    OR?: PulseSurveyWhereInput[]
    NOT?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    id?: StringFilter<"PulseSurvey"> | string
    halfTermName?: StringFilter<"PulseSurvey"> | string
    status?: StringFilter<"PulseSurvey"> | string
    opensAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    additionalQuestionKey?: StringNullableFilter<"PulseSurvey"> | string | null
    schoolId?: StringFilter<"PulseSurvey"> | string
    createdAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    responses?: PulseResponseListRelationFilter
  }

  export type PulseSurveyOrderByWithRelationInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    additionalQuestionKey?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    responses?: PulseResponseOrderByRelationAggregateInput
  }

  export type PulseSurveyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    OR?: PulseSurveyWhereInput[]
    NOT?: PulseSurveyWhereInput | PulseSurveyWhereInput[]
    halfTermName?: StringFilter<"PulseSurvey"> | string
    status?: StringFilter<"PulseSurvey"> | string
    opensAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    additionalQuestionKey?: StringNullableFilter<"PulseSurvey"> | string | null
    schoolId?: StringFilter<"PulseSurvey"> | string
    createdAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    responses?: PulseResponseListRelationFilter
  }, "id">

  export type PulseSurveyOrderByWithAggregationInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    additionalQuestionKey?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    _count?: PulseSurveyCountOrderByAggregateInput
    _max?: PulseSurveyMaxOrderByAggregateInput
    _min?: PulseSurveyMinOrderByAggregateInput
  }

  export type PulseSurveyScalarWhereWithAggregatesInput = {
    AND?: PulseSurveyScalarWhereWithAggregatesInput | PulseSurveyScalarWhereWithAggregatesInput[]
    OR?: PulseSurveyScalarWhereWithAggregatesInput[]
    NOT?: PulseSurveyScalarWhereWithAggregatesInput | PulseSurveyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PulseSurvey"> | string
    halfTermName?: StringWithAggregatesFilter<"PulseSurvey"> | string
    status?: StringWithAggregatesFilter<"PulseSurvey"> | string
    opensAt?: DateTimeWithAggregatesFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeWithAggregatesFilter<"PulseSurvey"> | Date | string
    additionalQuestionKey?: StringNullableWithAggregatesFilter<"PulseSurvey"> | string | null
    schoolId?: StringWithAggregatesFilter<"PulseSurvey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PulseSurvey"> | Date | string
  }

  export type PulseResponseWhereInput = {
    AND?: PulseResponseWhereInput | PulseResponseWhereInput[]
    OR?: PulseResponseWhereInput[]
    NOT?: PulseResponseWhereInput | PulseResponseWhereInput[]
    id?: StringFilter<"PulseResponse"> | string
    pulseId?: StringFilter<"PulseResponse"> | string
    userId?: StringFilter<"PulseResponse"> | string
    answers?: JsonFilter<"PulseResponse">
    createdAt?: DateTimeFilter<"PulseResponse"> | Date | string
    pulse?: XOR<PulseSurveyRelationFilter, PulseSurveyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PulseResponseOrderByWithRelationInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    pulse?: PulseSurveyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PulseResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pulseId_userId?: PulseResponsePulseIdUserIdCompoundUniqueInput
    AND?: PulseResponseWhereInput | PulseResponseWhereInput[]
    OR?: PulseResponseWhereInput[]
    NOT?: PulseResponseWhereInput | PulseResponseWhereInput[]
    pulseId?: StringFilter<"PulseResponse"> | string
    userId?: StringFilter<"PulseResponse"> | string
    answers?: JsonFilter<"PulseResponse">
    createdAt?: DateTimeFilter<"PulseResponse"> | Date | string
    pulse?: XOR<PulseSurveyRelationFilter, PulseSurveyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "pulseId_userId">

  export type PulseResponseOrderByWithAggregationInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    _count?: PulseResponseCountOrderByAggregateInput
    _max?: PulseResponseMaxOrderByAggregateInput
    _min?: PulseResponseMinOrderByAggregateInput
  }

  export type PulseResponseScalarWhereWithAggregatesInput = {
    AND?: PulseResponseScalarWhereWithAggregatesInput | PulseResponseScalarWhereWithAggregatesInput[]
    OR?: PulseResponseScalarWhereWithAggregatesInput[]
    NOT?: PulseResponseScalarWhereWithAggregatesInput | PulseResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PulseResponse"> | string
    pulseId?: StringWithAggregatesFilter<"PulseResponse"> | string
    userId?: StringWithAggregatesFilter<"PulseResponse"> | string
    answers?: JsonWithAggregatesFilter<"PulseResponse">
    createdAt?: DateTimeWithAggregatesFilter<"PulseResponse"> | Date | string
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    id?: StringFilter<"Policy"> | string
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    fileUrl?: StringFilter<"Policy"> | string
    fileSize?: IntNullableFilter<"Policy"> | number | null
    schoolId?: StringFilter<"Policy"> | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    fileUrl?: StringFilter<"Policy"> | string
    fileSize?: IntNullableFilter<"Policy"> | number | null
    schoolId?: StringFilter<"Policy"> | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Policy"> | string
    name?: StringWithAggregatesFilter<"Policy"> | string
    description?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    fileUrl?: StringWithAggregatesFilter<"Policy"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Policy"> | number | null
    schoolId?: StringWithAggregatesFilter<"Policy"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
  }

  export type FileFolderWhereInput = {
    AND?: FileFolderWhereInput | FileFolderWhereInput[]
    OR?: FileFolderWhereInput[]
    NOT?: FileFolderWhereInput | FileFolderWhereInput[]
    id?: StringFilter<"FileFolder"> | string
    name?: StringFilter<"FileFolder"> | string
    icon?: StringNullableFilter<"FileFolder"> | string | null
    color?: StringNullableFilter<"FileFolder"> | string | null
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    schoolId?: StringFilter<"FileFolder"> | string
    order?: IntFilter<"FileFolder"> | number
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
    parent?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    children?: FileFolderListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    files?: SchoolFileListRelationFilter
  }

  export type FileFolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    parent?: FileFolderOrderByWithRelationInput
    children?: FileFolderOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
    files?: SchoolFileOrderByRelationAggregateInput
  }

  export type FileFolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileFolderWhereInput | FileFolderWhereInput[]
    OR?: FileFolderWhereInput[]
    NOT?: FileFolderWhereInput | FileFolderWhereInput[]
    name?: StringFilter<"FileFolder"> | string
    icon?: StringNullableFilter<"FileFolder"> | string | null
    color?: StringNullableFilter<"FileFolder"> | string | null
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    schoolId?: StringFilter<"FileFolder"> | string
    order?: IntFilter<"FileFolder"> | number
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
    parent?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    children?: FileFolderListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    files?: SchoolFileListRelationFilter
  }, "id">

  export type FileFolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: FileFolderCountOrderByAggregateInput
    _avg?: FileFolderAvgOrderByAggregateInput
    _max?: FileFolderMaxOrderByAggregateInput
    _min?: FileFolderMinOrderByAggregateInput
    _sum?: FileFolderSumOrderByAggregateInput
  }

  export type FileFolderScalarWhereWithAggregatesInput = {
    AND?: FileFolderScalarWhereWithAggregatesInput | FileFolderScalarWhereWithAggregatesInput[]
    OR?: FileFolderScalarWhereWithAggregatesInput[]
    NOT?: FileFolderScalarWhereWithAggregatesInput | FileFolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileFolder"> | string
    name?: StringWithAggregatesFilter<"FileFolder"> | string
    icon?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    color?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"FileFolder"> | string | null
    schoolId?: StringWithAggregatesFilter<"FileFolder"> | string
    order?: IntWithAggregatesFilter<"FileFolder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FileFolder"> | Date | string
  }

  export type SchoolFileWhereInput = {
    AND?: SchoolFileWhereInput | SchoolFileWhereInput[]
    OR?: SchoolFileWhereInput[]
    NOT?: SchoolFileWhereInput | SchoolFileWhereInput[]
    id?: StringFilter<"SchoolFile"> | string
    name?: StringFilter<"SchoolFile"> | string
    fileName?: StringFilter<"SchoolFile"> | string
    fileUrl?: StringFilter<"SchoolFile"> | string
    fileType?: StringFilter<"SchoolFile"> | string
    fileSize?: IntFilter<"SchoolFile"> | number
    folderId?: StringNullableFilter<"SchoolFile"> | string | null
    schoolId?: StringFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    folder?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type SchoolFileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    folder?: FileFolderOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolFileWhereInput | SchoolFileWhereInput[]
    OR?: SchoolFileWhereInput[]
    NOT?: SchoolFileWhereInput | SchoolFileWhereInput[]
    name?: StringFilter<"SchoolFile"> | string
    fileName?: StringFilter<"SchoolFile"> | string
    fileUrl?: StringFilter<"SchoolFile"> | string
    fileType?: StringFilter<"SchoolFile"> | string
    fileSize?: IntFilter<"SchoolFile"> | number
    folderId?: StringNullableFilter<"SchoolFile"> | string | null
    schoolId?: StringFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    folder?: XOR<FileFolderNullableRelationFilter, FileFolderWhereInput> | null
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type SchoolFileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolFileCountOrderByAggregateInput
    _avg?: SchoolFileAvgOrderByAggregateInput
    _max?: SchoolFileMaxOrderByAggregateInput
    _min?: SchoolFileMinOrderByAggregateInput
    _sum?: SchoolFileSumOrderByAggregateInput
  }

  export type SchoolFileScalarWhereWithAggregatesInput = {
    AND?: SchoolFileScalarWhereWithAggregatesInput | SchoolFileScalarWhereWithAggregatesInput[]
    OR?: SchoolFileScalarWhereWithAggregatesInput[]
    NOT?: SchoolFileScalarWhereWithAggregatesInput | SchoolFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolFile"> | string
    name?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileName?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileUrl?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileType?: StringWithAggregatesFilter<"SchoolFile"> | string
    fileSize?: IntWithAggregatesFilter<"SchoolFile"> | number
    folderId?: StringNullableWithAggregatesFilter<"SchoolFile"> | string | null
    schoolId?: StringWithAggregatesFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolFile"> | Date | string
  }

  export type FormWhereInput = {
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    id?: StringFilter<"Form"> | string
    title?: StringFilter<"Form"> | string
    description?: StringNullableFilter<"Form"> | string | null
    type?: StringFilter<"Form"> | string
    status?: StringFilter<"Form"> | string
    fields?: JsonFilter<"Form">
    targetClass?: StringFilter<"Form"> | string
    classIds?: JsonFilter<"Form">
    yearGroupIds?: JsonFilter<"Form">
    schoolId?: StringFilter<"Form"> | string
    expiresAt?: DateTimeNullableFilter<"Form"> | Date | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    message?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    responses?: FormResponseListRelationFilter
  }

  export type FormOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    fields?: SortOrder
    targetClass?: SortOrder
    classIds?: SortOrder
    yearGroupIds?: SortOrder
    schoolId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    message?: MessageOrderByWithRelationInput
    responses?: FormResponseOrderByRelationAggregateInput
  }

  export type FormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    title?: StringFilter<"Form"> | string
    description?: StringNullableFilter<"Form"> | string | null
    type?: StringFilter<"Form"> | string
    status?: StringFilter<"Form"> | string
    fields?: JsonFilter<"Form">
    targetClass?: StringFilter<"Form"> | string
    classIds?: JsonFilter<"Form">
    yearGroupIds?: JsonFilter<"Form">
    schoolId?: StringFilter<"Form"> | string
    expiresAt?: DateTimeNullableFilter<"Form"> | Date | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    message?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    responses?: FormResponseListRelationFilter
  }, "id">

  export type FormOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    fields?: SortOrder
    targetClass?: SortOrder
    classIds?: SortOrder
    yearGroupIds?: SortOrder
    schoolId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormCountOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    OR?: FormScalarWhereWithAggregatesInput[]
    NOT?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Form"> | string
    title?: StringWithAggregatesFilter<"Form"> | string
    description?: StringNullableWithAggregatesFilter<"Form"> | string | null
    type?: StringWithAggregatesFilter<"Form"> | string
    status?: StringWithAggregatesFilter<"Form"> | string
    fields?: JsonWithAggregatesFilter<"Form">
    targetClass?: StringWithAggregatesFilter<"Form"> | string
    classIds?: JsonWithAggregatesFilter<"Form">
    yearGroupIds?: JsonWithAggregatesFilter<"Form">
    schoolId?: StringWithAggregatesFilter<"Form"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Form"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
  }

  export type FormResponseWhereInput = {
    AND?: FormResponseWhereInput | FormResponseWhereInput[]
    OR?: FormResponseWhereInput[]
    NOT?: FormResponseWhereInput | FormResponseWhereInput[]
    id?: StringFilter<"FormResponse"> | string
    formId?: StringFilter<"FormResponse"> | string
    userId?: StringFilter<"FormResponse"> | string
    answers?: JsonFilter<"FormResponse">
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FormResponseOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    form?: FormOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FormResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    formId_userId?: FormResponseFormIdUserIdCompoundUniqueInput
    AND?: FormResponseWhereInput | FormResponseWhereInput[]
    OR?: FormResponseWhereInput[]
    NOT?: FormResponseWhereInput | FormResponseWhereInput[]
    formId?: StringFilter<"FormResponse"> | string
    userId?: StringFilter<"FormResponse"> | string
    answers?: JsonFilter<"FormResponse">
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
    form?: XOR<FormRelationFilter, FormWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "formId_userId">

  export type FormResponseOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    _count?: FormResponseCountOrderByAggregateInput
    _max?: FormResponseMaxOrderByAggregateInput
    _min?: FormResponseMinOrderByAggregateInput
  }

  export type FormResponseScalarWhereWithAggregatesInput = {
    AND?: FormResponseScalarWhereWithAggregatesInput | FormResponseScalarWhereWithAggregatesInput[]
    OR?: FormResponseScalarWhereWithAggregatesInput[]
    NOT?: FormResponseScalarWhereWithAggregatesInput | FormResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormResponse"> | string
    formId?: StringWithAggregatesFilter<"FormResponse"> | string
    userId?: StringWithAggregatesFilter<"FormResponse"> | string
    answers?: JsonWithAggregatesFilter<"FormResponse">
    createdAt?: DateTimeWithAggregatesFilter<"FormResponse"> | Date | string
  }

  export type ParentInvitationWhereInput = {
    AND?: ParentInvitationWhereInput | ParentInvitationWhereInput[]
    OR?: ParentInvitationWhereInput[]
    NOT?: ParentInvitationWhereInput | ParentInvitationWhereInput[]
    id?: StringFilter<"ParentInvitation"> | string
    schoolId?: StringFilter<"ParentInvitation"> | string
    accessCode?: StringFilter<"ParentInvitation"> | string
    magicToken?: StringNullableFilter<"ParentInvitation"> | string | null
    parentEmail?: StringNullableFilter<"ParentInvitation"> | string | null
    parentName?: StringNullableFilter<"ParentInvitation"> | string | null
    status?: StringFilter<"ParentInvitation"> | string
    expiresAt?: DateTimeNullableFilter<"ParentInvitation"> | Date | string | null
    redeemedAt?: DateTimeNullableFilter<"ParentInvitation"> | Date | string | null
    redeemedByUserId?: StringNullableFilter<"ParentInvitation"> | string | null
    createdById?: StringFilter<"ParentInvitation"> | string
    createdAt?: DateTimeFilter<"ParentInvitation"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    childLinks?: ChildInvitationLinkListRelationFilter
    studentLinks?: StudentInvitationLinkListRelationFilter
    redeemedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ParentInvitationOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    accessCode?: SortOrder
    magicToken?: SortOrderInput | SortOrder
    parentEmail?: SortOrderInput | SortOrder
    parentName?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    redeemedAt?: SortOrderInput | SortOrder
    redeemedByUserId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    childLinks?: ChildInvitationLinkOrderByRelationAggregateInput
    studentLinks?: StudentInvitationLinkOrderByRelationAggregateInput
    redeemedByUser?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type ParentInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessCode?: string
    magicToken?: string
    AND?: ParentInvitationWhereInput | ParentInvitationWhereInput[]
    OR?: ParentInvitationWhereInput[]
    NOT?: ParentInvitationWhereInput | ParentInvitationWhereInput[]
    schoolId?: StringFilter<"ParentInvitation"> | string
    parentEmail?: StringNullableFilter<"ParentInvitation"> | string | null
    parentName?: StringNullableFilter<"ParentInvitation"> | string | null
    status?: StringFilter<"ParentInvitation"> | string
    expiresAt?: DateTimeNullableFilter<"ParentInvitation"> | Date | string | null
    redeemedAt?: DateTimeNullableFilter<"ParentInvitation"> | Date | string | null
    redeemedByUserId?: StringNullableFilter<"ParentInvitation"> | string | null
    createdById?: StringFilter<"ParentInvitation"> | string
    createdAt?: DateTimeFilter<"ParentInvitation"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    childLinks?: ChildInvitationLinkListRelationFilter
    studentLinks?: StudentInvitationLinkListRelationFilter
    redeemedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "accessCode" | "magicToken">

  export type ParentInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    accessCode?: SortOrder
    magicToken?: SortOrderInput | SortOrder
    parentEmail?: SortOrderInput | SortOrder
    parentName?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    redeemedAt?: SortOrderInput | SortOrder
    redeemedByUserId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: ParentInvitationCountOrderByAggregateInput
    _max?: ParentInvitationMaxOrderByAggregateInput
    _min?: ParentInvitationMinOrderByAggregateInput
  }

  export type ParentInvitationScalarWhereWithAggregatesInput = {
    AND?: ParentInvitationScalarWhereWithAggregatesInput | ParentInvitationScalarWhereWithAggregatesInput[]
    OR?: ParentInvitationScalarWhereWithAggregatesInput[]
    NOT?: ParentInvitationScalarWhereWithAggregatesInput | ParentInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParentInvitation"> | string
    schoolId?: StringWithAggregatesFilter<"ParentInvitation"> | string
    accessCode?: StringWithAggregatesFilter<"ParentInvitation"> | string
    magicToken?: StringNullableWithAggregatesFilter<"ParentInvitation"> | string | null
    parentEmail?: StringNullableWithAggregatesFilter<"ParentInvitation"> | string | null
    parentName?: StringNullableWithAggregatesFilter<"ParentInvitation"> | string | null
    status?: StringWithAggregatesFilter<"ParentInvitation"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ParentInvitation"> | Date | string | null
    redeemedAt?: DateTimeNullableWithAggregatesFilter<"ParentInvitation"> | Date | string | null
    redeemedByUserId?: StringNullableWithAggregatesFilter<"ParentInvitation"> | string | null
    createdById?: StringWithAggregatesFilter<"ParentInvitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParentInvitation"> | Date | string
  }

  export type ChildInvitationLinkWhereInput = {
    AND?: ChildInvitationLinkWhereInput | ChildInvitationLinkWhereInput[]
    OR?: ChildInvitationLinkWhereInput[]
    NOT?: ChildInvitationLinkWhereInput | ChildInvitationLinkWhereInput[]
    id?: StringFilter<"ChildInvitationLink"> | string
    invitationId?: StringFilter<"ChildInvitationLink"> | string
    childName?: StringFilter<"ChildInvitationLink"> | string
    classId?: StringFilter<"ChildInvitationLink"> | string
    invitation?: XOR<ParentInvitationRelationFilter, ParentInvitationWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type ChildInvitationLinkOrderByWithRelationInput = {
    id?: SortOrder
    invitationId?: SortOrder
    childName?: SortOrder
    classId?: SortOrder
    invitation?: ParentInvitationOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type ChildInvitationLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invitationId_classId_childName?: ChildInvitationLinkInvitationIdClassIdChildNameCompoundUniqueInput
    AND?: ChildInvitationLinkWhereInput | ChildInvitationLinkWhereInput[]
    OR?: ChildInvitationLinkWhereInput[]
    NOT?: ChildInvitationLinkWhereInput | ChildInvitationLinkWhereInput[]
    invitationId?: StringFilter<"ChildInvitationLink"> | string
    childName?: StringFilter<"ChildInvitationLink"> | string
    classId?: StringFilter<"ChildInvitationLink"> | string
    invitation?: XOR<ParentInvitationRelationFilter, ParentInvitationWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "id" | "invitationId_classId_childName">

  export type ChildInvitationLinkOrderByWithAggregationInput = {
    id?: SortOrder
    invitationId?: SortOrder
    childName?: SortOrder
    classId?: SortOrder
    _count?: ChildInvitationLinkCountOrderByAggregateInput
    _max?: ChildInvitationLinkMaxOrderByAggregateInput
    _min?: ChildInvitationLinkMinOrderByAggregateInput
  }

  export type ChildInvitationLinkScalarWhereWithAggregatesInput = {
    AND?: ChildInvitationLinkScalarWhereWithAggregatesInput | ChildInvitationLinkScalarWhereWithAggregatesInput[]
    OR?: ChildInvitationLinkScalarWhereWithAggregatesInput[]
    NOT?: ChildInvitationLinkScalarWhereWithAggregatesInput | ChildInvitationLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChildInvitationLink"> | string
    invitationId?: StringWithAggregatesFilter<"ChildInvitationLink"> | string
    childName?: StringWithAggregatesFilter<"ChildInvitationLink"> | string
    classId?: StringWithAggregatesFilter<"ChildInvitationLink"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    userName?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFilter<"AuditLog"> | $Enums.AuditResourceType
    resourceId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    schoolId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    userName?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFilter<"AuditLog"> | $Enums.AuditResourceType
    resourceId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    schoolId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    userName?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeWithAggregatesFilter<"AuditLog"> | $Enums.AuditResourceType
    resourceId?: StringWithAggregatesFilter<"AuditLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    schoolId?: StringWithAggregatesFilter<"AuditLog"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    resourceType?: StringNullableFilter<"Notification"> | string | null
    resourceId?: StringNullableFilter<"Notification"> | string | null
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    schoolId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    resourceType?: StringNullableFilter<"Notification"> | string | null
    resourceId?: StringNullableFilter<"Notification"> | string | null
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    schoolId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    resourceType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    data?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    schoolId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type DeviceTokenWhereInput = {
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    userId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeviceTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_token?: DeviceTokenUserIdTokenCompoundUniqueInput
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    userId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_token">

  export type DeviceTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceTokenCountOrderByAggregateInput
    _max?: DeviceTokenMaxOrderByAggregateInput
    _min?: DeviceTokenMinOrderByAggregateInput
  }

  export type DeviceTokenScalarWhereWithAggregatesInput = {
    AND?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    OR?: DeviceTokenScalarWhereWithAggregatesInput[]
    NOT?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceToken"> | string
    userId?: StringWithAggregatesFilter<"DeviceToken"> | string
    token?: StringWithAggregatesFilter<"DeviceToken"> | string
    platform?: StringWithAggregatesFilter<"DeviceToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
  }

  export type MagicLinkTokenWhereInput = {
    AND?: MagicLinkTokenWhereInput | MagicLinkTokenWhereInput[]
    OR?: MagicLinkTokenWhereInput[]
    NOT?: MagicLinkTokenWhereInput | MagicLinkTokenWhereInput[]
    id?: StringFilter<"MagicLinkToken"> | string
    token?: StringFilter<"MagicLinkToken"> | string
    email?: StringFilter<"MagicLinkToken"> | string
    schoolId?: StringFilter<"MagicLinkToken"> | string
    type?: StringFilter<"MagicLinkToken"> | string
    invitationId?: StringNullableFilter<"MagicLinkToken"> | string | null
    expiresAt?: DateTimeFilter<"MagicLinkToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"MagicLinkToken"> | Date | string | null
    createdAt?: DateTimeFilter<"MagicLinkToken"> | Date | string
  }

  export type MagicLinkTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    invitationId?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type MagicLinkTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: MagicLinkTokenWhereInput | MagicLinkTokenWhereInput[]
    OR?: MagicLinkTokenWhereInput[]
    NOT?: MagicLinkTokenWhereInput | MagicLinkTokenWhereInput[]
    email?: StringFilter<"MagicLinkToken"> | string
    schoolId?: StringFilter<"MagicLinkToken"> | string
    type?: StringFilter<"MagicLinkToken"> | string
    invitationId?: StringNullableFilter<"MagicLinkToken"> | string | null
    expiresAt?: DateTimeFilter<"MagicLinkToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"MagicLinkToken"> | Date | string | null
    createdAt?: DateTimeFilter<"MagicLinkToken"> | Date | string
  }, "id" | "token">

  export type MagicLinkTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    invitationId?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MagicLinkTokenCountOrderByAggregateInput
    _max?: MagicLinkTokenMaxOrderByAggregateInput
    _min?: MagicLinkTokenMinOrderByAggregateInput
  }

  export type MagicLinkTokenScalarWhereWithAggregatesInput = {
    AND?: MagicLinkTokenScalarWhereWithAggregatesInput | MagicLinkTokenScalarWhereWithAggregatesInput[]
    OR?: MagicLinkTokenScalarWhereWithAggregatesInput[]
    NOT?: MagicLinkTokenScalarWhereWithAggregatesInput | MagicLinkTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MagicLinkToken"> | string
    token?: StringWithAggregatesFilter<"MagicLinkToken"> | string
    email?: StringWithAggregatesFilter<"MagicLinkToken"> | string
    schoolId?: StringWithAggregatesFilter<"MagicLinkToken"> | string
    type?: StringWithAggregatesFilter<"MagicLinkToken"> | string
    invitationId?: StringNullableWithAggregatesFilter<"MagicLinkToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"MagicLinkToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"MagicLinkToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MagicLinkToken"> | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateInput = {
    id?: string
    name: string
    parent: UserCreateNestedOneWithoutChildrenInput
    class: ClassCreateNestedOneWithoutChildrenInput
  }

  export type ChildUncheckedCreateInput = {
    id?: string
    name: string
    parentId: string
    classId: string
  }

  export type ChildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: UserUpdateOneRequiredWithoutChildrenNestedInput
    class?: ClassUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildCreateManyInput = {
    id?: string
    name: string
    parentId: string
    classId: string
  }

  export type ChildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ChildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentsInput
    class: ClassCreateNestedOneWithoutStudentsInput
    parentLinks?: ParentStudentLinkCreateNestedManyWithoutStudentInput
    invitationLinks?: StudentInvitationLinkCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    schoolId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutStudentInput
    invitationLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    parentLinks?: ParentStudentLinkUpdateManyWithoutStudentNestedInput
    invitationLinks?: StudentInvitationLinkUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutStudentNestedInput
    invitationLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    schoolId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentLinkCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentLinksInput
    student: StudentCreateNestedOneWithoutParentLinksInput
  }

  export type ParentStudentLinkUncheckedCreateInput = {
    id?: string
    userId: string
    studentId: string
    createdAt?: Date | string
  }

  export type ParentStudentLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentLinksNestedInput
    student?: StudentUpdateOneRequiredWithoutParentLinksNestedInput
  }

  export type ParentStudentLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentLinkCreateManyInput = {
    id?: string
    userId: string
    studentId: string
    createdAt?: Date | string
  }

  export type ParentStudentLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentInvitationLinkCreateInput = {
    id?: string
    invitation: ParentInvitationCreateNestedOneWithoutStudentLinksInput
    student: StudentCreateNestedOneWithoutInvitationLinksInput
  }

  export type StudentInvitationLinkUncheckedCreateInput = {
    id?: string
    invitationId: string
    studentId: string
  }

  export type StudentInvitationLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitation?: ParentInvitationUpdateOneRequiredWithoutStudentLinksNestedInput
    student?: StudentUpdateOneRequiredWithoutInvitationLinksNestedInput
  }

  export type StudentInvitationLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentInvitationLinkCreateManyInput = {
    id?: string
    invitationId: string
    studentId: string
  }

  export type StudentInvitationLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StudentInvitationLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type YearGroupCreateInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutYearGroupsInput
    classes?: ClassCreateNestedManyWithoutYearGroupInput
    messages?: MessageCreateNestedManyWithoutYearGroupInput
    events?: EventCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupUncheckedCreateInput = {
    id?: string
    name: string
    order: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutYearGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutYearGroupInput
    events?: EventUncheckedCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutYearGroupsNestedInput
    classes?: ClassUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUpdateManyWithoutYearGroupNestedInput
    events?: EventUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutYearGroupNestedInput
    events?: EventUncheckedUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupCreateManyInput = {
    id?: string
    name: string
    order: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YearGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffClassAssignmentCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAssignedClassesInput
    class: ClassCreateNestedOneWithoutAssignedStaffInput
  }

  export type StaffClassAssignmentUncheckedCreateInput = {
    id?: string
    userId: string
    classId: string
    createdAt?: Date | string
  }

  export type StaffClassAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAssignedClassesNestedInput
    class?: ClassUpdateOneRequiredWithoutAssignedStaffNestedInput
  }

  export type StaffClassAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffClassAssignmentCreateManyInput = {
    id?: string
    userId: string
    classId: string
    createdAt?: Date | string
  }

  export type StaffClassAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffClassAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    yearGroup?: YearGroupCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    form?: FormCreateNestedOneWithoutMessageInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    form?: FormUpdateOneWithoutMessageNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentCreateInput = {
    id?: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAcknowledgmentsInput
    user: UserCreateNestedOneWithoutMessageAcksInput
  }

  export type MessageAcknowledgmentUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAcknowledgmentsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageAcksNestedInput
  }

  export type MessageAcknowledgmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutEventsInput
    yearGroup?: YearGroupCreateNestedOneWithoutEventsInput
    school: SchoolCreateNestedOneWithoutEventsInput
    rsvps?: EventRsvpCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: EventRsvpUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutEventsNestedInput
    yearGroup?: YearGroupUpdateOneWithoutEventsNestedInput
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: EventRsvpUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: EventRsvpUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpCreateInput = {
    id?: string
    status: string
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutRsvpsInput
    user: UserCreateNestedOneWithoutEventRsvpsInput
  }

  export type EventRsvpUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRsvpsNestedInput
    user?: UserUpdateOneRequiredWithoutEventRsvpsNestedInput
  }

  export type EventRsvpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermDateCreateInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
    school: SchoolCreateNestedOneWithoutTermDatesInput
  }

  export type TermDateUncheckedCreateInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
    schoolId: string
  }

  export type TermDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutTermDatesNestedInput
  }

  export type TermDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateCreateManyInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
    schoolId: string
  }

  export type TermDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleItemCreateInput = {
    id?: string
    targetClass: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutScheduleItemsInput
    yearGroup?: YearGroupCreateNestedOneWithoutScheduleItemsInput
    school: SchoolCreateNestedOneWithoutScheduleItemsInput
  }

  export type ScheduleItemUncheckedCreateInput = {
    id?: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutScheduleItemsNestedInput
    yearGroup?: YearGroupUpdateOneWithoutScheduleItemsNestedInput
    school?: SchoolUpdateOneRequiredWithoutScheduleItemsNestedInput
  }

  export type ScheduleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemCreateManyInput = {
    id?: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageCreateInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutWeeklyMessagesInput
    hearts?: WeeklyMessageHeartCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
    hearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutWeeklyMessagesNestedInput
    hearts?: WeeklyMessageHeartUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageCreateManyInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartCreateInput = {
    id?: string
    createdAt?: Date | string
    message: WeeklyMessageCreateNestedOneWithoutHeartsInput
    user: UserCreateNestedOneWithoutWeeklyHeartsInput
  }

  export type WeeklyMessageHeartUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: WeeklyMessageUpdateOneRequiredWithoutHeartsNestedInput
    user?: UserUpdateOneRequiredWithoutWeeklyHeartsNestedInput
  }

  export type WeeklyMessageHeartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCategoryCreateInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    school: SchoolCreateNestedOneWithoutKnowledgeCategoriesInput
    articles?: KnowledgeArticleCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryUncheckedCreateInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    schoolId: string
    articles?: KnowledgeArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    school?: SchoolUpdateOneRequiredWithoutKnowledgeCategoriesNestedInput
    articles?: KnowledgeArticleUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    articles?: KnowledgeArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryCreateManyInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    schoolId: string
  }

  export type KnowledgeCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type KnowledgeCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type KnowledgeArticleCreateInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
    category: KnowledgeCategoryCreateNestedOneWithoutArticlesInput
  }

  export type KnowledgeArticleUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: KnowledgeCategoryUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type KnowledgeArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleCreateManyInput = {
    id?: string
    title: string
    content: string
    categoryId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseSurveyCreateInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutPulseSurveysInput
    responses?: PulseResponseCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyUncheckedCreateInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    schoolId: string
    createdAt?: Date | string
    responses?: PulseResponseUncheckedCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPulseSurveysNestedInput
    responses?: PulseResponseUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PulseResponseUncheckedUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyCreateManyInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    schoolId: string
    createdAt?: Date | string
  }

  export type PulseSurveyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseSurveyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseCreateInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pulse: PulseSurveyCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutPulseResponsesInput
  }

  export type PulseResponseUncheckedCreateInput = {
    id?: string
    pulseId: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pulse?: PulseSurveyUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutPulseResponsesNestedInput
  }

  export type PulseResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseCreateManyInput = {
    id?: string
    pulseId: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    schoolId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    schoolId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderCreateInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    children?: FileFolderCreateNestedManyWithoutParentInput
    school: SchoolCreateNestedOneWithoutFoldersInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    children?: FileFolderUpdateManyWithoutParentNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderCreateManyInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
  }

  export type FileFolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileCreateInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    folder?: FileFolderCreateNestedOneWithoutFilesInput
    school: SchoolCreateNestedOneWithoutFilesInput
  }

  export type SchoolFileUncheckedCreateInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FileFolderUpdateOneWithoutFilesNestedInput
    school?: SchoolUpdateOneRequiredWithoutFilesNestedInput
  }

  export type SchoolFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileCreateManyInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFormsInput
    message?: MessageCreateNestedOneWithoutFormInput
    responses?: FormResponseCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: MessageUncheckedCreateNestedOneWithoutFormInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFormsNestedInput
    message?: MessageUpdateOneWithoutFormNestedInput
    responses?: FormResponseUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUncheckedUpdateOneWithoutFormNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseCreateInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    form: FormCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutFormResponsesInput
  }

  export type FormResponseUncheckedCreateInput = {
    id?: string
    formId: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutFormResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseCreateManyInput = {
    id?: string
    formId: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInvitationCreateInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvitationsInput
    childLinks?: ChildInvitationLinkCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkCreateNestedManyWithoutInvitationInput
    redeemedByUser?: UserCreateNestedOneWithoutRedeemedInvitationsInput
    createdBy: UserCreateNestedOneWithoutCreatedInvitationsInput
  }

  export type ParentInvitationUncheckedCreateInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdById: string
    createdAt?: Date | string
    childLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type ParentInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvitationsNestedInput
    childLinks?: ChildInvitationLinkUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUpdateManyWithoutInvitationNestedInput
    redeemedByUser?: UserUpdateOneWithoutRedeemedInvitationsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvitationsNestedInput
  }

  export type ParentInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type ParentInvitationCreateManyInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type ParentInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildInvitationLinkCreateInput = {
    id?: string
    childName: string
    invitation: ParentInvitationCreateNestedOneWithoutChildLinksInput
    class: ClassCreateNestedOneWithoutChildInvitationLinksInput
  }

  export type ChildInvitationLinkUncheckedCreateInput = {
    id?: string
    invitationId: string
    childName: string
    classId: string
  }

  export type ChildInvitationLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
    invitation?: ParentInvitationUpdateOneRequiredWithoutChildLinksNestedInput
    class?: ClassUpdateOneRequiredWithoutChildInvitationLinksNestedInput
  }

  export type ChildInvitationLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildInvitationLinkCreateManyInput = {
    id?: string
    invitationId: string
    childName: string
    classId: string
  }

  export type ChildInvitationLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
  }

  export type ChildInvitationLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
    school: SchoolCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId: string
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    school?: SchoolUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId: string
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    school: SchoolCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    school?: SchoolUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateInput = {
    id?: string
    token: string
    platform: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeviceTokensInput
  }

  export type DeviceTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    platform: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeviceTokensNestedInput
  }

  export type DeviceTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    platform: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicLinkTokenCreateInput = {
    id?: string
    token: string
    email: string
    schoolId: string
    type: string
    invitationId?: string | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MagicLinkTokenUncheckedCreateInput = {
    id?: string
    token: string
    email: string
    schoolId: string
    type: string
    invitationId?: string | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MagicLinkTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicLinkTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicLinkTokenCreateManyInput = {
    id?: string
    token: string
    email: string
    schoolId: string
    type: string
    invitationId?: string | null
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MagicLinkTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicLinkTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type YearGroupListRelationFilter = {
    every?: YearGroupWhereInput
    some?: YearGroupWhereInput
    none?: YearGroupWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type FormListRelationFilter = {
    every?: FormWhereInput
    some?: FormWhereInput
    none?: FormWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type TermDateListRelationFilter = {
    every?: TermDateWhereInput
    some?: TermDateWhereInput
    none?: TermDateWhereInput
  }

  export type ScheduleItemListRelationFilter = {
    every?: ScheduleItemWhereInput
    some?: ScheduleItemWhereInput
    none?: ScheduleItemWhereInput
  }

  export type WeeklyMessageListRelationFilter = {
    every?: WeeklyMessageWhereInput
    some?: WeeklyMessageWhereInput
    none?: WeeklyMessageWhereInput
  }

  export type KnowledgeCategoryListRelationFilter = {
    every?: KnowledgeCategoryWhereInput
    some?: KnowledgeCategoryWhereInput
    none?: KnowledgeCategoryWhereInput
  }

  export type PulseSurveyListRelationFilter = {
    every?: PulseSurveyWhereInput
    some?: PulseSurveyWhereInput
    none?: PulseSurveyWhereInput
  }

  export type PolicyListRelationFilter = {
    every?: PolicyWhereInput
    some?: PolicyWhereInput
    none?: PolicyWhereInput
  }

  export type FileFolderListRelationFilter = {
    every?: FileFolderWhereInput
    some?: FileFolderWhereInput
    none?: FileFolderWhereInput
  }

  export type SchoolFileListRelationFilter = {
    every?: SchoolFileWhereInput
    some?: SchoolFileWhereInput
    none?: SchoolFileWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ParentInvitationListRelationFilter = {
    every?: ParentInvitationWhereInput
    some?: ParentInvitationWhereInput
    none?: ParentInvitationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TermDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PulseSurveyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileFolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    logoIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    logoIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    city?: SortOrder
    academicYear?: SortOrder
    brandColor?: SortOrder
    accentColor?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    logoIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type ChildListRelationFilter = {
    every?: ChildWhereInput
    some?: ChildWhereInput
    none?: ChildWhereInput
  }

  export type ParentStudentLinkListRelationFilter = {
    every?: ParentStudentLinkWhereInput
    some?: ParentStudentLinkWhereInput
    none?: ParentStudentLinkWhereInput
  }

  export type StaffClassAssignmentListRelationFilter = {
    every?: StaffClassAssignmentWhereInput
    some?: StaffClassAssignmentWhereInput
    none?: StaffClassAssignmentWhereInput
  }

  export type MessageAcknowledgmentListRelationFilter = {
    every?: MessageAcknowledgmentWhereInput
    some?: MessageAcknowledgmentWhereInput
    none?: MessageAcknowledgmentWhereInput
  }

  export type FormResponseListRelationFilter = {
    every?: FormResponseWhereInput
    some?: FormResponseWhereInput
    none?: FormResponseWhereInput
  }

  export type EventRsvpListRelationFilter = {
    every?: EventRsvpWhereInput
    some?: EventRsvpWhereInput
    none?: EventRsvpWhereInput
  }

  export type PulseResponseListRelationFilter = {
    every?: PulseResponseWhereInput
    some?: PulseResponseWhereInput
    none?: PulseResponseWhereInput
  }

  export type WeeklyMessageHeartListRelationFilter = {
    every?: WeeklyMessageHeartWhereInput
    some?: WeeklyMessageHeartWhereInput
    none?: WeeklyMessageHeartWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type DeviceTokenListRelationFilter = {
    every?: DeviceTokenWhereInput
    some?: DeviceTokenWhereInput
    none?: DeviceTokenWhereInput
  }

  export type ChildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentStudentLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffClassAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageAcknowledgmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventRsvpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PulseResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyMessageHeartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrder
    microsoftId?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrder
    microsoftId?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    googleId?: SortOrder
    microsoftId?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ChildCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
  }

  export type ChildMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
  }

  export type ChildMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    classId?: SortOrder
  }

  export type StudentInvitationLinkListRelationFilter = {
    every?: StudentInvitationLinkWhereInput
    some?: StudentInvitationLinkWhereInput
    none?: StudentInvitationLinkWhereInput
  }

  export type StudentInvitationLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSchoolIdExternalIdCompoundUniqueInput = {
    schoolId: string
    externalId: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    externalId?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    externalId?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    externalId?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ParentStudentLinkUserIdStudentIdCompoundUniqueInput = {
    userId: string
    studentId: string
  }

  export type ParentStudentLinkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentStudentLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentStudentLinkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentInvitationRelationFilter = {
    is?: ParentInvitationWhereInput
    isNot?: ParentInvitationWhereInput
  }

  export type StudentInvitationLinkInvitationIdStudentIdCompoundUniqueInput = {
    invitationId: string
    studentId: string
  }

  export type StudentInvitationLinkCountOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    studentId?: SortOrder
  }

  export type StudentInvitationLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    studentId?: SortOrder
  }

  export type StudentInvitationLinkMinOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    studentId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type YearGroupSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type YearGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YearGroupAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type YearGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YearGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YearGroupSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type YearGroupNullableRelationFilter = {
    is?: YearGroupWhereInput | null
    isNot?: YearGroupWhereInput | null
  }

  export type ChildInvitationLinkListRelationFilter = {
    every?: ChildInvitationLinkWhereInput
    some?: ChildInvitationLinkWhereInput
    none?: ChildInvitationLinkWhereInput
  }

  export type ChildInvitationLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
    yearGroupId?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
    yearGroupId?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    colorBg?: SortOrder
    colorText?: SortOrder
    schoolId?: SortOrder
    yearGroupId?: SortOrder
  }

  export type StaffClassAssignmentUserIdClassIdCompoundUniqueInput = {
    userId: string
    classId: string
  }

  export type StaffClassAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffClassAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffClassAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ClassNullableRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type FormNullableRelationFilter = {
    is?: FormWhereInput | null
    isNot?: FormWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrder
    actionLabel?: SortOrder
    actionDueDate?: SortOrder
    actionAmount?: SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    expiresAt?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrder
    actionLabel?: SortOrder
    actionDueDate?: SortOrder
    actionAmount?: SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    expiresAt?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    actionType?: SortOrder
    actionLabel?: SortOrder
    actionDueDate?: SortOrder
    actionAmount?: SortOrder
    isPinned?: SortOrder
    isUrgent?: SortOrder
    expiresAt?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageAcknowledgmentMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageAcknowledgmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAcknowledgmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAcknowledgmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    location?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    requiresRsvp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventRsvpEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventRsvpCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EventRsvpMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EventRsvpMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TermDateCountOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
  }

  export type TermDateAvgOrderByAggregateInput = {
    term?: SortOrder
  }

  export type TermDateMaxOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
  }

  export type TermDateMinOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    termName?: SortOrder
    label?: SortOrder
    sublabel?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    color?: SortOrder
    schoolId?: SortOrder
  }

  export type TermDateSumOrderByAggregateInput = {
    term?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ScheduleItemCountOrderByAggregateInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrder
    active?: SortOrder
    date?: SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduleItemAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type ScheduleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrder
    active?: SortOrder
    date?: SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduleItemMinOrderByAggregateInput = {
    id?: SortOrder
    targetClass?: SortOrder
    classId?: SortOrder
    yearGroupId?: SortOrder
    schoolId?: SortOrder
    isRecurring?: SortOrder
    dayOfWeek?: SortOrder
    active?: SortOrder
    date?: SortOrder
    type?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduleItemSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type WeeklyMessageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    weekOf?: SortOrder
    isCurrent?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageRelationFilter = {
    is?: WeeklyMessageWhereInput
    isNot?: WeeklyMessageWhereInput
  }

  export type WeeklyMessageHeartMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type WeeklyMessageHeartCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageHeartMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type WeeklyMessageHeartMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeArticleListRelationFilter = {
    every?: KnowledgeArticleWhereInput
    some?: KnowledgeArticleWhereInput
    none?: KnowledgeArticleWhereInput
  }

  export type KnowledgeArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
  }

  export type KnowledgeCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type KnowledgeCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
  }

  export type KnowledgeCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    schoolId?: SortOrder
  }

  export type KnowledgeCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type KnowledgeCategoryRelationFilter = {
    is?: KnowledgeCategoryWhereInput
    isNot?: KnowledgeCategoryWhereInput
  }

  export type KnowledgeArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseSurveyCountOrderByAggregateInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    additionalQuestionKey?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseSurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    additionalQuestionKey?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseSurveyMinOrderByAggregateInput = {
    id?: SortOrder
    halfTermName?: SortOrder
    status?: SortOrder
    opensAt?: SortOrder
    closesAt?: SortOrder
    additionalQuestionKey?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PulseSurveyRelationFilter = {
    is?: PulseSurveyWhereInput
    isNot?: PulseSurveyWhereInput
  }

  export type PulseResponsePulseIdUserIdCompoundUniqueInput = {
    pulseId: string
    userId: string
  }

  export type PulseResponseCountOrderByAggregateInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PulseResponseMinOrderByAggregateInput = {
    id?: SortOrder
    pulseId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    schoolId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type FileFolderNullableRelationFilter = {
    is?: FileFolderWhereInput | null
    isNot?: FileFolderWhereInput | null
  }

  export type FileFolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FileFolderAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FileFolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FileFolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    schoolId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type FileFolderSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SchoolFileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolFileAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type SchoolFileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolFileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    folderId?: SortOrder
    schoolId?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolFileSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MessageNullableRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type FormCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    fields?: SortOrder
    targetClass?: SortOrder
    classIds?: SortOrder
    yearGroupIds?: SortOrder
    schoolId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetClass?: SortOrder
    schoolId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetClass?: SortOrder
    schoolId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormRelationFilter = {
    is?: FormWhereInput
    isNot?: FormWhereInput
  }

  export type FormResponseFormIdUserIdCompoundUniqueInput = {
    formId: string
    userId: string
  }

  export type FormResponseCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
  }

  export type FormResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FormResponseMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ParentInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    accessCode?: SortOrder
    magicToken?: SortOrder
    parentEmail?: SortOrder
    parentName?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    redeemedAt?: SortOrder
    redeemedByUserId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    accessCode?: SortOrder
    magicToken?: SortOrder
    parentEmail?: SortOrder
    parentName?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    redeemedAt?: SortOrder
    redeemedByUserId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    accessCode?: SortOrder
    magicToken?: SortOrder
    parentEmail?: SortOrder
    parentName?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    redeemedAt?: SortOrder
    redeemedByUserId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ChildInvitationLinkInvitationIdClassIdChildNameCompoundUniqueInput = {
    invitationId: string
    classId: string
    childName: string
  }

  export type ChildInvitationLinkCountOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    childName?: SortOrder
    classId?: SortOrder
  }

  export type ChildInvitationLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    childName?: SortOrder
    classId?: SortOrder
  }

  export type ChildInvitationLinkMinOrderByAggregateInput = {
    id?: SortOrder
    invitationId?: SortOrder
    childName?: SortOrder
    classId?: SortOrder
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type EnumAuditResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditResourceType | EnumAuditResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditResourceTypeFilter<$PrismaModel> | $Enums.AuditResourceType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    metadata?: SortOrder
    schoolId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    schoolId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    schoolId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type EnumAuditResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditResourceType | EnumAuditResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditResourceTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    data?: SortOrder
    read?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    read?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    read?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceTokenUserIdTokenCompoundUniqueInput = {
    userId: string
    token: string
  }

  export type DeviceTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MagicLinkTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    invitationId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MagicLinkTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    invitationId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MagicLinkTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    schoolId?: SortOrder
    type?: SortOrder
    invitationId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type YearGroupCreateNestedManyWithoutSchoolInput = {
    create?: XOR<YearGroupCreateWithoutSchoolInput, YearGroupUncheckedCreateWithoutSchoolInput> | YearGroupCreateWithoutSchoolInput[] | YearGroupUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: YearGroupCreateOrConnectWithoutSchoolInput | YearGroupCreateOrConnectWithoutSchoolInput[]
    createMany?: YearGroupCreateManySchoolInputEnvelope
    connect?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSchoolInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FormCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FormCreateWithoutSchoolInput, FormUncheckedCreateWithoutSchoolInput> | FormCreateWithoutSchoolInput[] | FormUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FormCreateOrConnectWithoutSchoolInput | FormCreateOrConnectWithoutSchoolInput[]
    createMany?: FormCreateManySchoolInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type TermDateCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type WeeklyMessageCreateNestedManyWithoutSchoolInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
  }

  export type KnowledgeCategoryCreateNestedManyWithoutSchoolInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
  }

  export type PulseSurveyCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
  }

  export type PolicyCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type FileFolderCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolFileCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AuditLogCreateWithoutSchoolInput, AuditLogUncheckedCreateWithoutSchoolInput> | AuditLogCreateWithoutSchoolInput[] | AuditLogUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutSchoolInput | AuditLogCreateOrConnectWithoutSchoolInput[]
    createMany?: AuditLogCreateManySchoolInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSchoolInput = {
    create?: XOR<NotificationCreateWithoutSchoolInput, NotificationUncheckedCreateWithoutSchoolInput> | NotificationCreateWithoutSchoolInput[] | NotificationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSchoolInput | NotificationCreateOrConnectWithoutSchoolInput[]
    createMany?: NotificationCreateManySchoolInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ParentInvitationCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ParentInvitationCreateWithoutSchoolInput, ParentInvitationUncheckedCreateWithoutSchoolInput> | ParentInvitationCreateWithoutSchoolInput[] | ParentInvitationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutSchoolInput | ParentInvitationCreateOrConnectWithoutSchoolInput[]
    createMany?: ParentInvitationCreateManySchoolInputEnvelope
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type YearGroupUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<YearGroupCreateWithoutSchoolInput, YearGroupUncheckedCreateWithoutSchoolInput> | YearGroupCreateWithoutSchoolInput[] | YearGroupUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: YearGroupCreateOrConnectWithoutSchoolInput | YearGroupCreateOrConnectWithoutSchoolInput[]
    createMany?: YearGroupCreateManySchoolInputEnvelope
    connect?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FormUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FormCreateWithoutSchoolInput, FormUncheckedCreateWithoutSchoolInput> | FormCreateWithoutSchoolInput[] | FormUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FormCreateOrConnectWithoutSchoolInput | FormCreateOrConnectWithoutSchoolInput[]
    createMany?: FormCreateManySchoolInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type TermDateUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
  }

  export type KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
  }

  export type PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type FileFolderUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolFileUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AuditLogCreateWithoutSchoolInput, AuditLogUncheckedCreateWithoutSchoolInput> | AuditLogCreateWithoutSchoolInput[] | AuditLogUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutSchoolInput | AuditLogCreateOrConnectWithoutSchoolInput[]
    createMany?: AuditLogCreateManySchoolInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<NotificationCreateWithoutSchoolInput, NotificationUncheckedCreateWithoutSchoolInput> | NotificationCreateWithoutSchoolInput[] | NotificationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSchoolInput | NotificationCreateOrConnectWithoutSchoolInput[]
    createMany?: NotificationCreateManySchoolInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ParentInvitationCreateWithoutSchoolInput, ParentInvitationUncheckedCreateWithoutSchoolInput> | ParentInvitationCreateWithoutSchoolInput[] | ParentInvitationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutSchoolInput | ParentInvitationCreateOrConnectWithoutSchoolInput[]
    createMany?: ParentInvitationCreateManySchoolInputEnvelope
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type YearGroupUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<YearGroupCreateWithoutSchoolInput, YearGroupUncheckedCreateWithoutSchoolInput> | YearGroupCreateWithoutSchoolInput[] | YearGroupUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: YearGroupCreateOrConnectWithoutSchoolInput | YearGroupCreateOrConnectWithoutSchoolInput[]
    upsert?: YearGroupUpsertWithWhereUniqueWithoutSchoolInput | YearGroupUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: YearGroupCreateManySchoolInputEnvelope
    set?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    disconnect?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    delete?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    connect?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    update?: YearGroupUpdateWithWhereUniqueWithoutSchoolInput | YearGroupUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: YearGroupUpdateManyWithWhereWithoutSchoolInput | YearGroupUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: YearGroupScalarWhereInput | YearGroupScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSchoolInput | MessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSchoolInput | MessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSchoolInput | MessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FormUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FormCreateWithoutSchoolInput, FormUncheckedCreateWithoutSchoolInput> | FormCreateWithoutSchoolInput[] | FormUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FormCreateOrConnectWithoutSchoolInput | FormCreateOrConnectWithoutSchoolInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutSchoolInput | FormUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FormCreateManySchoolInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutSchoolInput | FormUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FormUpdateManyWithWhereWithoutSchoolInput | FormUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type EventUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSchoolInput | EventUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSchoolInput | EventUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSchoolInput | EventUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type TermDateUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    upsert?: TermDateUpsertWithWhereUniqueWithoutSchoolInput | TermDateUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    set?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    disconnect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    delete?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    update?: TermDateUpdateWithWhereUniqueWithoutSchoolInput | TermDateUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TermDateUpdateManyWithWhereWithoutSchoolInput | TermDateUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput | ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput | ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutSchoolInput | ScheduleItemUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type WeeklyMessageUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    upsert?: WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    set?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    disconnect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    delete?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    update?: WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: WeeklyMessageUpdateManyWithWhereWithoutSchoolInput | WeeklyMessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
  }

  export type KnowledgeCategoryUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    upsert?: KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    set?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    disconnect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    delete?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    update?: KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput | KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
  }

  export type PulseSurveyUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    upsert?: PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput | PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    set?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    disconnect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    delete?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    update?: PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput | PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PulseSurveyUpdateManyWithWhereWithoutSchoolInput | PulseSurveyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
  }

  export type PolicyUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutSchoolInput | PolicyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutSchoolInput | PolicyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutSchoolInput | PolicyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type FileFolderUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutSchoolInput | FileFolderUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutSchoolInput | FileFolderUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutSchoolInput | FileFolderUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolFileUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutSchoolInput | SchoolFileUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutSchoolInput | SchoolFileUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutSchoolInput | SchoolFileUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AuditLogCreateWithoutSchoolInput, AuditLogUncheckedCreateWithoutSchoolInput> | AuditLogCreateWithoutSchoolInput[] | AuditLogUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutSchoolInput | AuditLogCreateOrConnectWithoutSchoolInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutSchoolInput | AuditLogUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AuditLogCreateManySchoolInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutSchoolInput | AuditLogUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutSchoolInput | AuditLogUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<NotificationCreateWithoutSchoolInput, NotificationUncheckedCreateWithoutSchoolInput> | NotificationCreateWithoutSchoolInput[] | NotificationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSchoolInput | NotificationCreateOrConnectWithoutSchoolInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSchoolInput | NotificationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: NotificationCreateManySchoolInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSchoolInput | NotificationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSchoolInput | NotificationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ParentInvitationUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutSchoolInput, ParentInvitationUncheckedCreateWithoutSchoolInput> | ParentInvitationCreateWithoutSchoolInput[] | ParentInvitationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutSchoolInput | ParentInvitationCreateOrConnectWithoutSchoolInput[]
    upsert?: ParentInvitationUpsertWithWhereUniqueWithoutSchoolInput | ParentInvitationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ParentInvitationCreateManySchoolInputEnvelope
    set?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    disconnect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    delete?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    update?: ParentInvitationUpdateWithWhereUniqueWithoutSchoolInput | ParentInvitationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ParentInvitationUpdateManyWithWhereWithoutSchoolInput | ParentInvitationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type YearGroupUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<YearGroupCreateWithoutSchoolInput, YearGroupUncheckedCreateWithoutSchoolInput> | YearGroupCreateWithoutSchoolInput[] | YearGroupUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: YearGroupCreateOrConnectWithoutSchoolInput | YearGroupCreateOrConnectWithoutSchoolInput[]
    upsert?: YearGroupUpsertWithWhereUniqueWithoutSchoolInput | YearGroupUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: YearGroupCreateManySchoolInputEnvelope
    set?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    disconnect?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    delete?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    connect?: YearGroupWhereUniqueInput | YearGroupWhereUniqueInput[]
    update?: YearGroupUpdateWithWhereUniqueWithoutSchoolInput | YearGroupUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: YearGroupUpdateManyWithWhereWithoutSchoolInput | YearGroupUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: YearGroupScalarWhereInput | YearGroupScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput> | MessageCreateWithoutSchoolInput[] | MessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSchoolInput | MessageCreateOrConnectWithoutSchoolInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSchoolInput | MessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: MessageCreateManySchoolInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSchoolInput | MessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSchoolInput | MessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FormUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FormCreateWithoutSchoolInput, FormUncheckedCreateWithoutSchoolInput> | FormCreateWithoutSchoolInput[] | FormUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FormCreateOrConnectWithoutSchoolInput | FormCreateOrConnectWithoutSchoolInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutSchoolInput | FormUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FormCreateManySchoolInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutSchoolInput | FormUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FormUpdateManyWithWhereWithoutSchoolInput | FormUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput> | EventCreateWithoutSchoolInput[] | EventUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: EventCreateOrConnectWithoutSchoolInput | EventCreateOrConnectWithoutSchoolInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutSchoolInput | EventUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: EventCreateManySchoolInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutSchoolInput | EventUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: EventUpdateManyWithWhereWithoutSchoolInput | EventUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type TermDateUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput> | TermDateCreateWithoutSchoolInput[] | TermDateUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermDateCreateOrConnectWithoutSchoolInput | TermDateCreateOrConnectWithoutSchoolInput[]
    upsert?: TermDateUpsertWithWhereUniqueWithoutSchoolInput | TermDateUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TermDateCreateManySchoolInputEnvelope
    set?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    disconnect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    delete?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    connect?: TermDateWhereUniqueInput | TermDateWhereUniqueInput[]
    update?: TermDateUpdateWithWhereUniqueWithoutSchoolInput | TermDateUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TermDateUpdateManyWithWhereWithoutSchoolInput | TermDateUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput> | ScheduleItemCreateWithoutSchoolInput[] | ScheduleItemUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutSchoolInput | ScheduleItemCreateOrConnectWithoutSchoolInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput | ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ScheduleItemCreateManySchoolInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput | ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutSchoolInput | ScheduleItemUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput> | WeeklyMessageCreateWithoutSchoolInput[] | WeeklyMessageUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutSchoolInput | WeeklyMessageCreateOrConnectWithoutSchoolInput[]
    upsert?: WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: WeeklyMessageCreateManySchoolInputEnvelope
    set?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    disconnect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    delete?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    connect?: WeeklyMessageWhereUniqueInput | WeeklyMessageWhereUniqueInput[]
    update?: WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput | WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: WeeklyMessageUpdateManyWithWhereWithoutSchoolInput | WeeklyMessageUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
  }

  export type KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput> | KnowledgeCategoryCreateWithoutSchoolInput[] | KnowledgeCategoryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutSchoolInput | KnowledgeCategoryCreateOrConnectWithoutSchoolInput[]
    upsert?: KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: KnowledgeCategoryCreateManySchoolInputEnvelope
    set?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    disconnect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    delete?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    connect?: KnowledgeCategoryWhereUniqueInput | KnowledgeCategoryWhereUniqueInput[]
    update?: KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput | KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput | KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
  }

  export type PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput> | PulseSurveyCreateWithoutSchoolInput[] | PulseSurveyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutSchoolInput | PulseSurveyCreateOrConnectWithoutSchoolInput[]
    upsert?: PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput | PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PulseSurveyCreateManySchoolInputEnvelope
    set?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    disconnect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    delete?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    connect?: PulseSurveyWhereUniqueInput | PulseSurveyWhereUniqueInput[]
    update?: PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput | PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PulseSurveyUpdateManyWithWhereWithoutSchoolInput | PulseSurveyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput> | PolicyCreateWithoutSchoolInput[] | PolicyUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutSchoolInput | PolicyCreateOrConnectWithoutSchoolInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutSchoolInput | PolicyUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PolicyCreateManySchoolInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutSchoolInput | PolicyUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutSchoolInput | PolicyUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type FileFolderUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput> | FileFolderCreateWithoutSchoolInput[] | FileFolderUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutSchoolInput | FileFolderCreateOrConnectWithoutSchoolInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutSchoolInput | FileFolderUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FileFolderCreateManySchoolInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutSchoolInput | FileFolderUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutSchoolInput | FileFolderUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput> | SchoolFileCreateWithoutSchoolInput[] | SchoolFileUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutSchoolInput | SchoolFileCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutSchoolInput | SchoolFileUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolFileCreateManySchoolInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutSchoolInput | SchoolFileUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutSchoolInput | SchoolFileUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AuditLogCreateWithoutSchoolInput, AuditLogUncheckedCreateWithoutSchoolInput> | AuditLogCreateWithoutSchoolInput[] | AuditLogUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutSchoolInput | AuditLogCreateOrConnectWithoutSchoolInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutSchoolInput | AuditLogUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AuditLogCreateManySchoolInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutSchoolInput | AuditLogUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutSchoolInput | AuditLogUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<NotificationCreateWithoutSchoolInput, NotificationUncheckedCreateWithoutSchoolInput> | NotificationCreateWithoutSchoolInput[] | NotificationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSchoolInput | NotificationCreateOrConnectWithoutSchoolInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSchoolInput | NotificationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: NotificationCreateManySchoolInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSchoolInput | NotificationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSchoolInput | NotificationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutSchoolInput, ParentInvitationUncheckedCreateWithoutSchoolInput> | ParentInvitationCreateWithoutSchoolInput[] | ParentInvitationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutSchoolInput | ParentInvitationCreateOrConnectWithoutSchoolInput[]
    upsert?: ParentInvitationUpsertWithWhereUniqueWithoutSchoolInput | ParentInvitationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ParentInvitationCreateManySchoolInputEnvelope
    set?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    disconnect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    delete?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    update?: ParentInvitationUpdateWithWhereUniqueWithoutSchoolInput | ParentInvitationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ParentInvitationUpdateManyWithWhereWithoutSchoolInput | ParentInvitationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type ChildCreateNestedManyWithoutParentInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type ParentStudentLinkCreateNestedManyWithoutUserInput = {
    create?: XOR<ParentStudentLinkCreateWithoutUserInput, ParentStudentLinkUncheckedCreateWithoutUserInput> | ParentStudentLinkCreateWithoutUserInput[] | ParentStudentLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutUserInput | ParentStudentLinkCreateOrConnectWithoutUserInput[]
    createMany?: ParentStudentLinkCreateManyUserInputEnvelope
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
  }

  export type StaffClassAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutUserInput, StaffClassAssignmentUncheckedCreateWithoutUserInput> | StaffClassAssignmentCreateWithoutUserInput[] | StaffClassAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutUserInput | StaffClassAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: StaffClassAssignmentCreateManyUserInputEnvelope
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageAcknowledgmentCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type FormResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<FormResponseCreateWithoutUserInput, FormResponseUncheckedCreateWithoutUserInput> | FormResponseCreateWithoutUserInput[] | FormResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutUserInput | FormResponseCreateOrConnectWithoutUserInput[]
    createMany?: FormResponseCreateManyUserInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type EventRsvpCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type PulseResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type WeeklyMessageHeartCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DeviceTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type ParentInvitationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ParentInvitationCreateWithoutCreatedByInput, ParentInvitationUncheckedCreateWithoutCreatedByInput> | ParentInvitationCreateWithoutCreatedByInput[] | ParentInvitationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutCreatedByInput | ParentInvitationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ParentInvitationCreateManyCreatedByInputEnvelope
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
  }

  export type ParentInvitationCreateNestedManyWithoutRedeemedByUserInput = {
    create?: XOR<ParentInvitationCreateWithoutRedeemedByUserInput, ParentInvitationUncheckedCreateWithoutRedeemedByUserInput> | ParentInvitationCreateWithoutRedeemedByUserInput[] | ParentInvitationUncheckedCreateWithoutRedeemedByUserInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutRedeemedByUserInput | ParentInvitationCreateOrConnectWithoutRedeemedByUserInput[]
    createMany?: ParentInvitationCreateManyRedeemedByUserInputEnvelope
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
  }

  export type ChildUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ParentStudentLinkCreateWithoutUserInput, ParentStudentLinkUncheckedCreateWithoutUserInput> | ParentStudentLinkCreateWithoutUserInput[] | ParentStudentLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutUserInput | ParentStudentLinkCreateOrConnectWithoutUserInput[]
    createMany?: ParentStudentLinkCreateManyUserInputEnvelope
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
  }

  export type StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutUserInput, StaffClassAssignmentUncheckedCreateWithoutUserInput> | StaffClassAssignmentCreateWithoutUserInput[] | StaffClassAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutUserInput | StaffClassAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: StaffClassAssignmentCreateManyUserInputEnvelope
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type FormResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FormResponseCreateWithoutUserInput, FormResponseUncheckedCreateWithoutUserInput> | FormResponseCreateWithoutUserInput[] | FormResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutUserInput | FormResponseCreateOrConnectWithoutUserInput[]
    createMany?: FormResponseCreateManyUserInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type EventRsvpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type PulseResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DeviceTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ParentInvitationCreateWithoutCreatedByInput, ParentInvitationUncheckedCreateWithoutCreatedByInput> | ParentInvitationCreateWithoutCreatedByInput[] | ParentInvitationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutCreatedByInput | ParentInvitationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ParentInvitationCreateManyCreatedByInputEnvelope
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
  }

  export type ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput = {
    create?: XOR<ParentInvitationCreateWithoutRedeemedByUserInput, ParentInvitationUncheckedCreateWithoutRedeemedByUserInput> | ParentInvitationCreateWithoutRedeemedByUserInput[] | ParentInvitationUncheckedCreateWithoutRedeemedByUserInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutRedeemedByUserInput | ParentInvitationCreateOrConnectWithoutRedeemedByUserInput[]
    createMany?: ParentInvitationCreateManyRedeemedByUserInputEnvelope
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type SchoolUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type ChildUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutParentInput | ChildUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutParentInput | ChildUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutParentInput | ChildUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type ParentStudentLinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParentStudentLinkCreateWithoutUserInput, ParentStudentLinkUncheckedCreateWithoutUserInput> | ParentStudentLinkCreateWithoutUserInput[] | ParentStudentLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutUserInput | ParentStudentLinkCreateOrConnectWithoutUserInput[]
    upsert?: ParentStudentLinkUpsertWithWhereUniqueWithoutUserInput | ParentStudentLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParentStudentLinkCreateManyUserInputEnvelope
    set?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    disconnect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    delete?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    update?: ParentStudentLinkUpdateWithWhereUniqueWithoutUserInput | ParentStudentLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParentStudentLinkUpdateManyWithWhereWithoutUserInput | ParentStudentLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParentStudentLinkScalarWhereInput | ParentStudentLinkScalarWhereInput[]
  }

  export type StaffClassAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutUserInput, StaffClassAssignmentUncheckedCreateWithoutUserInput> | StaffClassAssignmentCreateWithoutUserInput[] | StaffClassAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutUserInput | StaffClassAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: StaffClassAssignmentUpsertWithWhereUniqueWithoutUserInput | StaffClassAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffClassAssignmentCreateManyUserInputEnvelope
    set?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    disconnect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    delete?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    update?: StaffClassAssignmentUpdateWithWhereUniqueWithoutUserInput | StaffClassAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffClassAssignmentUpdateManyWithWhereWithoutUserInput | StaffClassAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffClassAssignmentScalarWhereInput | StaffClassAssignmentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageAcknowledgmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput | MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type FormResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<FormResponseCreateWithoutUserInput, FormResponseUncheckedCreateWithoutUserInput> | FormResponseCreateWithoutUserInput[] | FormResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutUserInput | FormResponseCreateOrConnectWithoutUserInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutUserInput | FormResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FormResponseCreateManyUserInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutUserInput | FormResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutUserInput | FormResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type EventRsvpUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutUserInput | EventRsvpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutUserInput | EventRsvpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutUserInput | EventRsvpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type PulseResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutUserInput | PulseResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutUserInput | PulseResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutUserInput | PulseResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type WeeklyMessageHeartUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput | WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DeviceTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type ParentInvitationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutCreatedByInput, ParentInvitationUncheckedCreateWithoutCreatedByInput> | ParentInvitationCreateWithoutCreatedByInput[] | ParentInvitationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutCreatedByInput | ParentInvitationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ParentInvitationUpsertWithWhereUniqueWithoutCreatedByInput | ParentInvitationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ParentInvitationCreateManyCreatedByInputEnvelope
    set?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    disconnect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    delete?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    update?: ParentInvitationUpdateWithWhereUniqueWithoutCreatedByInput | ParentInvitationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ParentInvitationUpdateManyWithWhereWithoutCreatedByInput | ParentInvitationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
  }

  export type ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutRedeemedByUserInput, ParentInvitationUncheckedCreateWithoutRedeemedByUserInput> | ParentInvitationCreateWithoutRedeemedByUserInput[] | ParentInvitationUncheckedCreateWithoutRedeemedByUserInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutRedeemedByUserInput | ParentInvitationCreateOrConnectWithoutRedeemedByUserInput[]
    upsert?: ParentInvitationUpsertWithWhereUniqueWithoutRedeemedByUserInput | ParentInvitationUpsertWithWhereUniqueWithoutRedeemedByUserInput[]
    createMany?: ParentInvitationCreateManyRedeemedByUserInputEnvelope
    set?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    disconnect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    delete?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    update?: ParentInvitationUpdateWithWhereUniqueWithoutRedeemedByUserInput | ParentInvitationUpdateWithWhereUniqueWithoutRedeemedByUserInput[]
    updateMany?: ParentInvitationUpdateManyWithWhereWithoutRedeemedByUserInput | ParentInvitationUpdateManyWithWhereWithoutRedeemedByUserInput[]
    deleteMany?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
  }

  export type ChildUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput> | ChildCreateWithoutParentInput[] | ChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutParentInput | ChildCreateOrConnectWithoutParentInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutParentInput | ChildUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChildCreateManyParentInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutParentInput | ChildUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutParentInput | ChildUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParentStudentLinkCreateWithoutUserInput, ParentStudentLinkUncheckedCreateWithoutUserInput> | ParentStudentLinkCreateWithoutUserInput[] | ParentStudentLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutUserInput | ParentStudentLinkCreateOrConnectWithoutUserInput[]
    upsert?: ParentStudentLinkUpsertWithWhereUniqueWithoutUserInput | ParentStudentLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParentStudentLinkCreateManyUserInputEnvelope
    set?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    disconnect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    delete?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    update?: ParentStudentLinkUpdateWithWhereUniqueWithoutUserInput | ParentStudentLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParentStudentLinkUpdateManyWithWhereWithoutUserInput | ParentStudentLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParentStudentLinkScalarWhereInput | ParentStudentLinkScalarWhereInput[]
  }

  export type StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutUserInput, StaffClassAssignmentUncheckedCreateWithoutUserInput> | StaffClassAssignmentCreateWithoutUserInput[] | StaffClassAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutUserInput | StaffClassAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: StaffClassAssignmentUpsertWithWhereUniqueWithoutUserInput | StaffClassAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffClassAssignmentCreateManyUserInputEnvelope
    set?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    disconnect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    delete?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    update?: StaffClassAssignmentUpdateWithWhereUniqueWithoutUserInput | StaffClassAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffClassAssignmentUpdateManyWithWhereWithoutUserInput | StaffClassAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffClassAssignmentScalarWhereInput | StaffClassAssignmentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput> | MessageAcknowledgmentCreateWithoutUserInput[] | MessageAcknowledgmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutUserInput | MessageAcknowledgmentCreateOrConnectWithoutUserInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageAcknowledgmentCreateManyUserInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput | MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type FormResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FormResponseCreateWithoutUserInput, FormResponseUncheckedCreateWithoutUserInput> | FormResponseCreateWithoutUserInput[] | FormResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutUserInput | FormResponseCreateOrConnectWithoutUserInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutUserInput | FormResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FormResponseCreateManyUserInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutUserInput | FormResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutUserInput | FormResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type EventRsvpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput> | EventRsvpCreateWithoutUserInput[] | EventRsvpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutUserInput | EventRsvpCreateOrConnectWithoutUserInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutUserInput | EventRsvpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRsvpCreateManyUserInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutUserInput | EventRsvpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutUserInput | EventRsvpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type PulseResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput> | PulseResponseCreateWithoutUserInput[] | PulseResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutUserInput | PulseResponseCreateOrConnectWithoutUserInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutUserInput | PulseResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PulseResponseCreateManyUserInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutUserInput | PulseResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutUserInput | PulseResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput> | WeeklyMessageHeartCreateWithoutUserInput[] | WeeklyMessageHeartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutUserInput | WeeklyMessageHeartCreateOrConnectWithoutUserInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeeklyMessageHeartCreateManyUserInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput | WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutCreatedByInput, ParentInvitationUncheckedCreateWithoutCreatedByInput> | ParentInvitationCreateWithoutCreatedByInput[] | ParentInvitationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutCreatedByInput | ParentInvitationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ParentInvitationUpsertWithWhereUniqueWithoutCreatedByInput | ParentInvitationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ParentInvitationCreateManyCreatedByInputEnvelope
    set?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    disconnect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    delete?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    update?: ParentInvitationUpdateWithWhereUniqueWithoutCreatedByInput | ParentInvitationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ParentInvitationUpdateManyWithWhereWithoutCreatedByInput | ParentInvitationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
  }

  export type ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutRedeemedByUserInput, ParentInvitationUncheckedCreateWithoutRedeemedByUserInput> | ParentInvitationCreateWithoutRedeemedByUserInput[] | ParentInvitationUncheckedCreateWithoutRedeemedByUserInput[]
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutRedeemedByUserInput | ParentInvitationCreateOrConnectWithoutRedeemedByUserInput[]
    upsert?: ParentInvitationUpsertWithWhereUniqueWithoutRedeemedByUserInput | ParentInvitationUpsertWithWhereUniqueWithoutRedeemedByUserInput[]
    createMany?: ParentInvitationCreateManyRedeemedByUserInputEnvelope
    set?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    disconnect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    delete?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    connect?: ParentInvitationWhereUniqueInput | ParentInvitationWhereUniqueInput[]
    update?: ParentInvitationUpdateWithWhereUniqueWithoutRedeemedByUserInput | ParentInvitationUpdateWithWhereUniqueWithoutRedeemedByUserInput[]
    updateMany?: ParentInvitationUpdateManyWithWhereWithoutRedeemedByUserInput | ParentInvitationUpdateManyWithWhereWithoutRedeemedByUserInput[]
    deleteMany?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutChildrenInput = {
    create?: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: UserCreateOrConnectWithoutChildrenInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ClassCreateOrConnectWithoutChildrenInput
    connect?: ClassWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: UserCreateOrConnectWithoutChildrenInput
    upsert?: UserUpsertWithoutChildrenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChildrenInput, UserUpdateWithoutChildrenInput>, UserUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ClassCreateOrConnectWithoutChildrenInput
    upsert?: ClassUpsertWithoutChildrenInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutChildrenInput, ClassUpdateWithoutChildrenInput>, ClassUncheckedUpdateWithoutChildrenInput>
  }

  export type SchoolCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type ParentStudentLinkCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentStudentLinkCreateWithoutStudentInput, ParentStudentLinkUncheckedCreateWithoutStudentInput> | ParentStudentLinkCreateWithoutStudentInput[] | ParentStudentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutStudentInput | ParentStudentLinkCreateOrConnectWithoutStudentInput[]
    createMany?: ParentStudentLinkCreateManyStudentInputEnvelope
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
  }

  export type StudentInvitationLinkCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutStudentInput, StudentInvitationLinkUncheckedCreateWithoutStudentInput> | StudentInvitationLinkCreateWithoutStudentInput[] | StudentInvitationLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutStudentInput | StudentInvitationLinkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentInvitationLinkCreateManyStudentInputEnvelope
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
  }

  export type ParentStudentLinkUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentStudentLinkCreateWithoutStudentInput, ParentStudentLinkUncheckedCreateWithoutStudentInput> | ParentStudentLinkCreateWithoutStudentInput[] | ParentStudentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutStudentInput | ParentStudentLinkCreateOrConnectWithoutStudentInput[]
    createMany?: ParentStudentLinkCreateManyStudentInputEnvelope
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
  }

  export type StudentInvitationLinkUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutStudentInput, StudentInvitationLinkUncheckedCreateWithoutStudentInput> | StudentInvitationLinkCreateWithoutStudentInput[] | StudentInvitationLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutStudentInput | StudentInvitationLinkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentInvitationLinkCreateManyStudentInputEnvelope
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    upsert?: SchoolUpsertWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStudentsInput, SchoolUpdateWithoutStudentsInput>, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    upsert?: ClassUpsertWithoutStudentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsInput, ClassUpdateWithoutStudentsInput>, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ParentStudentLinkUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentStudentLinkCreateWithoutStudentInput, ParentStudentLinkUncheckedCreateWithoutStudentInput> | ParentStudentLinkCreateWithoutStudentInput[] | ParentStudentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutStudentInput | ParentStudentLinkCreateOrConnectWithoutStudentInput[]
    upsert?: ParentStudentLinkUpsertWithWhereUniqueWithoutStudentInput | ParentStudentLinkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentStudentLinkCreateManyStudentInputEnvelope
    set?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    disconnect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    delete?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    update?: ParentStudentLinkUpdateWithWhereUniqueWithoutStudentInput | ParentStudentLinkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentStudentLinkUpdateManyWithWhereWithoutStudentInput | ParentStudentLinkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentStudentLinkScalarWhereInput | ParentStudentLinkScalarWhereInput[]
  }

  export type StudentInvitationLinkUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutStudentInput, StudentInvitationLinkUncheckedCreateWithoutStudentInput> | StudentInvitationLinkCreateWithoutStudentInput[] | StudentInvitationLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutStudentInput | StudentInvitationLinkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentInvitationLinkUpsertWithWhereUniqueWithoutStudentInput | StudentInvitationLinkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentInvitationLinkCreateManyStudentInputEnvelope
    set?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    disconnect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    delete?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    update?: StudentInvitationLinkUpdateWithWhereUniqueWithoutStudentInput | StudentInvitationLinkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentInvitationLinkUpdateManyWithWhereWithoutStudentInput | StudentInvitationLinkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentInvitationLinkScalarWhereInput | StudentInvitationLinkScalarWhereInput[]
  }

  export type ParentStudentLinkUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentStudentLinkCreateWithoutStudentInput, ParentStudentLinkUncheckedCreateWithoutStudentInput> | ParentStudentLinkCreateWithoutStudentInput[] | ParentStudentLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentStudentLinkCreateOrConnectWithoutStudentInput | ParentStudentLinkCreateOrConnectWithoutStudentInput[]
    upsert?: ParentStudentLinkUpsertWithWhereUniqueWithoutStudentInput | ParentStudentLinkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentStudentLinkCreateManyStudentInputEnvelope
    set?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    disconnect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    delete?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    connect?: ParentStudentLinkWhereUniqueInput | ParentStudentLinkWhereUniqueInput[]
    update?: ParentStudentLinkUpdateWithWhereUniqueWithoutStudentInput | ParentStudentLinkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentStudentLinkUpdateManyWithWhereWithoutStudentInput | ParentStudentLinkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentStudentLinkScalarWhereInput | ParentStudentLinkScalarWhereInput[]
  }

  export type StudentInvitationLinkUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutStudentInput, StudentInvitationLinkUncheckedCreateWithoutStudentInput> | StudentInvitationLinkCreateWithoutStudentInput[] | StudentInvitationLinkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutStudentInput | StudentInvitationLinkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentInvitationLinkUpsertWithWhereUniqueWithoutStudentInput | StudentInvitationLinkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentInvitationLinkCreateManyStudentInputEnvelope
    set?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    disconnect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    delete?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    update?: StudentInvitationLinkUpdateWithWhereUniqueWithoutStudentInput | StudentInvitationLinkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentInvitationLinkUpdateManyWithWhereWithoutStudentInput | StudentInvitationLinkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentInvitationLinkScalarWhereInput | StudentInvitationLinkScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentLinksInput = {
    create?: XOR<UserCreateWithoutStudentLinksInput, UserUncheckedCreateWithoutStudentLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentLinksInput
    connect?: UserWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutParentLinksInput = {
    create?: XOR<StudentCreateWithoutParentLinksInput, StudentUncheckedCreateWithoutParentLinksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentLinksInput
    connect?: StudentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStudentLinksNestedInput = {
    create?: XOR<UserCreateWithoutStudentLinksInput, UserUncheckedCreateWithoutStudentLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentLinksInput
    upsert?: UserUpsertWithoutStudentLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentLinksInput, UserUpdateWithoutStudentLinksInput>, UserUncheckedUpdateWithoutStudentLinksInput>
  }

  export type StudentUpdateOneRequiredWithoutParentLinksNestedInput = {
    create?: XOR<StudentCreateWithoutParentLinksInput, StudentUncheckedCreateWithoutParentLinksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentLinksInput
    upsert?: StudentUpsertWithoutParentLinksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentLinksInput, StudentUpdateWithoutParentLinksInput>, StudentUncheckedUpdateWithoutParentLinksInput>
  }

  export type ParentInvitationCreateNestedOneWithoutStudentLinksInput = {
    create?: XOR<ParentInvitationCreateWithoutStudentLinksInput, ParentInvitationUncheckedCreateWithoutStudentLinksInput>
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutStudentLinksInput
    connect?: ParentInvitationWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutInvitationLinksInput = {
    create?: XOR<StudentCreateWithoutInvitationLinksInput, StudentUncheckedCreateWithoutInvitationLinksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvitationLinksInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentInvitationUpdateOneRequiredWithoutStudentLinksNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutStudentLinksInput, ParentInvitationUncheckedCreateWithoutStudentLinksInput>
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutStudentLinksInput
    upsert?: ParentInvitationUpsertWithoutStudentLinksInput
    connect?: ParentInvitationWhereUniqueInput
    update?: XOR<XOR<ParentInvitationUpdateToOneWithWhereWithoutStudentLinksInput, ParentInvitationUpdateWithoutStudentLinksInput>, ParentInvitationUncheckedUpdateWithoutStudentLinksInput>
  }

  export type StudentUpdateOneRequiredWithoutInvitationLinksNestedInput = {
    create?: XOR<StudentCreateWithoutInvitationLinksInput, StudentUncheckedCreateWithoutInvitationLinksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvitationLinksInput
    upsert?: StudentUpsertWithoutInvitationLinksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutInvitationLinksInput, StudentUpdateWithoutInvitationLinksInput>, StudentUncheckedUpdateWithoutInvitationLinksInput>
  }

  export type SchoolCreateNestedOneWithoutYearGroupsInput = {
    create?: XOR<SchoolCreateWithoutYearGroupsInput, SchoolUncheckedCreateWithoutYearGroupsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutYearGroupsInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<ClassCreateWithoutYearGroupInput, ClassUncheckedCreateWithoutYearGroupInput> | ClassCreateWithoutYearGroupInput[] | ClassUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutYearGroupInput | ClassCreateOrConnectWithoutYearGroupInput[]
    createMany?: ClassCreateManyYearGroupInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<MessageCreateWithoutYearGroupInput, MessageUncheckedCreateWithoutYearGroupInput> | MessageCreateWithoutYearGroupInput[] | MessageUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutYearGroupInput | MessageCreateOrConnectWithoutYearGroupInput[]
    createMany?: MessageCreateManyYearGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<EventCreateWithoutYearGroupInput, EventUncheckedCreateWithoutYearGroupInput> | EventCreateWithoutYearGroupInput[] | EventUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutYearGroupInput | EventCreateOrConnectWithoutYearGroupInput[]
    createMany?: EventCreateManyYearGroupInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<ScheduleItemCreateWithoutYearGroupInput, ScheduleItemUncheckedCreateWithoutYearGroupInput> | ScheduleItemCreateWithoutYearGroupInput[] | ScheduleItemUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutYearGroupInput | ScheduleItemCreateOrConnectWithoutYearGroupInput[]
    createMany?: ScheduleItemCreateManyYearGroupInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<ClassCreateWithoutYearGroupInput, ClassUncheckedCreateWithoutYearGroupInput> | ClassCreateWithoutYearGroupInput[] | ClassUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutYearGroupInput | ClassCreateOrConnectWithoutYearGroupInput[]
    createMany?: ClassCreateManyYearGroupInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<MessageCreateWithoutYearGroupInput, MessageUncheckedCreateWithoutYearGroupInput> | MessageCreateWithoutYearGroupInput[] | MessageUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutYearGroupInput | MessageCreateOrConnectWithoutYearGroupInput[]
    createMany?: MessageCreateManyYearGroupInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<EventCreateWithoutYearGroupInput, EventUncheckedCreateWithoutYearGroupInput> | EventCreateWithoutYearGroupInput[] | EventUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutYearGroupInput | EventCreateOrConnectWithoutYearGroupInput[]
    createMany?: EventCreateManyYearGroupInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutYearGroupInput = {
    create?: XOR<ScheduleItemCreateWithoutYearGroupInput, ScheduleItemUncheckedCreateWithoutYearGroupInput> | ScheduleItemCreateWithoutYearGroupInput[] | ScheduleItemUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutYearGroupInput | ScheduleItemCreateOrConnectWithoutYearGroupInput[]
    createMany?: ScheduleItemCreateManyYearGroupInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SchoolUpdateOneRequiredWithoutYearGroupsNestedInput = {
    create?: XOR<SchoolCreateWithoutYearGroupsInput, SchoolUncheckedCreateWithoutYearGroupsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutYearGroupsInput
    upsert?: SchoolUpsertWithoutYearGroupsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutYearGroupsInput, SchoolUpdateWithoutYearGroupsInput>, SchoolUncheckedUpdateWithoutYearGroupsInput>
  }

  export type ClassUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<ClassCreateWithoutYearGroupInput, ClassUncheckedCreateWithoutYearGroupInput> | ClassCreateWithoutYearGroupInput[] | ClassUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutYearGroupInput | ClassCreateOrConnectWithoutYearGroupInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutYearGroupInput | ClassUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: ClassCreateManyYearGroupInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutYearGroupInput | ClassUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutYearGroupInput | ClassUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<MessageCreateWithoutYearGroupInput, MessageUncheckedCreateWithoutYearGroupInput> | MessageCreateWithoutYearGroupInput[] | MessageUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutYearGroupInput | MessageCreateOrConnectWithoutYearGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutYearGroupInput | MessageUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: MessageCreateManyYearGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutYearGroupInput | MessageUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutYearGroupInput | MessageUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type EventUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<EventCreateWithoutYearGroupInput, EventUncheckedCreateWithoutYearGroupInput> | EventCreateWithoutYearGroupInput[] | EventUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutYearGroupInput | EventCreateOrConnectWithoutYearGroupInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutYearGroupInput | EventUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: EventCreateManyYearGroupInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutYearGroupInput | EventUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: EventUpdateManyWithWhereWithoutYearGroupInput | EventUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutYearGroupInput, ScheduleItemUncheckedCreateWithoutYearGroupInput> | ScheduleItemCreateWithoutYearGroupInput[] | ScheduleItemUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutYearGroupInput | ScheduleItemCreateOrConnectWithoutYearGroupInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutYearGroupInput | ScheduleItemUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: ScheduleItemCreateManyYearGroupInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutYearGroupInput | ScheduleItemUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutYearGroupInput | ScheduleItemUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<ClassCreateWithoutYearGroupInput, ClassUncheckedCreateWithoutYearGroupInput> | ClassCreateWithoutYearGroupInput[] | ClassUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutYearGroupInput | ClassCreateOrConnectWithoutYearGroupInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutYearGroupInput | ClassUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: ClassCreateManyYearGroupInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutYearGroupInput | ClassUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutYearGroupInput | ClassUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<MessageCreateWithoutYearGroupInput, MessageUncheckedCreateWithoutYearGroupInput> | MessageCreateWithoutYearGroupInput[] | MessageUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutYearGroupInput | MessageCreateOrConnectWithoutYearGroupInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutYearGroupInput | MessageUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: MessageCreateManyYearGroupInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutYearGroupInput | MessageUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutYearGroupInput | MessageUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<EventCreateWithoutYearGroupInput, EventUncheckedCreateWithoutYearGroupInput> | EventCreateWithoutYearGroupInput[] | EventUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutYearGroupInput | EventCreateOrConnectWithoutYearGroupInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutYearGroupInput | EventUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: EventCreateManyYearGroupInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutYearGroupInput | EventUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: EventUpdateManyWithWhereWithoutYearGroupInput | EventUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutYearGroupNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutYearGroupInput, ScheduleItemUncheckedCreateWithoutYearGroupInput> | ScheduleItemCreateWithoutYearGroupInput[] | ScheduleItemUncheckedCreateWithoutYearGroupInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutYearGroupInput | ScheduleItemCreateOrConnectWithoutYearGroupInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutYearGroupInput | ScheduleItemUpsertWithWhereUniqueWithoutYearGroupInput[]
    createMany?: ScheduleItemCreateManyYearGroupInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutYearGroupInput | ScheduleItemUpdateWithWhereUniqueWithoutYearGroupInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutYearGroupInput | ScheduleItemUpdateManyWithWhereWithoutYearGroupInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    connect?: SchoolWhereUniqueInput
  }

  export type YearGroupCreateNestedOneWithoutClassesInput = {
    create?: XOR<YearGroupCreateWithoutClassesInput, YearGroupUncheckedCreateWithoutClassesInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutClassesInput
    connect?: YearGroupWhereUniqueInput
  }

  export type ChildCreateNestedManyWithoutClassInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutClassInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutClassInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutClassInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type StaffClassAssignmentCreateNestedManyWithoutClassInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutClassInput, StaffClassAssignmentUncheckedCreateWithoutClassInput> | StaffClassAssignmentCreateWithoutClassInput[] | StaffClassAssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutClassInput | StaffClassAssignmentCreateOrConnectWithoutClassInput[]
    createMany?: StaffClassAssignmentCreateManyClassInputEnvelope
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
  }

  export type ChildInvitationLinkCreateNestedManyWithoutClassInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutClassInput, ChildInvitationLinkUncheckedCreateWithoutClassInput> | ChildInvitationLinkCreateWithoutClassInput[] | ChildInvitationLinkUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutClassInput | ChildInvitationLinkCreateOrConnectWithoutClassInput[]
    createMany?: ChildInvitationLinkCreateManyClassInputEnvelope
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
  }

  export type ChildUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutClassInput, StaffClassAssignmentUncheckedCreateWithoutClassInput> | StaffClassAssignmentCreateWithoutClassInput[] | StaffClassAssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutClassInput | StaffClassAssignmentCreateOrConnectWithoutClassInput[]
    createMany?: StaffClassAssignmentCreateManyClassInputEnvelope
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
  }

  export type ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutClassInput, ChildInvitationLinkUncheckedCreateWithoutClassInput> | ChildInvitationLinkCreateWithoutClassInput[] | ChildInvitationLinkUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutClassInput | ChildInvitationLinkCreateOrConnectWithoutClassInput[]
    createMany?: ChildInvitationLinkCreateManyClassInputEnvelope
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    upsert?: SchoolUpsertWithoutClassesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassesInput, SchoolUpdateWithoutClassesInput>, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type YearGroupUpdateOneWithoutClassesNestedInput = {
    create?: XOR<YearGroupCreateWithoutClassesInput, YearGroupUncheckedCreateWithoutClassesInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutClassesInput
    upsert?: YearGroupUpsertWithoutClassesInput
    disconnect?: YearGroupWhereInput | boolean
    delete?: YearGroupWhereInput | boolean
    connect?: YearGroupWhereUniqueInput
    update?: XOR<XOR<YearGroupUpdateToOneWithWhereWithoutClassesInput, YearGroupUpdateWithoutClassesInput>, YearGroupUncheckedUpdateWithoutClassesInput>
  }

  export type ChildUpdateManyWithoutClassNestedInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutClassInput | ChildUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutClassInput | ChildUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutClassInput | ChildUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutClassNestedInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClassInput | MessageUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClassInput | MessageUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClassInput | MessageUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type EventUpdateManyWithoutClassNestedInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutClassInput | EventUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutClassInput | EventUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EventUpdateManyWithWhereWithoutClassInput | EventUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutClassNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutClassInput | ScheduleItemUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutClassInput | ScheduleItemUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutClassInput | ScheduleItemUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type StaffClassAssignmentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutClassInput, StaffClassAssignmentUncheckedCreateWithoutClassInput> | StaffClassAssignmentCreateWithoutClassInput[] | StaffClassAssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutClassInput | StaffClassAssignmentCreateOrConnectWithoutClassInput[]
    upsert?: StaffClassAssignmentUpsertWithWhereUniqueWithoutClassInput | StaffClassAssignmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StaffClassAssignmentCreateManyClassInputEnvelope
    set?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    disconnect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    delete?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    update?: StaffClassAssignmentUpdateWithWhereUniqueWithoutClassInput | StaffClassAssignmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StaffClassAssignmentUpdateManyWithWhereWithoutClassInput | StaffClassAssignmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StaffClassAssignmentScalarWhereInput | StaffClassAssignmentScalarWhereInput[]
  }

  export type ChildInvitationLinkUpdateManyWithoutClassNestedInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutClassInput, ChildInvitationLinkUncheckedCreateWithoutClassInput> | ChildInvitationLinkCreateWithoutClassInput[] | ChildInvitationLinkUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutClassInput | ChildInvitationLinkCreateOrConnectWithoutClassInput[]
    upsert?: ChildInvitationLinkUpsertWithWhereUniqueWithoutClassInput | ChildInvitationLinkUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ChildInvitationLinkCreateManyClassInputEnvelope
    set?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    disconnect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    delete?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    update?: ChildInvitationLinkUpdateWithWhereUniqueWithoutClassInput | ChildInvitationLinkUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ChildInvitationLinkUpdateManyWithWhereWithoutClassInput | ChildInvitationLinkUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ChildInvitationLinkScalarWhereInput | ChildInvitationLinkScalarWhereInput[]
  }

  export type ChildUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput> | ChildCreateWithoutClassInput[] | ChildUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutClassInput | ChildCreateOrConnectWithoutClassInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutClassInput | ChildUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ChildCreateManyClassInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutClassInput | ChildUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutClassInput | ChildUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput> | MessageCreateWithoutClassInput[] | MessageUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClassInput | MessageCreateOrConnectWithoutClassInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClassInput | MessageUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: MessageCreateManyClassInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClassInput | MessageUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClassInput | MessageUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput> | EventCreateWithoutClassInput[] | EventUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EventCreateOrConnectWithoutClassInput | EventCreateOrConnectWithoutClassInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutClassInput | EventUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EventCreateManyClassInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutClassInput | EventUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EventUpdateManyWithWhereWithoutClassInput | EventUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput> | ScheduleItemCreateWithoutClassInput[] | ScheduleItemUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassInput | ScheduleItemCreateOrConnectWithoutClassInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutClassInput | ScheduleItemUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ScheduleItemCreateManyClassInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutClassInput | ScheduleItemUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutClassInput | ScheduleItemUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StaffClassAssignmentCreateWithoutClassInput, StaffClassAssignmentUncheckedCreateWithoutClassInput> | StaffClassAssignmentCreateWithoutClassInput[] | StaffClassAssignmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StaffClassAssignmentCreateOrConnectWithoutClassInput | StaffClassAssignmentCreateOrConnectWithoutClassInput[]
    upsert?: StaffClassAssignmentUpsertWithWhereUniqueWithoutClassInput | StaffClassAssignmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StaffClassAssignmentCreateManyClassInputEnvelope
    set?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    disconnect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    delete?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    connect?: StaffClassAssignmentWhereUniqueInput | StaffClassAssignmentWhereUniqueInput[]
    update?: StaffClassAssignmentUpdateWithWhereUniqueWithoutClassInput | StaffClassAssignmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StaffClassAssignmentUpdateManyWithWhereWithoutClassInput | StaffClassAssignmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StaffClassAssignmentScalarWhereInput | StaffClassAssignmentScalarWhereInput[]
  }

  export type ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutClassInput, ChildInvitationLinkUncheckedCreateWithoutClassInput> | ChildInvitationLinkCreateWithoutClassInput[] | ChildInvitationLinkUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutClassInput | ChildInvitationLinkCreateOrConnectWithoutClassInput[]
    upsert?: ChildInvitationLinkUpsertWithWhereUniqueWithoutClassInput | ChildInvitationLinkUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ChildInvitationLinkCreateManyClassInputEnvelope
    set?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    disconnect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    delete?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    update?: ChildInvitationLinkUpdateWithWhereUniqueWithoutClassInput | ChildInvitationLinkUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ChildInvitationLinkUpdateManyWithWhereWithoutClassInput | ChildInvitationLinkUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ChildInvitationLinkScalarWhereInput | ChildInvitationLinkScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedClassesInput = {
    create?: XOR<UserCreateWithoutAssignedClassesInput, UserUncheckedCreateWithoutAssignedClassesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedClassesInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutAssignedStaffInput = {
    create?: XOR<ClassCreateWithoutAssignedStaffInput, ClassUncheckedCreateWithoutAssignedStaffInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAssignedStaffInput
    connect?: ClassWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAssignedClassesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedClassesInput, UserUncheckedCreateWithoutAssignedClassesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedClassesInput
    upsert?: UserUpsertWithoutAssignedClassesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedClassesInput, UserUpdateWithoutAssignedClassesInput>, UserUncheckedUpdateWithoutAssignedClassesInput>
  }

  export type ClassUpdateOneRequiredWithoutAssignedStaffNestedInput = {
    create?: XOR<ClassCreateWithoutAssignedStaffInput, ClassUncheckedCreateWithoutAssignedStaffInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAssignedStaffInput
    upsert?: ClassUpsertWithoutAssignedStaffInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAssignedStaffInput, ClassUpdateWithoutAssignedStaffInput>, ClassUncheckedUpdateWithoutAssignedStaffInput>
  }

  export type ClassCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMessagesInput
    connect?: ClassWhereUniqueInput
  }

  export type YearGroupCreateNestedOneWithoutMessagesInput = {
    create?: XOR<YearGroupCreateWithoutMessagesInput, YearGroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutMessagesInput
    connect?: YearGroupWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutMessagesInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type FormCreateNestedOneWithoutMessageInput = {
    create?: XOR<FormCreateWithoutMessageInput, FormUncheckedCreateWithoutMessageInput>
    connectOrCreate?: FormCreateOrConnectWithoutMessageInput
    connect?: FormWhereUniqueInput
  }

  export type MessageAcknowledgmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClassUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMessagesInput
    upsert?: ClassUpsertWithoutMessagesInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutMessagesInput, ClassUpdateWithoutMessagesInput>, ClassUncheckedUpdateWithoutMessagesInput>
  }

  export type YearGroupUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<YearGroupCreateWithoutMessagesInput, YearGroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutMessagesInput
    upsert?: YearGroupUpsertWithoutMessagesInput
    disconnect?: YearGroupWhereInput | boolean
    delete?: YearGroupWhereInput | boolean
    connect?: YearGroupWhereUniqueInput
    update?: XOR<XOR<YearGroupUpdateToOneWithWhereWithoutMessagesInput, YearGroupUpdateWithoutMessagesInput>, YearGroupUncheckedUpdateWithoutMessagesInput>
  }

  export type SchoolUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutMessagesInput
    upsert?: SchoolUpsertWithoutMessagesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutMessagesInput, SchoolUpdateWithoutMessagesInput>, SchoolUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type FormUpdateOneWithoutMessageNestedInput = {
    create?: XOR<FormCreateWithoutMessageInput, FormUncheckedCreateWithoutMessageInput>
    connectOrCreate?: FormCreateOrConnectWithoutMessageInput
    upsert?: FormUpsertWithoutMessageInput
    disconnect?: FormWhereInput | boolean
    delete?: FormWhereInput | boolean
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutMessageInput, FormUpdateWithoutMessageInput>, FormUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAcknowledgmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput | MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput> | MessageAcknowledgmentCreateWithoutMessageInput[] | MessageAcknowledgmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAcknowledgmentCreateOrConnectWithoutMessageInput | MessageAcknowledgmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAcknowledgmentCreateManyMessageInputEnvelope
    set?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    disconnect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    delete?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    connect?: MessageAcknowledgmentWhereUniqueInput | MessageAcknowledgmentWhereUniqueInput[]
    update?: MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput | MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput | MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAcknowledgmentsInput = {
    create?: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAcknowledgmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageAcksInput = {
    create?: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageAcksInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAcknowledgmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAcknowledgmentsInput
    upsert?: MessageUpsertWithoutAcknowledgmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAcknowledgmentsInput, MessageUpdateWithoutAcknowledgmentsInput>, MessageUncheckedUpdateWithoutAcknowledgmentsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageAcksNestedInput = {
    create?: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageAcksInput
    upsert?: UserUpsertWithoutMessageAcksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageAcksInput, UserUpdateWithoutMessageAcksInput>, UserUncheckedUpdateWithoutMessageAcksInput>
  }

  export type ClassCreateNestedOneWithoutEventsInput = {
    create?: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEventsInput
    connect?: ClassWhereUniqueInput
  }

  export type YearGroupCreateNestedOneWithoutEventsInput = {
    create?: XOR<YearGroupCreateWithoutEventsInput, YearGroupUncheckedCreateWithoutEventsInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutEventsInput
    connect?: YearGroupWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutEventsInput = {
    create?: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEventsInput
    connect?: SchoolWhereUniqueInput
  }

  export type EventRsvpCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type EventRsvpUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
  }

  export type ClassUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEventsInput
    upsert?: ClassUpsertWithoutEventsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutEventsInput, ClassUpdateWithoutEventsInput>, ClassUncheckedUpdateWithoutEventsInput>
  }

  export type YearGroupUpdateOneWithoutEventsNestedInput = {
    create?: XOR<YearGroupCreateWithoutEventsInput, YearGroupUncheckedCreateWithoutEventsInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutEventsInput
    upsert?: YearGroupUpsertWithoutEventsInput
    disconnect?: YearGroupWhereInput | boolean
    delete?: YearGroupWhereInput | boolean
    connect?: YearGroupWhereUniqueInput
    update?: XOR<XOR<YearGroupUpdateToOneWithWhereWithoutEventsInput, YearGroupUpdateWithoutEventsInput>, YearGroupUncheckedUpdateWithoutEventsInput>
  }

  export type SchoolUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutEventsInput
    upsert?: SchoolUpsertWithoutEventsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutEventsInput, SchoolUpdateWithoutEventsInput>, SchoolUncheckedUpdateWithoutEventsInput>
  }

  export type EventRsvpUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutEventInput | EventRsvpUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutEventInput | EventRsvpUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutEventInput | EventRsvpUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type EventRsvpUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput> | EventRsvpCreateWithoutEventInput[] | EventRsvpUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRsvpCreateOrConnectWithoutEventInput | EventRsvpCreateOrConnectWithoutEventInput[]
    upsert?: EventRsvpUpsertWithWhereUniqueWithoutEventInput | EventRsvpUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRsvpCreateManyEventInputEnvelope
    set?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    disconnect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    delete?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    connect?: EventRsvpWhereUniqueInput | EventRsvpWhereUniqueInput[]
    update?: EventRsvpUpdateWithWhereUniqueWithoutEventInput | EventRsvpUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRsvpUpdateManyWithWhereWithoutEventInput | EventRsvpUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutRsvpsInput = {
    create?: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRsvpsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventRsvpsInput = {
    create?: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRsvpsInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutRsvpsNestedInput = {
    create?: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRsvpsInput
    upsert?: EventUpsertWithoutRsvpsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutRsvpsInput, EventUpdateWithoutRsvpsInput>, EventUncheckedUpdateWithoutRsvpsInput>
  }

  export type UserUpdateOneRequiredWithoutEventRsvpsNestedInput = {
    create?: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRsvpsInput
    upsert?: UserUpsertWithoutEventRsvpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventRsvpsInput, UserUpdateWithoutEventRsvpsInput>, UserUncheckedUpdateWithoutEventRsvpsInput>
  }

  export type SchoolCreateNestedOneWithoutTermDatesInput = {
    create?: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTermDatesInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutTermDatesNestedInput = {
    create?: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTermDatesInput
    upsert?: SchoolUpsertWithoutTermDatesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTermDatesInput, SchoolUpdateWithoutTermDatesInput>, SchoolUncheckedUpdateWithoutTermDatesInput>
  }

  export type ClassCreateNestedOneWithoutScheduleItemsInput = {
    create?: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutScheduleItemsInput
    connect?: ClassWhereUniqueInput
  }

  export type YearGroupCreateNestedOneWithoutScheduleItemsInput = {
    create?: XOR<YearGroupCreateWithoutScheduleItemsInput, YearGroupUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutScheduleItemsInput
    connect?: YearGroupWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutScheduleItemsInput = {
    create?: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutScheduleItemsInput
    connect?: SchoolWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassUpdateOneWithoutScheduleItemsNestedInput = {
    create?: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutScheduleItemsInput
    upsert?: ClassUpsertWithoutScheduleItemsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutScheduleItemsInput, ClassUpdateWithoutScheduleItemsInput>, ClassUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type YearGroupUpdateOneWithoutScheduleItemsNestedInput = {
    create?: XOR<YearGroupCreateWithoutScheduleItemsInput, YearGroupUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: YearGroupCreateOrConnectWithoutScheduleItemsInput
    upsert?: YearGroupUpsertWithoutScheduleItemsInput
    disconnect?: YearGroupWhereInput | boolean
    delete?: YearGroupWhereInput | boolean
    connect?: YearGroupWhereUniqueInput
    update?: XOR<XOR<YearGroupUpdateToOneWithWhereWithoutScheduleItemsInput, YearGroupUpdateWithoutScheduleItemsInput>, YearGroupUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type SchoolUpdateOneRequiredWithoutScheduleItemsNestedInput = {
    create?: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutScheduleItemsInput
    upsert?: SchoolUpsertWithoutScheduleItemsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutScheduleItemsInput, SchoolUpdateWithoutScheduleItemsInput>, SchoolUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type SchoolCreateNestedOneWithoutWeeklyMessagesInput = {
    create?: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutWeeklyMessagesInput
    connect?: SchoolWhereUniqueInput
  }

  export type WeeklyMessageHeartCreateNestedManyWithoutMessageInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type WeeklyMessageHeartUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutWeeklyMessagesNestedInput = {
    create?: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutWeeklyMessagesInput
    upsert?: SchoolUpsertWithoutWeeklyMessagesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutWeeklyMessagesInput, SchoolUpdateWithoutWeeklyMessagesInput>, SchoolUncheckedUpdateWithoutWeeklyMessagesInput>
  }

  export type WeeklyMessageHeartUpdateManyWithoutMessageNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput | WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput> | WeeklyMessageHeartCreateWithoutMessageInput[] | WeeklyMessageHeartUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: WeeklyMessageHeartCreateOrConnectWithoutMessageInput | WeeklyMessageHeartCreateOrConnectWithoutMessageInput[]
    upsert?: WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: WeeklyMessageHeartCreateManyMessageInputEnvelope
    set?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    disconnect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    delete?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    connect?: WeeklyMessageHeartWhereUniqueInput | WeeklyMessageHeartWhereUniqueInput[]
    update?: WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput | WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput | WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
  }

  export type WeeklyMessageCreateNestedOneWithoutHeartsInput = {
    create?: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutHeartsInput
    connect?: WeeklyMessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWeeklyHeartsInput = {
    create?: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeeklyHeartsInput
    connect?: UserWhereUniqueInput
  }

  export type WeeklyMessageUpdateOneRequiredWithoutHeartsNestedInput = {
    create?: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
    connectOrCreate?: WeeklyMessageCreateOrConnectWithoutHeartsInput
    upsert?: WeeklyMessageUpsertWithoutHeartsInput
    connect?: WeeklyMessageWhereUniqueInput
    update?: XOR<XOR<WeeklyMessageUpdateToOneWithWhereWithoutHeartsInput, WeeklyMessageUpdateWithoutHeartsInput>, WeeklyMessageUncheckedUpdateWithoutHeartsInput>
  }

  export type UserUpdateOneRequiredWithoutWeeklyHeartsNestedInput = {
    create?: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeeklyHeartsInput
    upsert?: UserUpsertWithoutWeeklyHeartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWeeklyHeartsInput, UserUpdateWithoutWeeklyHeartsInput>, UserUncheckedUpdateWithoutWeeklyHeartsInput>
  }

  export type SchoolCreateNestedOneWithoutKnowledgeCategoriesInput = {
    create?: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutKnowledgeCategoriesInput
    connect?: SchoolWhereUniqueInput
  }

  export type KnowledgeArticleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
  }

  export type KnowledgeArticleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutKnowledgeCategoriesNestedInput = {
    create?: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutKnowledgeCategoriesInput
    upsert?: SchoolUpsertWithoutKnowledgeCategoriesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutKnowledgeCategoriesInput, SchoolUpdateWithoutKnowledgeCategoriesInput>, SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput>
  }

  export type KnowledgeArticleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    set?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    disconnect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    delete?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    update?: KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput | KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
  }

  export type KnowledgeArticleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput> | KnowledgeArticleCreateWithoutCategoryInput[] | KnowledgeArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeArticleCreateOrConnectWithoutCategoryInput | KnowledgeArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KnowledgeArticleCreateManyCategoryInputEnvelope
    set?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    disconnect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    delete?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    connect?: KnowledgeArticleWhereUniqueInput | KnowledgeArticleWhereUniqueInput[]
    update?: KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput | KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput | KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
  }

  export type KnowledgeCategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutArticlesInput
    connect?: KnowledgeCategoryWhereUniqueInput
  }

  export type KnowledgeCategoryUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: KnowledgeCategoryCreateOrConnectWithoutArticlesInput
    upsert?: KnowledgeCategoryUpsertWithoutArticlesInput
    connect?: KnowledgeCategoryWhereUniqueInput
    update?: XOR<XOR<KnowledgeCategoryUpdateToOneWithWhereWithoutArticlesInput, KnowledgeCategoryUpdateWithoutArticlesInput>, KnowledgeCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type SchoolCreateNestedOneWithoutPulseSurveysInput = {
    create?: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPulseSurveysInput
    connect?: SchoolWhereUniqueInput
  }

  export type PulseResponseCreateNestedManyWithoutPulseInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type PulseResponseUncheckedCreateNestedManyWithoutPulseInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutPulseSurveysNestedInput = {
    create?: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPulseSurveysInput
    upsert?: SchoolUpsertWithoutPulseSurveysInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutPulseSurveysInput, SchoolUpdateWithoutPulseSurveysInput>, SchoolUncheckedUpdateWithoutPulseSurveysInput>
  }

  export type PulseResponseUpdateManyWithoutPulseNestedInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutPulseInput | PulseResponseUpsertWithWhereUniqueWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutPulseInput | PulseResponseUpdateWithWhereUniqueWithoutPulseInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutPulseInput | PulseResponseUpdateManyWithWhereWithoutPulseInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type PulseResponseUncheckedUpdateManyWithoutPulseNestedInput = {
    create?: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput> | PulseResponseCreateWithoutPulseInput[] | PulseResponseUncheckedCreateWithoutPulseInput[]
    connectOrCreate?: PulseResponseCreateOrConnectWithoutPulseInput | PulseResponseCreateOrConnectWithoutPulseInput[]
    upsert?: PulseResponseUpsertWithWhereUniqueWithoutPulseInput | PulseResponseUpsertWithWhereUniqueWithoutPulseInput[]
    createMany?: PulseResponseCreateManyPulseInputEnvelope
    set?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    disconnect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    delete?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    connect?: PulseResponseWhereUniqueInput | PulseResponseWhereUniqueInput[]
    update?: PulseResponseUpdateWithWhereUniqueWithoutPulseInput | PulseResponseUpdateWithWhereUniqueWithoutPulseInput[]
    updateMany?: PulseResponseUpdateManyWithWhereWithoutPulseInput | PulseResponseUpdateManyWithWhereWithoutPulseInput[]
    deleteMany?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
  }

  export type PulseSurveyCreateNestedOneWithoutResponsesInput = {
    create?: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutResponsesInput
    connect?: PulseSurveyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPulseResponsesInput = {
    create?: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPulseResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type PulseSurveyUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PulseSurveyCreateOrConnectWithoutResponsesInput
    upsert?: PulseSurveyUpsertWithoutResponsesInput
    connect?: PulseSurveyWhereUniqueInput
    update?: XOR<XOR<PulseSurveyUpdateToOneWithWhereWithoutResponsesInput, PulseSurveyUpdateWithoutResponsesInput>, PulseSurveyUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutPulseResponsesNestedInput = {
    create?: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPulseResponsesInput
    upsert?: UserUpsertWithoutPulseResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPulseResponsesInput, UserUpdateWithoutPulseResponsesInput>, UserUncheckedUpdateWithoutPulseResponsesInput>
  }

  export type SchoolCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPoliciesInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutPoliciesNestedInput = {
    create?: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPoliciesInput
    upsert?: SchoolUpsertWithoutPoliciesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutPoliciesInput, SchoolUpdateWithoutPoliciesInput>, SchoolUncheckedUpdateWithoutPoliciesInput>
  }

  export type FileFolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutChildrenInput
    connect?: FileFolderWhereUniqueInput
  }

  export type FileFolderCreateNestedManyWithoutParentInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutFoldersInput = {
    create?: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFoldersInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolFileCreateNestedManyWithoutFolderInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type FileFolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
  }

  export type SchoolFileUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
  }

  export type FileFolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutChildrenInput
    upsert?: FileFolderUpsertWithoutChildrenInput
    disconnect?: FileFolderWhereInput | boolean
    delete?: FileFolderWhereInput | boolean
    connect?: FileFolderWhereUniqueInput
    update?: XOR<XOR<FileFolderUpdateToOneWithWhereWithoutChildrenInput, FileFolderUpdateWithoutChildrenInput>, FileFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FileFolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutParentInput | FileFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutParentInput | FileFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutParentInput | FileFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFoldersInput
    upsert?: SchoolUpsertWithoutFoldersInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFoldersInput, SchoolUpdateWithoutFoldersInput>, SchoolUncheckedUpdateWithoutFoldersInput>
  }

  export type SchoolFileUpdateManyWithoutFolderNestedInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutFolderInput | SchoolFileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutFolderInput | SchoolFileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutFolderInput | SchoolFileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type FileFolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput> | FileFolderCreateWithoutParentInput[] | FileFolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FileFolderCreateOrConnectWithoutParentInput | FileFolderCreateOrConnectWithoutParentInput[]
    upsert?: FileFolderUpsertWithWhereUniqueWithoutParentInput | FileFolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FileFolderCreateManyParentInputEnvelope
    set?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    disconnect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    delete?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    connect?: FileFolderWhereUniqueInput | FileFolderWhereUniqueInput[]
    update?: FileFolderUpdateWithWhereUniqueWithoutParentInput | FileFolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FileFolderUpdateManyWithWhereWithoutParentInput | FileFolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
  }

  export type SchoolFileUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput> | SchoolFileCreateWithoutFolderInput[] | SchoolFileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: SchoolFileCreateOrConnectWithoutFolderInput | SchoolFileCreateOrConnectWithoutFolderInput[]
    upsert?: SchoolFileUpsertWithWhereUniqueWithoutFolderInput | SchoolFileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: SchoolFileCreateManyFolderInputEnvelope
    set?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    disconnect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    delete?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    connect?: SchoolFileWhereUniqueInput | SchoolFileWhereUniqueInput[]
    update?: SchoolFileUpdateWithWhereUniqueWithoutFolderInput | SchoolFileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: SchoolFileUpdateManyWithWhereWithoutFolderInput | SchoolFileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
  }

  export type FileFolderCreateNestedOneWithoutFilesInput = {
    create?: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutFilesInput
    connect?: FileFolderWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutFilesInput = {
    create?: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFilesInput
    connect?: SchoolWhereUniqueInput
  }

  export type FileFolderUpdateOneWithoutFilesNestedInput = {
    create?: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FileFolderCreateOrConnectWithoutFilesInput
    upsert?: FileFolderUpsertWithoutFilesInput
    disconnect?: FileFolderWhereInput | boolean
    delete?: FileFolderWhereInput | boolean
    connect?: FileFolderWhereUniqueInput
    update?: XOR<XOR<FileFolderUpdateToOneWithWhereWithoutFilesInput, FileFolderUpdateWithoutFilesInput>, FileFolderUncheckedUpdateWithoutFilesInput>
  }

  export type SchoolUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFilesInput
    upsert?: SchoolUpsertWithoutFilesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFilesInput, SchoolUpdateWithoutFilesInput>, SchoolUncheckedUpdateWithoutFilesInput>
  }

  export type SchoolCreateNestedOneWithoutFormsInput = {
    create?: XOR<SchoolCreateWithoutFormsInput, SchoolUncheckedCreateWithoutFormsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFormsInput
    connect?: SchoolWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutFormInput = {
    create?: XOR<MessageCreateWithoutFormInput, MessageUncheckedCreateWithoutFormInput>
    connectOrCreate?: MessageCreateOrConnectWithoutFormInput
    connect?: MessageWhereUniqueInput
  }

  export type FormResponseCreateNestedManyWithoutFormInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedOneWithoutFormInput = {
    create?: XOR<MessageCreateWithoutFormInput, MessageUncheckedCreateWithoutFormInput>
    connectOrCreate?: MessageCreateOrConnectWithoutFormInput
    connect?: MessageWhereUniqueInput
  }

  export type FormResponseUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutFormsNestedInput = {
    create?: XOR<SchoolCreateWithoutFormsInput, SchoolUncheckedCreateWithoutFormsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFormsInput
    upsert?: SchoolUpsertWithoutFormsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFormsInput, SchoolUpdateWithoutFormsInput>, SchoolUncheckedUpdateWithoutFormsInput>
  }

  export type MessageUpdateOneWithoutFormNestedInput = {
    create?: XOR<MessageCreateWithoutFormInput, MessageUncheckedCreateWithoutFormInput>
    connectOrCreate?: MessageCreateOrConnectWithoutFormInput
    upsert?: MessageUpsertWithoutFormInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutFormInput, MessageUpdateWithoutFormInput>, MessageUncheckedUpdateWithoutFormInput>
  }

  export type FormResponseUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutFormInput | FormResponseUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutFormInput | FormResponseUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutFormInput | FormResponseUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type MessageUncheckedUpdateOneWithoutFormNestedInput = {
    create?: XOR<MessageCreateWithoutFormInput, MessageUncheckedCreateWithoutFormInput>
    connectOrCreate?: MessageCreateOrConnectWithoutFormInput
    upsert?: MessageUpsertWithoutFormInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutFormInput, MessageUpdateWithoutFormInput>, MessageUncheckedUpdateWithoutFormInput>
  }

  export type FormResponseUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutFormInput | FormResponseUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutFormInput | FormResponseUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutFormInput | FormResponseUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type FormCreateNestedOneWithoutResponsesInput = {
    create?: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: FormCreateOrConnectWithoutResponsesInput
    connect?: FormWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFormResponsesInput = {
    create?: XOR<UserCreateWithoutFormResponsesInput, UserUncheckedCreateWithoutFormResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type FormUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: FormCreateOrConnectWithoutResponsesInput
    upsert?: FormUpsertWithoutResponsesInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutResponsesInput, FormUpdateWithoutResponsesInput>, FormUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutFormResponsesNestedInput = {
    create?: XOR<UserCreateWithoutFormResponsesInput, UserUncheckedCreateWithoutFormResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormResponsesInput
    upsert?: UserUpsertWithoutFormResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFormResponsesInput, UserUpdateWithoutFormResponsesInput>, UserUncheckedUpdateWithoutFormResponsesInput>
  }

  export type SchoolCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<SchoolCreateWithoutInvitationsInput, SchoolUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutInvitationsInput
    connect?: SchoolWhereUniqueInput
  }

  export type ChildInvitationLinkCreateNestedManyWithoutInvitationInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutInvitationInput, ChildInvitationLinkUncheckedCreateWithoutInvitationInput> | ChildInvitationLinkCreateWithoutInvitationInput[] | ChildInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutInvitationInput | ChildInvitationLinkCreateOrConnectWithoutInvitationInput[]
    createMany?: ChildInvitationLinkCreateManyInvitationInputEnvelope
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
  }

  export type StudentInvitationLinkCreateNestedManyWithoutInvitationInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutInvitationInput, StudentInvitationLinkUncheckedCreateWithoutInvitationInput> | StudentInvitationLinkCreateWithoutInvitationInput[] | StudentInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutInvitationInput | StudentInvitationLinkCreateOrConnectWithoutInvitationInput[]
    createMany?: StudentInvitationLinkCreateManyInvitationInputEnvelope
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutRedeemedInvitationsInput = {
    create?: XOR<UserCreateWithoutRedeemedInvitationsInput, UserUncheckedCreateWithoutRedeemedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedInvitationsInput = {
    create?: XOR<UserCreateWithoutCreatedInvitationsInput, UserUncheckedCreateWithoutCreatedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type ChildInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutInvitationInput, ChildInvitationLinkUncheckedCreateWithoutInvitationInput> | ChildInvitationLinkCreateWithoutInvitationInput[] | ChildInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutInvitationInput | ChildInvitationLinkCreateOrConnectWithoutInvitationInput[]
    createMany?: ChildInvitationLinkCreateManyInvitationInputEnvelope
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
  }

  export type StudentInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutInvitationInput, StudentInvitationLinkUncheckedCreateWithoutInvitationInput> | StudentInvitationLinkCreateWithoutInvitationInput[] | StudentInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutInvitationInput | StudentInvitationLinkCreateOrConnectWithoutInvitationInput[]
    createMany?: StudentInvitationLinkCreateManyInvitationInputEnvelope
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<SchoolCreateWithoutInvitationsInput, SchoolUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutInvitationsInput
    upsert?: SchoolUpsertWithoutInvitationsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutInvitationsInput, SchoolUpdateWithoutInvitationsInput>, SchoolUncheckedUpdateWithoutInvitationsInput>
  }

  export type ChildInvitationLinkUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutInvitationInput, ChildInvitationLinkUncheckedCreateWithoutInvitationInput> | ChildInvitationLinkCreateWithoutInvitationInput[] | ChildInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutInvitationInput | ChildInvitationLinkCreateOrConnectWithoutInvitationInput[]
    upsert?: ChildInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput | ChildInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: ChildInvitationLinkCreateManyInvitationInputEnvelope
    set?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    disconnect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    delete?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    update?: ChildInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput | ChildInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: ChildInvitationLinkUpdateManyWithWhereWithoutInvitationInput | ChildInvitationLinkUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: ChildInvitationLinkScalarWhereInput | ChildInvitationLinkScalarWhereInput[]
  }

  export type StudentInvitationLinkUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutInvitationInput, StudentInvitationLinkUncheckedCreateWithoutInvitationInput> | StudentInvitationLinkCreateWithoutInvitationInput[] | StudentInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutInvitationInput | StudentInvitationLinkCreateOrConnectWithoutInvitationInput[]
    upsert?: StudentInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput | StudentInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: StudentInvitationLinkCreateManyInvitationInputEnvelope
    set?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    disconnect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    delete?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    update?: StudentInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput | StudentInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: StudentInvitationLinkUpdateManyWithWhereWithoutInvitationInput | StudentInvitationLinkUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: StudentInvitationLinkScalarWhereInput | StudentInvitationLinkScalarWhereInput[]
  }

  export type UserUpdateOneWithoutRedeemedInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutRedeemedInvitationsInput, UserUncheckedCreateWithoutRedeemedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedInvitationsInput
    upsert?: UserUpsertWithoutRedeemedInvitationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRedeemedInvitationsInput, UserUpdateWithoutRedeemedInvitationsInput>, UserUncheckedUpdateWithoutRedeemedInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedInvitationsInput, UserUncheckedCreateWithoutCreatedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvitationsInput
    upsert?: UserUpsertWithoutCreatedInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedInvitationsInput, UserUpdateWithoutCreatedInvitationsInput>, UserUncheckedUpdateWithoutCreatedInvitationsInput>
  }

  export type ChildInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<ChildInvitationLinkCreateWithoutInvitationInput, ChildInvitationLinkUncheckedCreateWithoutInvitationInput> | ChildInvitationLinkCreateWithoutInvitationInput[] | ChildInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: ChildInvitationLinkCreateOrConnectWithoutInvitationInput | ChildInvitationLinkCreateOrConnectWithoutInvitationInput[]
    upsert?: ChildInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput | ChildInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: ChildInvitationLinkCreateManyInvitationInputEnvelope
    set?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    disconnect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    delete?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    connect?: ChildInvitationLinkWhereUniqueInput | ChildInvitationLinkWhereUniqueInput[]
    update?: ChildInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput | ChildInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: ChildInvitationLinkUpdateManyWithWhereWithoutInvitationInput | ChildInvitationLinkUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: ChildInvitationLinkScalarWhereInput | ChildInvitationLinkScalarWhereInput[]
  }

  export type StudentInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<StudentInvitationLinkCreateWithoutInvitationInput, StudentInvitationLinkUncheckedCreateWithoutInvitationInput> | StudentInvitationLinkCreateWithoutInvitationInput[] | StudentInvitationLinkUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: StudentInvitationLinkCreateOrConnectWithoutInvitationInput | StudentInvitationLinkCreateOrConnectWithoutInvitationInput[]
    upsert?: StudentInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput | StudentInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: StudentInvitationLinkCreateManyInvitationInputEnvelope
    set?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    disconnect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    delete?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    connect?: StudentInvitationLinkWhereUniqueInput | StudentInvitationLinkWhereUniqueInput[]
    update?: StudentInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput | StudentInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: StudentInvitationLinkUpdateManyWithWhereWithoutInvitationInput | StudentInvitationLinkUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: StudentInvitationLinkScalarWhereInput | StudentInvitationLinkScalarWhereInput[]
  }

  export type ParentInvitationCreateNestedOneWithoutChildLinksInput = {
    create?: XOR<ParentInvitationCreateWithoutChildLinksInput, ParentInvitationUncheckedCreateWithoutChildLinksInput>
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutChildLinksInput
    connect?: ParentInvitationWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutChildInvitationLinksInput = {
    create?: XOR<ClassCreateWithoutChildInvitationLinksInput, ClassUncheckedCreateWithoutChildInvitationLinksInput>
    connectOrCreate?: ClassCreateOrConnectWithoutChildInvitationLinksInput
    connect?: ClassWhereUniqueInput
  }

  export type ParentInvitationUpdateOneRequiredWithoutChildLinksNestedInput = {
    create?: XOR<ParentInvitationCreateWithoutChildLinksInput, ParentInvitationUncheckedCreateWithoutChildLinksInput>
    connectOrCreate?: ParentInvitationCreateOrConnectWithoutChildLinksInput
    upsert?: ParentInvitationUpsertWithoutChildLinksInput
    connect?: ParentInvitationWhereUniqueInput
    update?: XOR<XOR<ParentInvitationUpdateToOneWithWhereWithoutChildLinksInput, ParentInvitationUpdateWithoutChildLinksInput>, ParentInvitationUncheckedUpdateWithoutChildLinksInput>
  }

  export type ClassUpdateOneRequiredWithoutChildInvitationLinksNestedInput = {
    create?: XOR<ClassCreateWithoutChildInvitationLinksInput, ClassUncheckedCreateWithoutChildInvitationLinksInput>
    connectOrCreate?: ClassCreateOrConnectWithoutChildInvitationLinksInput
    upsert?: ClassUpsertWithoutChildInvitationLinksInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutChildInvitationLinksInput, ClassUpdateWithoutChildInvitationLinksInput>, ClassUncheckedUpdateWithoutChildInvitationLinksInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<SchoolCreateWithoutAuditLogsInput, SchoolUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAuditLogsInput
    connect?: SchoolWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type EnumAuditResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditResourceType
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type SchoolUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<SchoolCreateWithoutAuditLogsInput, SchoolUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAuditLogsInput
    upsert?: SchoolUpsertWithoutAuditLogsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAuditLogsInput, SchoolUpdateWithoutAuditLogsInput>, SchoolUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<SchoolCreateWithoutNotificationsInput, SchoolUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutNotificationsInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type SchoolUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<SchoolCreateWithoutNotificationsInput, SchoolUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutNotificationsInput
    upsert?: SchoolUpsertWithoutNotificationsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutNotificationsInput, SchoolUpdateWithoutNotificationsInput>, SchoolUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutDeviceTokensInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeviceTokensNestedInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    upsert?: UserUpsertWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceTokensInput, UserUpdateWithoutDeviceTokensInput>, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditResourceType | EnumAuditResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditResourceTypeFilter<$PrismaModel> | $Enums.AuditResourceType
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumAuditResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditResourceType | EnumAuditResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditResourceType[] | ListEnumAuditResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditResourceTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type YearGroupCreateWithoutSchoolInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutYearGroupInput
    messages?: MessageCreateNestedManyWithoutYearGroupInput
    events?: EventCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutYearGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutYearGroupInput
    events?: EventUncheckedCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupCreateOrConnectWithoutSchoolInput = {
    where: YearGroupWhereUniqueInput
    create: XOR<YearGroupCreateWithoutSchoolInput, YearGroupUncheckedCreateWithoutSchoolInput>
  }

  export type YearGroupCreateManySchoolInputEnvelope = {
    data: YearGroupCreateManySchoolInput | YearGroupCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutSchoolInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateManySchoolInputEnvelope = {
    data: ClassCreateManySchoolInput | ClassCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutSchoolInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsInput
    parentLinks?: ParentStudentLinkCreateNestedManyWithoutStudentInput
    invitationLinks?: StudentInvitationLinkCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSchoolInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutStudentInput
    invitationLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentCreateManySchoolInputEnvelope = {
    data: StudentCreateManySchoolInput | StudentCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    yearGroup?: YearGroupCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    form?: FormCreateNestedOneWithoutMessageInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSchoolInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput>
  }

  export type MessageCreateManySchoolInputEnvelope = {
    data: MessageCreateManySchoolInput | MessageCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type FormCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: MessageCreateNestedOneWithoutFormInput
    responses?: FormResponseCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: MessageUncheckedCreateNestedOneWithoutFormInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutSchoolInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutSchoolInput, FormUncheckedCreateWithoutSchoolInput>
  }

  export type FormCreateManySchoolInputEnvelope = {
    data: FormCreateManySchoolInput | FormCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutEventsInput
    yearGroup?: YearGroupCreateNestedOneWithoutEventsInput
    rsvps?: EventRsvpCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: EventRsvpUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutSchoolInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput>
  }

  export type EventCreateManySchoolInputEnvelope = {
    data: EventCreateManySchoolInput | EventCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type TermDateCreateWithoutSchoolInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
  }

  export type TermDateUncheckedCreateWithoutSchoolInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
  }

  export type TermDateCreateOrConnectWithoutSchoolInput = {
    where: TermDateWhereUniqueInput
    create: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput>
  }

  export type TermDateCreateManySchoolInputEnvelope = {
    data: TermDateCreateManySchoolInput | TermDateCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleItemCreateWithoutSchoolInput = {
    id?: string
    targetClass: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutScheduleItemsInput
    yearGroup?: YearGroupCreateNestedOneWithoutScheduleItemsInput
  }

  export type ScheduleItemUncheckedCreateWithoutSchoolInput = {
    id?: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemCreateOrConnectWithoutSchoolInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput>
  }

  export type ScheduleItemCreateManySchoolInputEnvelope = {
    data: ScheduleItemCreateManySchoolInput | ScheduleItemCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyMessageCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    hearts?: WeeklyMessageHeartCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    hearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutMessageInput
  }

  export type WeeklyMessageCreateOrConnectWithoutSchoolInput = {
    where: WeeklyMessageWhereUniqueInput
    create: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput>
  }

  export type WeeklyMessageCreateManySchoolInputEnvelope = {
    data: WeeklyMessageCreateManySchoolInput | WeeklyMessageCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeCategoryCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    articles?: KnowledgeArticleCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    articles?: KnowledgeArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeCategoryCreateOrConnectWithoutSchoolInput = {
    where: KnowledgeCategoryWhereUniqueInput
    create: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput>
  }

  export type KnowledgeCategoryCreateManySchoolInputEnvelope = {
    data: KnowledgeCategoryCreateManySchoolInput | KnowledgeCategoryCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type PulseSurveyCreateWithoutSchoolInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    createdAt?: Date | string
    responses?: PulseResponseCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyUncheckedCreateWithoutSchoolInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    createdAt?: Date | string
    responses?: PulseResponseUncheckedCreateNestedManyWithoutPulseInput
  }

  export type PulseSurveyCreateOrConnectWithoutSchoolInput = {
    where: PulseSurveyWhereUniqueInput
    create: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput>
  }

  export type PulseSurveyCreateManySchoolInputEnvelope = {
    data: PulseSurveyCreateManySchoolInput | PulseSurveyCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type PolicyCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PolicyCreateOrConnectWithoutSchoolInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput>
  }

  export type PolicyCreateManySchoolInputEnvelope = {
    data: PolicyCreateManySchoolInput | PolicyCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type FileFolderCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    children?: FileFolderCreateNestedManyWithoutParentInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderCreateOrConnectWithoutSchoolInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput>
  }

  export type FileFolderCreateManySchoolInputEnvelope = {
    data: FileFolderCreateManySchoolInput | FileFolderCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolFileCreateWithoutSchoolInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    folder?: FileFolderCreateNestedOneWithoutFilesInput
  }

  export type SchoolFileUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileCreateOrConnectWithoutSchoolInput = {
    where: SchoolFileWhereUniqueInput
    create: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolFileCreateManySchoolInputEnvelope = {
    data: SchoolFileCreateManySchoolInput | SchoolFileCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutSchoolInput = {
    id?: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutSchoolInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutSchoolInput, AuditLogUncheckedCreateWithoutSchoolInput>
  }

  export type AuditLogCreateManySchoolInputEnvelope = {
    data: AuditLogCreateManySchoolInput | AuditLogCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSchoolInput = {
    id?: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSchoolInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSchoolInput, NotificationUncheckedCreateWithoutSchoolInput>
  }

  export type NotificationCreateManySchoolInputEnvelope = {
    data: NotificationCreateManySchoolInput | NotificationCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ParentInvitationCreateWithoutSchoolInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    childLinks?: ChildInvitationLinkCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkCreateNestedManyWithoutInvitationInput
    redeemedByUser?: UserCreateNestedOneWithoutRedeemedInvitationsInput
    createdBy: UserCreateNestedOneWithoutCreatedInvitationsInput
  }

  export type ParentInvitationUncheckedCreateWithoutSchoolInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdById: string
    createdAt?: Date | string
    childLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type ParentInvitationCreateOrConnectWithoutSchoolInput = {
    where: ParentInvitationWhereUniqueInput
    create: XOR<ParentInvitationCreateWithoutSchoolInput, ParentInvitationUncheckedCreateWithoutSchoolInput>
  }

  export type ParentInvitationCreateManySchoolInputEnvelope = {
    data: ParentInvitationCreateManySchoolInput | ParentInvitationCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    schoolId?: StringFilter<"User"> | string
    googleId?: StringNullableFilter<"User"> | string | null
    microsoftId?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type YearGroupUpsertWithWhereUniqueWithoutSchoolInput = {
    where: YearGroupWhereUniqueInput
    update: XOR<YearGroupUpdateWithoutSchoolInput, YearGroupUncheckedUpdateWithoutSchoolInput>
    create: XOR<YearGroupCreateWithoutSchoolInput, YearGroupUncheckedCreateWithoutSchoolInput>
  }

  export type YearGroupUpdateWithWhereUniqueWithoutSchoolInput = {
    where: YearGroupWhereUniqueInput
    data: XOR<YearGroupUpdateWithoutSchoolInput, YearGroupUncheckedUpdateWithoutSchoolInput>
  }

  export type YearGroupUpdateManyWithWhereWithoutSchoolInput = {
    where: YearGroupScalarWhereInput
    data: XOR<YearGroupUpdateManyMutationInput, YearGroupUncheckedUpdateManyWithoutSchoolInput>
  }

  export type YearGroupScalarWhereInput = {
    AND?: YearGroupScalarWhereInput | YearGroupScalarWhereInput[]
    OR?: YearGroupScalarWhereInput[]
    NOT?: YearGroupScalarWhereInput | YearGroupScalarWhereInput[]
    id?: StringFilter<"YearGroup"> | string
    name?: StringFilter<"YearGroup"> | string
    order?: IntFilter<"YearGroup"> | number
    schoolId?: StringFilter<"YearGroup"> | string
    createdAt?: DateTimeFilter<"YearGroup"> | Date | string
    updatedAt?: DateTimeFilter<"YearGroup"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    colorBg?: StringFilter<"Class"> | string
    colorText?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    yearGroupId?: StringNullableFilter<"Class"> | string | null
  }

  export type StudentUpsertWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
  }

  export type StudentUpdateManyWithWhereWithoutSchoolInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    externalId?: StringNullableFilter<"Student"> | string | null
    schoolId?: StringFilter<"Student"> | string
    classId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSchoolInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSchoolInput, MessageUncheckedUpdateWithoutSchoolInput>
    create: XOR<MessageCreateWithoutSchoolInput, MessageUncheckedCreateWithoutSchoolInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSchoolInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSchoolInput, MessageUncheckedUpdateWithoutSchoolInput>
  }

  export type MessageUpdateManyWithWhereWithoutSchoolInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSchoolInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    title?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    targetClass?: StringFilter<"Message"> | string
    classId?: StringNullableFilter<"Message"> | string | null
    yearGroupId?: StringNullableFilter<"Message"> | string | null
    schoolId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderName?: StringFilter<"Message"> | string
    actionType?: StringNullableFilter<"Message"> | string | null
    actionLabel?: StringNullableFilter<"Message"> | string | null
    actionDueDate?: DateTimeNullableFilter<"Message"> | Date | string | null
    actionAmount?: StringNullableFilter<"Message"> | string | null
    isPinned?: BoolFilter<"Message"> | boolean
    isUrgent?: BoolFilter<"Message"> | boolean
    expiresAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    formId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type FormUpsertWithWhereUniqueWithoutSchoolInput = {
    where: FormWhereUniqueInput
    update: XOR<FormUpdateWithoutSchoolInput, FormUncheckedUpdateWithoutSchoolInput>
    create: XOR<FormCreateWithoutSchoolInput, FormUncheckedCreateWithoutSchoolInput>
  }

  export type FormUpdateWithWhereUniqueWithoutSchoolInput = {
    where: FormWhereUniqueInput
    data: XOR<FormUpdateWithoutSchoolInput, FormUncheckedUpdateWithoutSchoolInput>
  }

  export type FormUpdateManyWithWhereWithoutSchoolInput = {
    where: FormScalarWhereInput
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyWithoutSchoolInput>
  }

  export type FormScalarWhereInput = {
    AND?: FormScalarWhereInput | FormScalarWhereInput[]
    OR?: FormScalarWhereInput[]
    NOT?: FormScalarWhereInput | FormScalarWhereInput[]
    id?: StringFilter<"Form"> | string
    title?: StringFilter<"Form"> | string
    description?: StringNullableFilter<"Form"> | string | null
    type?: StringFilter<"Form"> | string
    status?: StringFilter<"Form"> | string
    fields?: JsonFilter<"Form">
    targetClass?: StringFilter<"Form"> | string
    classIds?: JsonFilter<"Form">
    yearGroupIds?: JsonFilter<"Form">
    schoolId?: StringFilter<"Form"> | string
    expiresAt?: DateTimeNullableFilter<"Form"> | Date | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutSchoolInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutSchoolInput, EventUncheckedUpdateWithoutSchoolInput>
    create: XOR<EventCreateWithoutSchoolInput, EventUncheckedCreateWithoutSchoolInput>
  }

  export type EventUpdateWithWhereUniqueWithoutSchoolInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutSchoolInput, EventUncheckedUpdateWithoutSchoolInput>
  }

  export type EventUpdateManyWithWhereWithoutSchoolInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutSchoolInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    targetClass?: StringFilter<"Event"> | string
    classId?: StringNullableFilter<"Event"> | string | null
    yearGroupId?: StringNullableFilter<"Event"> | string | null
    schoolId?: StringFilter<"Event"> | string
    requiresRsvp?: BoolFilter<"Event"> | boolean
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type TermDateUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TermDateWhereUniqueInput
    update: XOR<TermDateUpdateWithoutSchoolInput, TermDateUncheckedUpdateWithoutSchoolInput>
    create: XOR<TermDateCreateWithoutSchoolInput, TermDateUncheckedCreateWithoutSchoolInput>
  }

  export type TermDateUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TermDateWhereUniqueInput
    data: XOR<TermDateUpdateWithoutSchoolInput, TermDateUncheckedUpdateWithoutSchoolInput>
  }

  export type TermDateUpdateManyWithWhereWithoutSchoolInput = {
    where: TermDateScalarWhereInput
    data: XOR<TermDateUpdateManyMutationInput, TermDateUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TermDateScalarWhereInput = {
    AND?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
    OR?: TermDateScalarWhereInput[]
    NOT?: TermDateScalarWhereInput | TermDateScalarWhereInput[]
    id?: StringFilter<"TermDate"> | string
    term?: IntFilter<"TermDate"> | number
    termName?: StringFilter<"TermDate"> | string
    label?: StringFilter<"TermDate"> | string
    sublabel?: StringNullableFilter<"TermDate"> | string | null
    date?: DateTimeFilter<"TermDate"> | Date | string
    endDate?: DateTimeNullableFilter<"TermDate"> | Date | string | null
    type?: StringFilter<"TermDate"> | string
    color?: StringFilter<"TermDate"> | string
    schoolId?: StringFilter<"TermDate"> | string
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutSchoolInput, ScheduleItemUncheckedUpdateWithoutSchoolInput>
    create: XOR<ScheduleItemCreateWithoutSchoolInput, ScheduleItemUncheckedCreateWithoutSchoolInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutSchoolInput, ScheduleItemUncheckedUpdateWithoutSchoolInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutSchoolInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ScheduleItemScalarWhereInput = {
    AND?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
    OR?: ScheduleItemScalarWhereInput[]
    NOT?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
    id?: StringFilter<"ScheduleItem"> | string
    targetClass?: StringFilter<"ScheduleItem"> | string
    classId?: StringNullableFilter<"ScheduleItem"> | string | null
    yearGroupId?: StringNullableFilter<"ScheduleItem"> | string | null
    schoolId?: StringFilter<"ScheduleItem"> | string
    isRecurring?: BoolFilter<"ScheduleItem"> | boolean
    dayOfWeek?: IntNullableFilter<"ScheduleItem"> | number | null
    active?: BoolFilter<"ScheduleItem"> | boolean
    date?: DateTimeNullableFilter<"ScheduleItem"> | Date | string | null
    type?: StringFilter<"ScheduleItem"> | string
    label?: StringFilter<"ScheduleItem"> | string
    description?: StringNullableFilter<"ScheduleItem"> | string | null
    icon?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
  }

  export type WeeklyMessageUpsertWithWhereUniqueWithoutSchoolInput = {
    where: WeeklyMessageWhereUniqueInput
    update: XOR<WeeklyMessageUpdateWithoutSchoolInput, WeeklyMessageUncheckedUpdateWithoutSchoolInput>
    create: XOR<WeeklyMessageCreateWithoutSchoolInput, WeeklyMessageUncheckedCreateWithoutSchoolInput>
  }

  export type WeeklyMessageUpdateWithWhereUniqueWithoutSchoolInput = {
    where: WeeklyMessageWhereUniqueInput
    data: XOR<WeeklyMessageUpdateWithoutSchoolInput, WeeklyMessageUncheckedUpdateWithoutSchoolInput>
  }

  export type WeeklyMessageUpdateManyWithWhereWithoutSchoolInput = {
    where: WeeklyMessageScalarWhereInput
    data: XOR<WeeklyMessageUpdateManyMutationInput, WeeklyMessageUncheckedUpdateManyWithoutSchoolInput>
  }

  export type WeeklyMessageScalarWhereInput = {
    AND?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
    OR?: WeeklyMessageScalarWhereInput[]
    NOT?: WeeklyMessageScalarWhereInput | WeeklyMessageScalarWhereInput[]
    id?: StringFilter<"WeeklyMessage"> | string
    title?: StringFilter<"WeeklyMessage"> | string
    content?: StringFilter<"WeeklyMessage"> | string
    weekOf?: DateTimeFilter<"WeeklyMessage"> | Date | string
    isCurrent?: BoolFilter<"WeeklyMessage"> | boolean
    schoolId?: StringFilter<"WeeklyMessage"> | string
    createdAt?: DateTimeFilter<"WeeklyMessage"> | Date | string
  }

  export type KnowledgeCategoryUpsertWithWhereUniqueWithoutSchoolInput = {
    where: KnowledgeCategoryWhereUniqueInput
    update: XOR<KnowledgeCategoryUpdateWithoutSchoolInput, KnowledgeCategoryUncheckedUpdateWithoutSchoolInput>
    create: XOR<KnowledgeCategoryCreateWithoutSchoolInput, KnowledgeCategoryUncheckedCreateWithoutSchoolInput>
  }

  export type KnowledgeCategoryUpdateWithWhereUniqueWithoutSchoolInput = {
    where: KnowledgeCategoryWhereUniqueInput
    data: XOR<KnowledgeCategoryUpdateWithoutSchoolInput, KnowledgeCategoryUncheckedUpdateWithoutSchoolInput>
  }

  export type KnowledgeCategoryUpdateManyWithWhereWithoutSchoolInput = {
    where: KnowledgeCategoryScalarWhereInput
    data: XOR<KnowledgeCategoryUpdateManyMutationInput, KnowledgeCategoryUncheckedUpdateManyWithoutSchoolInput>
  }

  export type KnowledgeCategoryScalarWhereInput = {
    AND?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
    OR?: KnowledgeCategoryScalarWhereInput[]
    NOT?: KnowledgeCategoryScalarWhereInput | KnowledgeCategoryScalarWhereInput[]
    id?: StringFilter<"KnowledgeCategory"> | string
    name?: StringFilter<"KnowledgeCategory"> | string
    icon?: StringFilter<"KnowledgeCategory"> | string
    color?: StringFilter<"KnowledgeCategory"> | string
    order?: IntFilter<"KnowledgeCategory"> | number
    schoolId?: StringFilter<"KnowledgeCategory"> | string
  }

  export type PulseSurveyUpsertWithWhereUniqueWithoutSchoolInput = {
    where: PulseSurveyWhereUniqueInput
    update: XOR<PulseSurveyUpdateWithoutSchoolInput, PulseSurveyUncheckedUpdateWithoutSchoolInput>
    create: XOR<PulseSurveyCreateWithoutSchoolInput, PulseSurveyUncheckedCreateWithoutSchoolInput>
  }

  export type PulseSurveyUpdateWithWhereUniqueWithoutSchoolInput = {
    where: PulseSurveyWhereUniqueInput
    data: XOR<PulseSurveyUpdateWithoutSchoolInput, PulseSurveyUncheckedUpdateWithoutSchoolInput>
  }

  export type PulseSurveyUpdateManyWithWhereWithoutSchoolInput = {
    where: PulseSurveyScalarWhereInput
    data: XOR<PulseSurveyUpdateManyMutationInput, PulseSurveyUncheckedUpdateManyWithoutSchoolInput>
  }

  export type PulseSurveyScalarWhereInput = {
    AND?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
    OR?: PulseSurveyScalarWhereInput[]
    NOT?: PulseSurveyScalarWhereInput | PulseSurveyScalarWhereInput[]
    id?: StringFilter<"PulseSurvey"> | string
    halfTermName?: StringFilter<"PulseSurvey"> | string
    status?: StringFilter<"PulseSurvey"> | string
    opensAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    closesAt?: DateTimeFilter<"PulseSurvey"> | Date | string
    additionalQuestionKey?: StringNullableFilter<"PulseSurvey"> | string | null
    schoolId?: StringFilter<"PulseSurvey"> | string
    createdAt?: DateTimeFilter<"PulseSurvey"> | Date | string
  }

  export type PolicyUpsertWithWhereUniqueWithoutSchoolInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutSchoolInput, PolicyUncheckedUpdateWithoutSchoolInput>
    create: XOR<PolicyCreateWithoutSchoolInput, PolicyUncheckedCreateWithoutSchoolInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutSchoolInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutSchoolInput, PolicyUncheckedUpdateWithoutSchoolInput>
  }

  export type PolicyUpdateManyWithWhereWithoutSchoolInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutSchoolInput>
  }

  export type PolicyScalarWhereInput = {
    AND?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    OR?: PolicyScalarWhereInput[]
    NOT?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    id?: StringFilter<"Policy"> | string
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    fileUrl?: StringFilter<"Policy"> | string
    fileSize?: IntNullableFilter<"Policy"> | number | null
    schoolId?: StringFilter<"Policy"> | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    createdAt?: DateTimeFilter<"Policy"> | Date | string
  }

  export type FileFolderUpsertWithWhereUniqueWithoutSchoolInput = {
    where: FileFolderWhereUniqueInput
    update: XOR<FileFolderUpdateWithoutSchoolInput, FileFolderUncheckedUpdateWithoutSchoolInput>
    create: XOR<FileFolderCreateWithoutSchoolInput, FileFolderUncheckedCreateWithoutSchoolInput>
  }

  export type FileFolderUpdateWithWhereUniqueWithoutSchoolInput = {
    where: FileFolderWhereUniqueInput
    data: XOR<FileFolderUpdateWithoutSchoolInput, FileFolderUncheckedUpdateWithoutSchoolInput>
  }

  export type FileFolderUpdateManyWithWhereWithoutSchoolInput = {
    where: FileFolderScalarWhereInput
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyWithoutSchoolInput>
  }

  export type FileFolderScalarWhereInput = {
    AND?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
    OR?: FileFolderScalarWhereInput[]
    NOT?: FileFolderScalarWhereInput | FileFolderScalarWhereInput[]
    id?: StringFilter<"FileFolder"> | string
    name?: StringFilter<"FileFolder"> | string
    icon?: StringNullableFilter<"FileFolder"> | string | null
    color?: StringNullableFilter<"FileFolder"> | string | null
    parentId?: StringNullableFilter<"FileFolder"> | string | null
    schoolId?: StringFilter<"FileFolder"> | string
    order?: IntFilter<"FileFolder"> | number
    createdAt?: DateTimeFilter<"FileFolder"> | Date | string
  }

  export type SchoolFileUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolFileWhereUniqueInput
    update: XOR<SchoolFileUpdateWithoutSchoolInput, SchoolFileUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolFileCreateWithoutSchoolInput, SchoolFileUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolFileUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolFileWhereUniqueInput
    data: XOR<SchoolFileUpdateWithoutSchoolInput, SchoolFileUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolFileUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolFileScalarWhereInput
    data: XOR<SchoolFileUpdateManyMutationInput, SchoolFileUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolFileScalarWhereInput = {
    AND?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
    OR?: SchoolFileScalarWhereInput[]
    NOT?: SchoolFileScalarWhereInput | SchoolFileScalarWhereInput[]
    id?: StringFilter<"SchoolFile"> | string
    name?: StringFilter<"SchoolFile"> | string
    fileName?: StringFilter<"SchoolFile"> | string
    fileUrl?: StringFilter<"SchoolFile"> | string
    fileType?: StringFilter<"SchoolFile"> | string
    fileSize?: IntFilter<"SchoolFile"> | number
    folderId?: StringNullableFilter<"SchoolFile"> | string | null
    schoolId?: StringFilter<"SchoolFile"> | string
    uploadedAt?: DateTimeFilter<"SchoolFile"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolFile"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutSchoolInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutSchoolInput, AuditLogUncheckedUpdateWithoutSchoolInput>
    create: XOR<AuditLogCreateWithoutSchoolInput, AuditLogUncheckedCreateWithoutSchoolInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutSchoolInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutSchoolInput, AuditLogUncheckedUpdateWithoutSchoolInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutSchoolInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    userName?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFilter<"AuditLog"> | $Enums.AuditResourceType
    resourceId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    schoolId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSchoolInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSchoolInput, NotificationUncheckedUpdateWithoutSchoolInput>
    create: XOR<NotificationCreateWithoutSchoolInput, NotificationUncheckedCreateWithoutSchoolInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSchoolInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSchoolInput, NotificationUncheckedUpdateWithoutSchoolInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSchoolInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSchoolInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    resourceType?: StringNullableFilter<"Notification"> | string | null
    resourceId?: StringNullableFilter<"Notification"> | string | null
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    schoolId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ParentInvitationUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ParentInvitationWhereUniqueInput
    update: XOR<ParentInvitationUpdateWithoutSchoolInput, ParentInvitationUncheckedUpdateWithoutSchoolInput>
    create: XOR<ParentInvitationCreateWithoutSchoolInput, ParentInvitationUncheckedCreateWithoutSchoolInput>
  }

  export type ParentInvitationUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ParentInvitationWhereUniqueInput
    data: XOR<ParentInvitationUpdateWithoutSchoolInput, ParentInvitationUncheckedUpdateWithoutSchoolInput>
  }

  export type ParentInvitationUpdateManyWithWhereWithoutSchoolInput = {
    where: ParentInvitationScalarWhereInput
    data: XOR<ParentInvitationUpdateManyMutationInput, ParentInvitationUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ParentInvitationScalarWhereInput = {
    AND?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
    OR?: ParentInvitationScalarWhereInput[]
    NOT?: ParentInvitationScalarWhereInput | ParentInvitationScalarWhereInput[]
    id?: StringFilter<"ParentInvitation"> | string
    schoolId?: StringFilter<"ParentInvitation"> | string
    accessCode?: StringFilter<"ParentInvitation"> | string
    magicToken?: StringNullableFilter<"ParentInvitation"> | string | null
    parentEmail?: StringNullableFilter<"ParentInvitation"> | string | null
    parentName?: StringNullableFilter<"ParentInvitation"> | string | null
    status?: StringFilter<"ParentInvitation"> | string
    expiresAt?: DateTimeNullableFilter<"ParentInvitation"> | Date | string | null
    redeemedAt?: DateTimeNullableFilter<"ParentInvitation"> | Date | string | null
    redeemedByUserId?: StringNullableFilter<"ParentInvitation"> | string | null
    createdById?: StringFilter<"ParentInvitation"> | string
    createdAt?: DateTimeFilter<"ParentInvitation"> | Date | string
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type ChildCreateWithoutParentInput = {
    id?: string
    name: string
    class: ClassCreateNestedOneWithoutChildrenInput
  }

  export type ChildUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    classId: string
  }

  export type ChildCreateOrConnectWithoutParentInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput>
  }

  export type ChildCreateManyParentInputEnvelope = {
    data: ChildCreateManyParentInput | ChildCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ParentStudentLinkCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutParentLinksInput
  }

  export type ParentStudentLinkUncheckedCreateWithoutUserInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
  }

  export type ParentStudentLinkCreateOrConnectWithoutUserInput = {
    where: ParentStudentLinkWhereUniqueInput
    create: XOR<ParentStudentLinkCreateWithoutUserInput, ParentStudentLinkUncheckedCreateWithoutUserInput>
  }

  export type ParentStudentLinkCreateManyUserInputEnvelope = {
    data: ParentStudentLinkCreateManyUserInput | ParentStudentLinkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StaffClassAssignmentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    class: ClassCreateNestedOneWithoutAssignedStaffInput
  }

  export type StaffClassAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    classId: string
    createdAt?: Date | string
  }

  export type StaffClassAssignmentCreateOrConnectWithoutUserInput = {
    where: StaffClassAssignmentWhereUniqueInput
    create: XOR<StaffClassAssignmentCreateWithoutUserInput, StaffClassAssignmentUncheckedCreateWithoutUserInput>
  }

  export type StaffClassAssignmentCreateManyUserInputEnvelope = {
    data: StaffClassAssignmentCreateManyUserInput | StaffClassAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    yearGroup?: YearGroupCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
    form?: FormCreateNestedOneWithoutMessageInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageAcknowledgmentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAcknowledgmentsInput
  }

  export type MessageAcknowledgmentUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentCreateOrConnectWithoutUserInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    create: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput>
  }

  export type MessageAcknowledgmentCreateManyUserInputEnvelope = {
    data: MessageAcknowledgmentCreateManyUserInput | MessageAcknowledgmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FormResponseCreateWithoutUserInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    form: FormCreateNestedOneWithoutResponsesInput
  }

  export type FormResponseUncheckedCreateWithoutUserInput = {
    id?: string
    formId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormResponseCreateOrConnectWithoutUserInput = {
    where: FormResponseWhereUniqueInput
    create: XOR<FormResponseCreateWithoutUserInput, FormResponseUncheckedCreateWithoutUserInput>
  }

  export type FormResponseCreateManyUserInputEnvelope = {
    data: FormResponseCreateManyUserInput | FormResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventRsvpCreateWithoutUserInput = {
    id?: string
    status: string
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutRsvpsInput
  }

  export type EventRsvpUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpCreateOrConnectWithoutUserInput = {
    where: EventRsvpWhereUniqueInput
    create: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput>
  }

  export type EventRsvpCreateManyUserInputEnvelope = {
    data: EventRsvpCreateManyUserInput | EventRsvpCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PulseResponseCreateWithoutUserInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pulse: PulseSurveyCreateNestedOneWithoutResponsesInput
  }

  export type PulseResponseUncheckedCreateWithoutUserInput = {
    id?: string
    pulseId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseCreateOrConnectWithoutUserInput = {
    where: PulseResponseWhereUniqueInput
    create: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput>
  }

  export type PulseResponseCreateManyUserInputEnvelope = {
    data: PulseResponseCreateManyUserInput | PulseResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyMessageHeartCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    message: WeeklyMessageCreateNestedOneWithoutHeartsInput
  }

  export type WeeklyMessageHeartUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartCreateOrConnectWithoutUserInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    create: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput>
  }

  export type WeeklyMessageHeartCreateManyUserInputEnvelope = {
    data: WeeklyMessageHeartCreateManyUserInput | WeeklyMessageHeartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId: string
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTokenCreateWithoutUserInput = {
    id?: string
    token: string
    platform: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    platform: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenCreateOrConnectWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenCreateManyUserInputEnvelope = {
    data: DeviceTokenCreateManyUserInput | DeviceTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ParentInvitationCreateWithoutCreatedByInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvitationsInput
    childLinks?: ChildInvitationLinkCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkCreateNestedManyWithoutInvitationInput
    redeemedByUser?: UserCreateNestedOneWithoutRedeemedInvitationsInput
  }

  export type ParentInvitationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdAt?: Date | string
    childLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type ParentInvitationCreateOrConnectWithoutCreatedByInput = {
    where: ParentInvitationWhereUniqueInput
    create: XOR<ParentInvitationCreateWithoutCreatedByInput, ParentInvitationUncheckedCreateWithoutCreatedByInput>
  }

  export type ParentInvitationCreateManyCreatedByInputEnvelope = {
    data: ParentInvitationCreateManyCreatedByInput | ParentInvitationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ParentInvitationCreateWithoutRedeemedByUserInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvitationsInput
    childLinks?: ChildInvitationLinkCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkCreateNestedManyWithoutInvitationInput
    createdBy: UserCreateNestedOneWithoutCreatedInvitationsInput
  }

  export type ParentInvitationUncheckedCreateWithoutRedeemedByUserInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    childLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
    studentLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type ParentInvitationCreateOrConnectWithoutRedeemedByUserInput = {
    where: ParentInvitationWhereUniqueInput
    create: XOR<ParentInvitationCreateWithoutRedeemedByUserInput, ParentInvitationUncheckedCreateWithoutRedeemedByUserInput>
  }

  export type ParentInvitationCreateManyRedeemedByUserInputEnvelope = {
    data: ParentInvitationCreateManyRedeemedByUserInput | ParentInvitationCreateManyRedeemedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ChildUpsertWithWhereUniqueWithoutParentInput = {
    where: ChildWhereUniqueInput
    update: XOR<ChildUpdateWithoutParentInput, ChildUncheckedUpdateWithoutParentInput>
    create: XOR<ChildCreateWithoutParentInput, ChildUncheckedCreateWithoutParentInput>
  }

  export type ChildUpdateWithWhereUniqueWithoutParentInput = {
    where: ChildWhereUniqueInput
    data: XOR<ChildUpdateWithoutParentInput, ChildUncheckedUpdateWithoutParentInput>
  }

  export type ChildUpdateManyWithWhereWithoutParentInput = {
    where: ChildScalarWhereInput
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyWithoutParentInput>
  }

  export type ChildScalarWhereInput = {
    AND?: ChildScalarWhereInput | ChildScalarWhereInput[]
    OR?: ChildScalarWhereInput[]
    NOT?: ChildScalarWhereInput | ChildScalarWhereInput[]
    id?: StringFilter<"Child"> | string
    name?: StringFilter<"Child"> | string
    parentId?: StringFilter<"Child"> | string
    classId?: StringFilter<"Child"> | string
  }

  export type ParentStudentLinkUpsertWithWhereUniqueWithoutUserInput = {
    where: ParentStudentLinkWhereUniqueInput
    update: XOR<ParentStudentLinkUpdateWithoutUserInput, ParentStudentLinkUncheckedUpdateWithoutUserInput>
    create: XOR<ParentStudentLinkCreateWithoutUserInput, ParentStudentLinkUncheckedCreateWithoutUserInput>
  }

  export type ParentStudentLinkUpdateWithWhereUniqueWithoutUserInput = {
    where: ParentStudentLinkWhereUniqueInput
    data: XOR<ParentStudentLinkUpdateWithoutUserInput, ParentStudentLinkUncheckedUpdateWithoutUserInput>
  }

  export type ParentStudentLinkUpdateManyWithWhereWithoutUserInput = {
    where: ParentStudentLinkScalarWhereInput
    data: XOR<ParentStudentLinkUpdateManyMutationInput, ParentStudentLinkUncheckedUpdateManyWithoutUserInput>
  }

  export type ParentStudentLinkScalarWhereInput = {
    AND?: ParentStudentLinkScalarWhereInput | ParentStudentLinkScalarWhereInput[]
    OR?: ParentStudentLinkScalarWhereInput[]
    NOT?: ParentStudentLinkScalarWhereInput | ParentStudentLinkScalarWhereInput[]
    id?: StringFilter<"ParentStudentLink"> | string
    userId?: StringFilter<"ParentStudentLink"> | string
    studentId?: StringFilter<"ParentStudentLink"> | string
    createdAt?: DateTimeFilter<"ParentStudentLink"> | Date | string
  }

  export type StaffClassAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: StaffClassAssignmentWhereUniqueInput
    update: XOR<StaffClassAssignmentUpdateWithoutUserInput, StaffClassAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<StaffClassAssignmentCreateWithoutUserInput, StaffClassAssignmentUncheckedCreateWithoutUserInput>
  }

  export type StaffClassAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: StaffClassAssignmentWhereUniqueInput
    data: XOR<StaffClassAssignmentUpdateWithoutUserInput, StaffClassAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type StaffClassAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: StaffClassAssignmentScalarWhereInput
    data: XOR<StaffClassAssignmentUpdateManyMutationInput, StaffClassAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type StaffClassAssignmentScalarWhereInput = {
    AND?: StaffClassAssignmentScalarWhereInput | StaffClassAssignmentScalarWhereInput[]
    OR?: StaffClassAssignmentScalarWhereInput[]
    NOT?: StaffClassAssignmentScalarWhereInput | StaffClassAssignmentScalarWhereInput[]
    id?: StringFilter<"StaffClassAssignment"> | string
    userId?: StringFilter<"StaffClassAssignment"> | string
    classId?: StringFilter<"StaffClassAssignment"> | string
    createdAt?: DateTimeFilter<"StaffClassAssignment"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageAcknowledgmentUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    update: XOR<MessageAcknowledgmentUpdateWithoutUserInput, MessageAcknowledgmentUncheckedUpdateWithoutUserInput>
    create: XOR<MessageAcknowledgmentCreateWithoutUserInput, MessageAcknowledgmentUncheckedCreateWithoutUserInput>
  }

  export type MessageAcknowledgmentUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    data: XOR<MessageAcknowledgmentUpdateWithoutUserInput, MessageAcknowledgmentUncheckedUpdateWithoutUserInput>
  }

  export type MessageAcknowledgmentUpdateManyWithWhereWithoutUserInput = {
    where: MessageAcknowledgmentScalarWhereInput
    data: XOR<MessageAcknowledgmentUpdateManyMutationInput, MessageAcknowledgmentUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageAcknowledgmentScalarWhereInput = {
    AND?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
    OR?: MessageAcknowledgmentScalarWhereInput[]
    NOT?: MessageAcknowledgmentScalarWhereInput | MessageAcknowledgmentScalarWhereInput[]
    id?: StringFilter<"MessageAcknowledgment"> | string
    messageId?: StringFilter<"MessageAcknowledgment"> | string
    userId?: StringFilter<"MessageAcknowledgment"> | string
    createdAt?: DateTimeFilter<"MessageAcknowledgment"> | Date | string
  }

  export type FormResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: FormResponseWhereUniqueInput
    update: XOR<FormResponseUpdateWithoutUserInput, FormResponseUncheckedUpdateWithoutUserInput>
    create: XOR<FormResponseCreateWithoutUserInput, FormResponseUncheckedCreateWithoutUserInput>
  }

  export type FormResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: FormResponseWhereUniqueInput
    data: XOR<FormResponseUpdateWithoutUserInput, FormResponseUncheckedUpdateWithoutUserInput>
  }

  export type FormResponseUpdateManyWithWhereWithoutUserInput = {
    where: FormResponseScalarWhereInput
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type FormResponseScalarWhereInput = {
    AND?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
    OR?: FormResponseScalarWhereInput[]
    NOT?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
    id?: StringFilter<"FormResponse"> | string
    formId?: StringFilter<"FormResponse"> | string
    userId?: StringFilter<"FormResponse"> | string
    answers?: JsonFilter<"FormResponse">
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
  }

  export type EventRsvpUpsertWithWhereUniqueWithoutUserInput = {
    where: EventRsvpWhereUniqueInput
    update: XOR<EventRsvpUpdateWithoutUserInput, EventRsvpUncheckedUpdateWithoutUserInput>
    create: XOR<EventRsvpCreateWithoutUserInput, EventRsvpUncheckedCreateWithoutUserInput>
  }

  export type EventRsvpUpdateWithWhereUniqueWithoutUserInput = {
    where: EventRsvpWhereUniqueInput
    data: XOR<EventRsvpUpdateWithoutUserInput, EventRsvpUncheckedUpdateWithoutUserInput>
  }

  export type EventRsvpUpdateManyWithWhereWithoutUserInput = {
    where: EventRsvpScalarWhereInput
    data: XOR<EventRsvpUpdateManyMutationInput, EventRsvpUncheckedUpdateManyWithoutUserInput>
  }

  export type EventRsvpScalarWhereInput = {
    AND?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
    OR?: EventRsvpScalarWhereInput[]
    NOT?: EventRsvpScalarWhereInput | EventRsvpScalarWhereInput[]
    id?: StringFilter<"EventRsvp"> | string
    eventId?: StringFilter<"EventRsvp"> | string
    userId?: StringFilter<"EventRsvp"> | string
    status?: StringFilter<"EventRsvp"> | string
    createdAt?: DateTimeFilter<"EventRsvp"> | Date | string
  }

  export type PulseResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: PulseResponseWhereUniqueInput
    update: XOR<PulseResponseUpdateWithoutUserInput, PulseResponseUncheckedUpdateWithoutUserInput>
    create: XOR<PulseResponseCreateWithoutUserInput, PulseResponseUncheckedCreateWithoutUserInput>
  }

  export type PulseResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: PulseResponseWhereUniqueInput
    data: XOR<PulseResponseUpdateWithoutUserInput, PulseResponseUncheckedUpdateWithoutUserInput>
  }

  export type PulseResponseUpdateManyWithWhereWithoutUserInput = {
    where: PulseResponseScalarWhereInput
    data: XOR<PulseResponseUpdateManyMutationInput, PulseResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type PulseResponseScalarWhereInput = {
    AND?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
    OR?: PulseResponseScalarWhereInput[]
    NOT?: PulseResponseScalarWhereInput | PulseResponseScalarWhereInput[]
    id?: StringFilter<"PulseResponse"> | string
    pulseId?: StringFilter<"PulseResponse"> | string
    userId?: StringFilter<"PulseResponse"> | string
    answers?: JsonFilter<"PulseResponse">
    createdAt?: DateTimeFilter<"PulseResponse"> | Date | string
  }

  export type WeeklyMessageHeartUpsertWithWhereUniqueWithoutUserInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    update: XOR<WeeklyMessageHeartUpdateWithoutUserInput, WeeklyMessageHeartUncheckedUpdateWithoutUserInput>
    create: XOR<WeeklyMessageHeartCreateWithoutUserInput, WeeklyMessageHeartUncheckedCreateWithoutUserInput>
  }

  export type WeeklyMessageHeartUpdateWithWhereUniqueWithoutUserInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    data: XOR<WeeklyMessageHeartUpdateWithoutUserInput, WeeklyMessageHeartUncheckedUpdateWithoutUserInput>
  }

  export type WeeklyMessageHeartUpdateManyWithWhereWithoutUserInput = {
    where: WeeklyMessageHeartScalarWhereInput
    data: XOR<WeeklyMessageHeartUpdateManyMutationInput, WeeklyMessageHeartUncheckedUpdateManyWithoutUserInput>
  }

  export type WeeklyMessageHeartScalarWhereInput = {
    AND?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
    OR?: WeeklyMessageHeartScalarWhereInput[]
    NOT?: WeeklyMessageHeartScalarWhereInput | WeeklyMessageHeartScalarWhereInput[]
    id?: StringFilter<"WeeklyMessageHeart"> | string
    messageId?: StringFilter<"WeeklyMessageHeart"> | string
    userId?: StringFilter<"WeeklyMessageHeart"> | string
    createdAt?: DateTimeFilter<"WeeklyMessageHeart"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    update: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    data: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
  }

  export type DeviceTokenUpdateManyWithWhereWithoutUserInput = {
    where: DeviceTokenScalarWhereInput
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceTokenScalarWhereInput = {
    AND?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    OR?: DeviceTokenScalarWhereInput[]
    NOT?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    userId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
  }

  export type ParentInvitationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ParentInvitationWhereUniqueInput
    update: XOR<ParentInvitationUpdateWithoutCreatedByInput, ParentInvitationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ParentInvitationCreateWithoutCreatedByInput, ParentInvitationUncheckedCreateWithoutCreatedByInput>
  }

  export type ParentInvitationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ParentInvitationWhereUniqueInput
    data: XOR<ParentInvitationUpdateWithoutCreatedByInput, ParentInvitationUncheckedUpdateWithoutCreatedByInput>
  }

  export type ParentInvitationUpdateManyWithWhereWithoutCreatedByInput = {
    where: ParentInvitationScalarWhereInput
    data: XOR<ParentInvitationUpdateManyMutationInput, ParentInvitationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ParentInvitationUpsertWithWhereUniqueWithoutRedeemedByUserInput = {
    where: ParentInvitationWhereUniqueInput
    update: XOR<ParentInvitationUpdateWithoutRedeemedByUserInput, ParentInvitationUncheckedUpdateWithoutRedeemedByUserInput>
    create: XOR<ParentInvitationCreateWithoutRedeemedByUserInput, ParentInvitationUncheckedCreateWithoutRedeemedByUserInput>
  }

  export type ParentInvitationUpdateWithWhereUniqueWithoutRedeemedByUserInput = {
    where: ParentInvitationWhereUniqueInput
    data: XOR<ParentInvitationUpdateWithoutRedeemedByUserInput, ParentInvitationUncheckedUpdateWithoutRedeemedByUserInput>
  }

  export type ParentInvitationUpdateManyWithWhereWithoutRedeemedByUserInput = {
    where: ParentInvitationScalarWhereInput
    data: XOR<ParentInvitationUpdateManyMutationInput, ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserCreateWithoutChildrenInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutChildrenInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutChildrenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
  }

  export type ClassCreateWithoutChildrenInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutChildrenInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
  }

  export type UserUpsertWithoutChildrenInput = {
    update: XOR<UserUpdateWithoutChildrenInput, UserUncheckedUpdateWithoutChildrenInput>
    create: XOR<UserCreateWithoutChildrenInput, UserUncheckedCreateWithoutChildrenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChildrenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChildrenInput, UserUncheckedUpdateWithoutChildrenInput>
  }

  export type UserUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type ClassUpsertWithoutChildrenInput = {
    update: XOR<ClassUpdateWithoutChildrenInput, ClassUncheckedUpdateWithoutChildrenInput>
    create: XOR<ClassCreateWithoutChildrenInput, ClassUncheckedCreateWithoutChildrenInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutChildrenInput, ClassUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolCreateWithoutStudentsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStudentsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type ParentStudentLinkCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudentLinksInput
  }

  export type ParentStudentLinkUncheckedCreateWithoutStudentInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ParentStudentLinkCreateOrConnectWithoutStudentInput = {
    where: ParentStudentLinkWhereUniqueInput
    create: XOR<ParentStudentLinkCreateWithoutStudentInput, ParentStudentLinkUncheckedCreateWithoutStudentInput>
  }

  export type ParentStudentLinkCreateManyStudentInputEnvelope = {
    data: ParentStudentLinkCreateManyStudentInput | ParentStudentLinkCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentInvitationLinkCreateWithoutStudentInput = {
    id?: string
    invitation: ParentInvitationCreateNestedOneWithoutStudentLinksInput
  }

  export type StudentInvitationLinkUncheckedCreateWithoutStudentInput = {
    id?: string
    invitationId: string
  }

  export type StudentInvitationLinkCreateOrConnectWithoutStudentInput = {
    where: StudentInvitationLinkWhereUniqueInput
    create: XOR<StudentInvitationLinkCreateWithoutStudentInput, StudentInvitationLinkUncheckedCreateWithoutStudentInput>
  }

  export type StudentInvitationLinkCreateManyStudentInputEnvelope = {
    data: StudentInvitationLinkCreateManyStudentInput | StudentInvitationLinkCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutStudentsInput = {
    update: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassUpsertWithoutStudentsInput = {
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ParentStudentLinkUpsertWithWhereUniqueWithoutStudentInput = {
    where: ParentStudentLinkWhereUniqueInput
    update: XOR<ParentStudentLinkUpdateWithoutStudentInput, ParentStudentLinkUncheckedUpdateWithoutStudentInput>
    create: XOR<ParentStudentLinkCreateWithoutStudentInput, ParentStudentLinkUncheckedCreateWithoutStudentInput>
  }

  export type ParentStudentLinkUpdateWithWhereUniqueWithoutStudentInput = {
    where: ParentStudentLinkWhereUniqueInput
    data: XOR<ParentStudentLinkUpdateWithoutStudentInput, ParentStudentLinkUncheckedUpdateWithoutStudentInput>
  }

  export type ParentStudentLinkUpdateManyWithWhereWithoutStudentInput = {
    where: ParentStudentLinkScalarWhereInput
    data: XOR<ParentStudentLinkUpdateManyMutationInput, ParentStudentLinkUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentInvitationLinkUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentInvitationLinkWhereUniqueInput
    update: XOR<StudentInvitationLinkUpdateWithoutStudentInput, StudentInvitationLinkUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentInvitationLinkCreateWithoutStudentInput, StudentInvitationLinkUncheckedCreateWithoutStudentInput>
  }

  export type StudentInvitationLinkUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentInvitationLinkWhereUniqueInput
    data: XOR<StudentInvitationLinkUpdateWithoutStudentInput, StudentInvitationLinkUncheckedUpdateWithoutStudentInput>
  }

  export type StudentInvitationLinkUpdateManyWithWhereWithoutStudentInput = {
    where: StudentInvitationLinkScalarWhereInput
    data: XOR<StudentInvitationLinkUpdateManyMutationInput, StudentInvitationLinkUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentInvitationLinkScalarWhereInput = {
    AND?: StudentInvitationLinkScalarWhereInput | StudentInvitationLinkScalarWhereInput[]
    OR?: StudentInvitationLinkScalarWhereInput[]
    NOT?: StudentInvitationLinkScalarWhereInput | StudentInvitationLinkScalarWhereInput[]
    id?: StringFilter<"StudentInvitationLink"> | string
    invitationId?: StringFilter<"StudentInvitationLink"> | string
    studentId?: StringFilter<"StudentInvitationLink"> | string
  }

  export type UserCreateWithoutStudentLinksInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutStudentLinksInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutStudentLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentLinksInput, UserUncheckedCreateWithoutStudentLinksInput>
  }

  export type StudentCreateWithoutParentLinksInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentsInput
    class: ClassCreateNestedOneWithoutStudentsInput
    invitationLinks?: StudentInvitationLinkCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentLinksInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    schoolId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invitationLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentLinksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentLinksInput, StudentUncheckedCreateWithoutParentLinksInput>
  }

  export type UserUpsertWithoutStudentLinksInput = {
    update: XOR<UserUpdateWithoutStudentLinksInput, UserUncheckedUpdateWithoutStudentLinksInput>
    create: XOR<UserCreateWithoutStudentLinksInput, UserUncheckedCreateWithoutStudentLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentLinksInput, UserUncheckedUpdateWithoutStudentLinksInput>
  }

  export type UserUpdateWithoutStudentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type StudentUpsertWithoutParentLinksInput = {
    update: XOR<StudentUpdateWithoutParentLinksInput, StudentUncheckedUpdateWithoutParentLinksInput>
    create: XOR<StudentCreateWithoutParentLinksInput, StudentUncheckedCreateWithoutParentLinksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentLinksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentLinksInput, StudentUncheckedUpdateWithoutParentLinksInput>
  }

  export type StudentUpdateWithoutParentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    invitationLinks?: StudentInvitationLinkUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitationLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentInvitationCreateWithoutStudentLinksInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvitationsInput
    childLinks?: ChildInvitationLinkCreateNestedManyWithoutInvitationInput
    redeemedByUser?: UserCreateNestedOneWithoutRedeemedInvitationsInput
    createdBy: UserCreateNestedOneWithoutCreatedInvitationsInput
  }

  export type ParentInvitationUncheckedCreateWithoutStudentLinksInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdById: string
    createdAt?: Date | string
    childLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type ParentInvitationCreateOrConnectWithoutStudentLinksInput = {
    where: ParentInvitationWhereUniqueInput
    create: XOR<ParentInvitationCreateWithoutStudentLinksInput, ParentInvitationUncheckedCreateWithoutStudentLinksInput>
  }

  export type StudentCreateWithoutInvitationLinksInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentsInput
    class: ClassCreateNestedOneWithoutStudentsInput
    parentLinks?: ParentStudentLinkCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInvitationLinksInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    schoolId: string
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInvitationLinksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInvitationLinksInput, StudentUncheckedCreateWithoutInvitationLinksInput>
  }

  export type ParentInvitationUpsertWithoutStudentLinksInput = {
    update: XOR<ParentInvitationUpdateWithoutStudentLinksInput, ParentInvitationUncheckedUpdateWithoutStudentLinksInput>
    create: XOR<ParentInvitationCreateWithoutStudentLinksInput, ParentInvitationUncheckedCreateWithoutStudentLinksInput>
    where?: ParentInvitationWhereInput
  }

  export type ParentInvitationUpdateToOneWithWhereWithoutStudentLinksInput = {
    where?: ParentInvitationWhereInput
    data: XOR<ParentInvitationUpdateWithoutStudentLinksInput, ParentInvitationUncheckedUpdateWithoutStudentLinksInput>
  }

  export type ParentInvitationUpdateWithoutStudentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvitationsNestedInput
    childLinks?: ChildInvitationLinkUpdateManyWithoutInvitationNestedInput
    redeemedByUser?: UserUpdateOneWithoutRedeemedInvitationsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvitationsNestedInput
  }

  export type ParentInvitationUncheckedUpdateWithoutStudentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type StudentUpsertWithoutInvitationLinksInput = {
    update: XOR<StudentUpdateWithoutInvitationLinksInput, StudentUncheckedUpdateWithoutInvitationLinksInput>
    create: XOR<StudentCreateWithoutInvitationLinksInput, StudentUncheckedCreateWithoutInvitationLinksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutInvitationLinksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutInvitationLinksInput, StudentUncheckedUpdateWithoutInvitationLinksInput>
  }

  export type StudentUpdateWithoutInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    parentLinks?: ParentStudentLinkUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SchoolCreateWithoutYearGroupsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutYearGroupsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutYearGroupsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutYearGroupsInput, SchoolUncheckedCreateWithoutYearGroupsInput>
  }

  export type ClassCreateWithoutYearGroupInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutYearGroupInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutYearGroupInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutYearGroupInput, ClassUncheckedCreateWithoutYearGroupInput>
  }

  export type ClassCreateManyYearGroupInputEnvelope = {
    data: ClassCreateManyYearGroupInput | ClassCreateManyYearGroupInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutYearGroupInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    form?: FormCreateNestedOneWithoutMessageInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutYearGroupInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutYearGroupInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutYearGroupInput, MessageUncheckedCreateWithoutYearGroupInput>
  }

  export type MessageCreateManyYearGroupInputEnvelope = {
    data: MessageCreateManyYearGroupInput | MessageCreateManyYearGroupInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutYearGroupInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutEventsInput
    school: SchoolCreateNestedOneWithoutEventsInput
    rsvps?: EventRsvpCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutYearGroupInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: EventRsvpUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutYearGroupInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutYearGroupInput, EventUncheckedCreateWithoutYearGroupInput>
  }

  export type EventCreateManyYearGroupInputEnvelope = {
    data: EventCreateManyYearGroupInput | EventCreateManyYearGroupInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleItemCreateWithoutYearGroupInput = {
    id?: string
    targetClass: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    class?: ClassCreateNestedOneWithoutScheduleItemsInput
    school: SchoolCreateNestedOneWithoutScheduleItemsInput
  }

  export type ScheduleItemUncheckedCreateWithoutYearGroupInput = {
    id?: string
    targetClass: string
    classId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemCreateOrConnectWithoutYearGroupInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutYearGroupInput, ScheduleItemUncheckedCreateWithoutYearGroupInput>
  }

  export type ScheduleItemCreateManyYearGroupInputEnvelope = {
    data: ScheduleItemCreateManyYearGroupInput | ScheduleItemCreateManyYearGroupInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutYearGroupsInput = {
    update: XOR<SchoolUpdateWithoutYearGroupsInput, SchoolUncheckedUpdateWithoutYearGroupsInput>
    create: XOR<SchoolCreateWithoutYearGroupsInput, SchoolUncheckedCreateWithoutYearGroupsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutYearGroupsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutYearGroupsInput, SchoolUncheckedUpdateWithoutYearGroupsInput>
  }

  export type SchoolUpdateWithoutYearGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutYearGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassUpsertWithWhereUniqueWithoutYearGroupInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutYearGroupInput, ClassUncheckedUpdateWithoutYearGroupInput>
    create: XOR<ClassCreateWithoutYearGroupInput, ClassUncheckedCreateWithoutYearGroupInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutYearGroupInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutYearGroupInput, ClassUncheckedUpdateWithoutYearGroupInput>
  }

  export type ClassUpdateManyWithWhereWithoutYearGroupInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutYearGroupInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutYearGroupInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutYearGroupInput, MessageUncheckedUpdateWithoutYearGroupInput>
    create: XOR<MessageCreateWithoutYearGroupInput, MessageUncheckedCreateWithoutYearGroupInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutYearGroupInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutYearGroupInput, MessageUncheckedUpdateWithoutYearGroupInput>
  }

  export type MessageUpdateManyWithWhereWithoutYearGroupInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutYearGroupInput>
  }

  export type EventUpsertWithWhereUniqueWithoutYearGroupInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutYearGroupInput, EventUncheckedUpdateWithoutYearGroupInput>
    create: XOR<EventCreateWithoutYearGroupInput, EventUncheckedCreateWithoutYearGroupInput>
  }

  export type EventUpdateWithWhereUniqueWithoutYearGroupInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutYearGroupInput, EventUncheckedUpdateWithoutYearGroupInput>
  }

  export type EventUpdateManyWithWhereWithoutYearGroupInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutYearGroupInput>
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutYearGroupInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutYearGroupInput, ScheduleItemUncheckedUpdateWithoutYearGroupInput>
    create: XOR<ScheduleItemCreateWithoutYearGroupInput, ScheduleItemUncheckedCreateWithoutYearGroupInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutYearGroupInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutYearGroupInput, ScheduleItemUncheckedUpdateWithoutYearGroupInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutYearGroupInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutYearGroupInput>
  }

  export type SchoolCreateWithoutClassesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
  }

  export type YearGroupCreateWithoutClassesInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutYearGroupsInput
    messages?: MessageCreateNestedManyWithoutYearGroupInput
    events?: EventCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    order: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutYearGroupInput
    events?: EventUncheckedCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupCreateOrConnectWithoutClassesInput = {
    where: YearGroupWhereUniqueInput
    create: XOR<YearGroupCreateWithoutClassesInput, YearGroupUncheckedCreateWithoutClassesInput>
  }

  export type ChildCreateWithoutClassInput = {
    id?: string
    name: string
    parent: UserCreateNestedOneWithoutChildrenInput
  }

  export type ChildUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    parentId: string
  }

  export type ChildCreateOrConnectWithoutClassInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput>
  }

  export type ChildCreateManyClassInputEnvelope = {
    data: ChildCreateManyClassInput | ChildCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutClassInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentsInput
    parentLinks?: ParentStudentLinkCreateNestedManyWithoutStudentInput
    invitationLinks?: StudentInvitationLinkCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutStudentInput
    invitationLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutClassInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    yearGroup?: YearGroupCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    form?: FormCreateNestedOneWithoutMessageInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutClassInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    yearGroupId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutClassInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput>
  }

  export type MessageCreateManyClassInputEnvelope = {
    data: MessageCreateManyClassInput | MessageCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutClassInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yearGroup?: YearGroupCreateNestedOneWithoutEventsInput
    school: SchoolCreateNestedOneWithoutEventsInput
    rsvps?: EventRsvpCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutClassInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    yearGroupId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rsvps?: EventRsvpUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutClassInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput>
  }

  export type EventCreateManyClassInputEnvelope = {
    data: EventCreateManyClassInput | EventCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleItemCreateWithoutClassInput = {
    id?: string
    targetClass: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    yearGroup?: YearGroupCreateNestedOneWithoutScheduleItemsInput
    school: SchoolCreateNestedOneWithoutScheduleItemsInput
  }

  export type ScheduleItemUncheckedCreateWithoutClassInput = {
    id?: string
    targetClass: string
    yearGroupId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ScheduleItemCreateOrConnectWithoutClassInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput>
  }

  export type ScheduleItemCreateManyClassInputEnvelope = {
    data: ScheduleItemCreateManyClassInput | ScheduleItemCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StaffClassAssignmentCreateWithoutClassInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAssignedClassesInput
  }

  export type StaffClassAssignmentUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type StaffClassAssignmentCreateOrConnectWithoutClassInput = {
    where: StaffClassAssignmentWhereUniqueInput
    create: XOR<StaffClassAssignmentCreateWithoutClassInput, StaffClassAssignmentUncheckedCreateWithoutClassInput>
  }

  export type StaffClassAssignmentCreateManyClassInputEnvelope = {
    data: StaffClassAssignmentCreateManyClassInput | StaffClassAssignmentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ChildInvitationLinkCreateWithoutClassInput = {
    id?: string
    childName: string
    invitation: ParentInvitationCreateNestedOneWithoutChildLinksInput
  }

  export type ChildInvitationLinkUncheckedCreateWithoutClassInput = {
    id?: string
    invitationId: string
    childName: string
  }

  export type ChildInvitationLinkCreateOrConnectWithoutClassInput = {
    where: ChildInvitationLinkWhereUniqueInput
    create: XOR<ChildInvitationLinkCreateWithoutClassInput, ChildInvitationLinkUncheckedCreateWithoutClassInput>
  }

  export type ChildInvitationLinkCreateManyClassInputEnvelope = {
    data: ChildInvitationLinkCreateManyClassInput | ChildInvitationLinkCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutClassesInput = {
    update: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type YearGroupUpsertWithoutClassesInput = {
    update: XOR<YearGroupUpdateWithoutClassesInput, YearGroupUncheckedUpdateWithoutClassesInput>
    create: XOR<YearGroupCreateWithoutClassesInput, YearGroupUncheckedCreateWithoutClassesInput>
    where?: YearGroupWhereInput
  }

  export type YearGroupUpdateToOneWithWhereWithoutClassesInput = {
    where?: YearGroupWhereInput
    data: XOR<YearGroupUpdateWithoutClassesInput, YearGroupUncheckedUpdateWithoutClassesInput>
  }

  export type YearGroupUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutYearGroupsNestedInput
    messages?: MessageUpdateManyWithoutYearGroupNestedInput
    events?: EventUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutYearGroupNestedInput
    events?: EventUncheckedUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutYearGroupNestedInput
  }

  export type ChildUpsertWithWhereUniqueWithoutClassInput = {
    where: ChildWhereUniqueInput
    update: XOR<ChildUpdateWithoutClassInput, ChildUncheckedUpdateWithoutClassInput>
    create: XOR<ChildCreateWithoutClassInput, ChildUncheckedCreateWithoutClassInput>
  }

  export type ChildUpdateWithWhereUniqueWithoutClassInput = {
    where: ChildWhereUniqueInput
    data: XOR<ChildUpdateWithoutClassInput, ChildUncheckedUpdateWithoutClassInput>
  }

  export type ChildUpdateManyWithWhereWithoutClassInput = {
    where: ChildScalarWhereInput
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyWithoutClassInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutClassInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutClassInput, MessageUncheckedUpdateWithoutClassInput>
    create: XOR<MessageCreateWithoutClassInput, MessageUncheckedCreateWithoutClassInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutClassInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutClassInput, MessageUncheckedUpdateWithoutClassInput>
  }

  export type MessageUpdateManyWithWhereWithoutClassInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutClassInput>
  }

  export type EventUpsertWithWhereUniqueWithoutClassInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutClassInput, EventUncheckedUpdateWithoutClassInput>
    create: XOR<EventCreateWithoutClassInput, EventUncheckedCreateWithoutClassInput>
  }

  export type EventUpdateWithWhereUniqueWithoutClassInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutClassInput, EventUncheckedUpdateWithoutClassInput>
  }

  export type EventUpdateManyWithWhereWithoutClassInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutClassInput>
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutClassInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutClassInput, ScheduleItemUncheckedUpdateWithoutClassInput>
    create: XOR<ScheduleItemCreateWithoutClassInput, ScheduleItemUncheckedCreateWithoutClassInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutClassInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutClassInput, ScheduleItemUncheckedUpdateWithoutClassInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutClassInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutClassInput>
  }

  export type StaffClassAssignmentUpsertWithWhereUniqueWithoutClassInput = {
    where: StaffClassAssignmentWhereUniqueInput
    update: XOR<StaffClassAssignmentUpdateWithoutClassInput, StaffClassAssignmentUncheckedUpdateWithoutClassInput>
    create: XOR<StaffClassAssignmentCreateWithoutClassInput, StaffClassAssignmentUncheckedCreateWithoutClassInput>
  }

  export type StaffClassAssignmentUpdateWithWhereUniqueWithoutClassInput = {
    where: StaffClassAssignmentWhereUniqueInput
    data: XOR<StaffClassAssignmentUpdateWithoutClassInput, StaffClassAssignmentUncheckedUpdateWithoutClassInput>
  }

  export type StaffClassAssignmentUpdateManyWithWhereWithoutClassInput = {
    where: StaffClassAssignmentScalarWhereInput
    data: XOR<StaffClassAssignmentUpdateManyMutationInput, StaffClassAssignmentUncheckedUpdateManyWithoutClassInput>
  }

  export type ChildInvitationLinkUpsertWithWhereUniqueWithoutClassInput = {
    where: ChildInvitationLinkWhereUniqueInput
    update: XOR<ChildInvitationLinkUpdateWithoutClassInput, ChildInvitationLinkUncheckedUpdateWithoutClassInput>
    create: XOR<ChildInvitationLinkCreateWithoutClassInput, ChildInvitationLinkUncheckedCreateWithoutClassInput>
  }

  export type ChildInvitationLinkUpdateWithWhereUniqueWithoutClassInput = {
    where: ChildInvitationLinkWhereUniqueInput
    data: XOR<ChildInvitationLinkUpdateWithoutClassInput, ChildInvitationLinkUncheckedUpdateWithoutClassInput>
  }

  export type ChildInvitationLinkUpdateManyWithWhereWithoutClassInput = {
    where: ChildInvitationLinkScalarWhereInput
    data: XOR<ChildInvitationLinkUpdateManyMutationInput, ChildInvitationLinkUncheckedUpdateManyWithoutClassInput>
  }

  export type ChildInvitationLinkScalarWhereInput = {
    AND?: ChildInvitationLinkScalarWhereInput | ChildInvitationLinkScalarWhereInput[]
    OR?: ChildInvitationLinkScalarWhereInput[]
    NOT?: ChildInvitationLinkScalarWhereInput | ChildInvitationLinkScalarWhereInput[]
    id?: StringFilter<"ChildInvitationLink"> | string
    invitationId?: StringFilter<"ChildInvitationLink"> | string
    childName?: StringFilter<"ChildInvitationLink"> | string
    classId?: StringFilter<"ChildInvitationLink"> | string
  }

  export type UserCreateWithoutAssignedClassesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutAssignedClassesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutAssignedClassesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedClassesInput, UserUncheckedCreateWithoutAssignedClassesInput>
  }

  export type ClassCreateWithoutAssignedStaffInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAssignedStaffInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAssignedStaffInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAssignedStaffInput, ClassUncheckedCreateWithoutAssignedStaffInput>
  }

  export type UserUpsertWithoutAssignedClassesInput = {
    update: XOR<UserUpdateWithoutAssignedClassesInput, UserUncheckedUpdateWithoutAssignedClassesInput>
    create: XOR<UserCreateWithoutAssignedClassesInput, UserUncheckedCreateWithoutAssignedClassesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedClassesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedClassesInput, UserUncheckedUpdateWithoutAssignedClassesInput>
  }

  export type UserUpdateWithoutAssignedClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type ClassUpsertWithoutAssignedStaffInput = {
    update: XOR<ClassUpdateWithoutAssignedStaffInput, ClassUncheckedUpdateWithoutAssignedStaffInput>
    create: XOR<ClassCreateWithoutAssignedStaffInput, ClassUncheckedCreateWithoutAssignedStaffInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAssignedStaffInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAssignedStaffInput, ClassUncheckedUpdateWithoutAssignedStaffInput>
  }

  export type ClassUpdateWithoutAssignedStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAssignedStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateWithoutMessagesInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutMessagesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
  }

  export type YearGroupCreateWithoutMessagesInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutYearGroupsInput
    classes?: ClassCreateNestedManyWithoutYearGroupInput
    events?: EventCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    order: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutYearGroupInput
    events?: EventUncheckedCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupCreateOrConnectWithoutMessagesInput = {
    where: YearGroupWhereUniqueInput
    create: XOR<YearGroupCreateWithoutMessagesInput, YearGroupUncheckedCreateWithoutMessagesInput>
  }

  export type SchoolCreateWithoutMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutMessagesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type FormCreateWithoutMessageInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFormsInput
    responses?: FormResponseCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutMessageInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: FormResponseUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutMessageInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutMessageInput, FormUncheckedCreateWithoutMessageInput>
  }

  export type MessageAcknowledgmentCreateWithoutMessageInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessageAcksInput
  }

  export type MessageAcknowledgmentUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentCreateOrConnectWithoutMessageInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    create: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAcknowledgmentCreateManyMessageInputEnvelope = {
    data: MessageAcknowledgmentCreateManyMessageInput | MessageAcknowledgmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutMessagesInput = {
    update: XOR<ClassUpdateWithoutMessagesInput, ClassUncheckedUpdateWithoutMessagesInput>
    create: XOR<ClassCreateWithoutMessagesInput, ClassUncheckedCreateWithoutMessagesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutMessagesInput, ClassUncheckedUpdateWithoutMessagesInput>
  }

  export type ClassUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type YearGroupUpsertWithoutMessagesInput = {
    update: XOR<YearGroupUpdateWithoutMessagesInput, YearGroupUncheckedUpdateWithoutMessagesInput>
    create: XOR<YearGroupCreateWithoutMessagesInput, YearGroupUncheckedCreateWithoutMessagesInput>
    where?: YearGroupWhereInput
  }

  export type YearGroupUpdateToOneWithWhereWithoutMessagesInput = {
    where?: YearGroupWhereInput
    data: XOR<YearGroupUpdateWithoutMessagesInput, YearGroupUncheckedUpdateWithoutMessagesInput>
  }

  export type YearGroupUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutYearGroupsNestedInput
    classes?: ClassUpdateManyWithoutYearGroupNestedInput
    events?: EventUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutYearGroupNestedInput
    events?: EventUncheckedUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutYearGroupNestedInput
  }

  export type SchoolUpsertWithoutMessagesInput = {
    update: XOR<SchoolUpdateWithoutMessagesInput, SchoolUncheckedUpdateWithoutMessagesInput>
    create: XOR<SchoolCreateWithoutMessagesInput, SchoolUncheckedCreateWithoutMessagesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutMessagesInput, SchoolUncheckedUpdateWithoutMessagesInput>
  }

  export type SchoolUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type FormUpsertWithoutMessageInput = {
    update: XOR<FormUpdateWithoutMessageInput, FormUncheckedUpdateWithoutMessageInput>
    create: XOR<FormCreateWithoutMessageInput, FormUncheckedCreateWithoutMessageInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutMessageInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutMessageInput, FormUncheckedUpdateWithoutMessageInput>
  }

  export type FormUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFormsNestedInput
    responses?: FormResponseUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: FormResponseUncheckedUpdateManyWithoutFormNestedInput
  }

  export type MessageAcknowledgmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    update: XOR<MessageAcknowledgmentUpdateWithoutMessageInput, MessageAcknowledgmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAcknowledgmentCreateWithoutMessageInput, MessageAcknowledgmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAcknowledgmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAcknowledgmentWhereUniqueInput
    data: XOR<MessageAcknowledgmentUpdateWithoutMessageInput, MessageAcknowledgmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAcknowledgmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAcknowledgmentScalarWhereInput
    data: XOR<MessageAcknowledgmentUpdateManyMutationInput, MessageAcknowledgmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutAcknowledgmentsInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    yearGroup?: YearGroupCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    form?: FormCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutAcknowledgmentsInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutAcknowledgmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
  }

  export type UserCreateWithoutMessageAcksInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutMessageAcksInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutMessageAcksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
  }

  export type MessageUpsertWithoutAcknowledgmentsInput = {
    update: XOR<MessageUpdateWithoutAcknowledgmentsInput, MessageUncheckedUpdateWithoutAcknowledgmentsInput>
    create: XOR<MessageCreateWithoutAcknowledgmentsInput, MessageUncheckedCreateWithoutAcknowledgmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAcknowledgmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAcknowledgmentsInput, MessageUncheckedUpdateWithoutAcknowledgmentsInput>
  }

  export type MessageUpdateWithoutAcknowledgmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    form?: FormUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutAcknowledgmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessageAcksInput = {
    update: XOR<UserUpdateWithoutMessageAcksInput, UserUncheckedUpdateWithoutMessageAcksInput>
    create: XOR<UserCreateWithoutMessageAcksInput, UserUncheckedCreateWithoutMessageAcksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageAcksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageAcksInput, UserUncheckedUpdateWithoutMessageAcksInput>
  }

  export type UserUpdateWithoutMessageAcksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageAcksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type ClassCreateWithoutEventsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutEventsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
  }

  export type YearGroupCreateWithoutEventsInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutYearGroupsInput
    classes?: ClassCreateNestedManyWithoutYearGroupInput
    messages?: MessageCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    order: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutYearGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutYearGroupInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupCreateOrConnectWithoutEventsInput = {
    where: YearGroupWhereUniqueInput
    create: XOR<YearGroupCreateWithoutEventsInput, YearGroupUncheckedCreateWithoutEventsInput>
  }

  export type SchoolCreateWithoutEventsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutEventsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
  }

  export type EventRsvpCreateWithoutEventInput = {
    id?: string
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEventRsvpsInput
  }

  export type EventRsvpUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpCreateOrConnectWithoutEventInput = {
    where: EventRsvpWhereUniqueInput
    create: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput>
  }

  export type EventRsvpCreateManyEventInputEnvelope = {
    data: EventRsvpCreateManyEventInput | EventRsvpCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutEventsInput = {
    update: XOR<ClassUpdateWithoutEventsInput, ClassUncheckedUpdateWithoutEventsInput>
    create: XOR<ClassCreateWithoutEventsInput, ClassUncheckedCreateWithoutEventsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutEventsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutEventsInput, ClassUncheckedUpdateWithoutEventsInput>
  }

  export type ClassUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type YearGroupUpsertWithoutEventsInput = {
    update: XOR<YearGroupUpdateWithoutEventsInput, YearGroupUncheckedUpdateWithoutEventsInput>
    create: XOR<YearGroupCreateWithoutEventsInput, YearGroupUncheckedCreateWithoutEventsInput>
    where?: YearGroupWhereInput
  }

  export type YearGroupUpdateToOneWithWhereWithoutEventsInput = {
    where?: YearGroupWhereInput
    data: XOR<YearGroupUpdateWithoutEventsInput, YearGroupUncheckedUpdateWithoutEventsInput>
  }

  export type YearGroupUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutYearGroupsNestedInput
    classes?: ClassUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutYearGroupNestedInput
  }

  export type SchoolUpsertWithoutEventsInput = {
    update: XOR<SchoolUpdateWithoutEventsInput, SchoolUncheckedUpdateWithoutEventsInput>
    create: XOR<SchoolCreateWithoutEventsInput, SchoolUncheckedCreateWithoutEventsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutEventsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutEventsInput, SchoolUncheckedUpdateWithoutEventsInput>
  }

  export type SchoolUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type EventRsvpUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRsvpWhereUniqueInput
    update: XOR<EventRsvpUpdateWithoutEventInput, EventRsvpUncheckedUpdateWithoutEventInput>
    create: XOR<EventRsvpCreateWithoutEventInput, EventRsvpUncheckedCreateWithoutEventInput>
  }

  export type EventRsvpUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRsvpWhereUniqueInput
    data: XOR<EventRsvpUpdateWithoutEventInput, EventRsvpUncheckedUpdateWithoutEventInput>
  }

  export type EventRsvpUpdateManyWithWhereWithoutEventInput = {
    where: EventRsvpScalarWhereInput
    data: XOR<EventRsvpUpdateManyMutationInput, EventRsvpUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutRsvpsInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutEventsInput
    yearGroup?: YearGroupCreateNestedOneWithoutEventsInput
    school: SchoolCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutRsvpsInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutRsvpsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
  }

  export type UserCreateWithoutEventRsvpsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutEventRsvpsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutEventRsvpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
  }

  export type EventUpsertWithoutRsvpsInput = {
    update: XOR<EventUpdateWithoutRsvpsInput, EventUncheckedUpdateWithoutRsvpsInput>
    create: XOR<EventCreateWithoutRsvpsInput, EventUncheckedCreateWithoutRsvpsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutRsvpsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutRsvpsInput, EventUncheckedUpdateWithoutRsvpsInput>
  }

  export type EventUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutEventsNestedInput
    yearGroup?: YearGroupUpdateOneWithoutEventsNestedInput
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEventRsvpsInput = {
    update: XOR<UserUpdateWithoutEventRsvpsInput, UserUncheckedUpdateWithoutEventRsvpsInput>
    create: XOR<UserCreateWithoutEventRsvpsInput, UserUncheckedCreateWithoutEventRsvpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventRsvpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventRsvpsInput, UserUncheckedUpdateWithoutEventRsvpsInput>
  }

  export type UserUpdateWithoutEventRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventRsvpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type SchoolCreateWithoutTermDatesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTermDatesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTermDatesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
  }

  export type SchoolUpsertWithoutTermDatesInput = {
    update: XOR<SchoolUpdateWithoutTermDatesInput, SchoolUncheckedUpdateWithoutTermDatesInput>
    create: XOR<SchoolCreateWithoutTermDatesInput, SchoolUncheckedCreateWithoutTermDatesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTermDatesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTermDatesInput, SchoolUncheckedUpdateWithoutTermDatesInput>
  }

  export type SchoolUpdateWithoutTermDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTermDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
    childInvitationLinks?: ChildInvitationLinkUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutScheduleItemsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
  }

  export type YearGroupCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutYearGroupsInput
    classes?: ClassCreateNestedManyWithoutYearGroupInput
    messages?: MessageCreateNestedManyWithoutYearGroupInput
    events?: EventCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupUncheckedCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    order: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutYearGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutYearGroupInput
    events?: EventUncheckedCreateNestedManyWithoutYearGroupInput
  }

  export type YearGroupCreateOrConnectWithoutScheduleItemsInput = {
    where: YearGroupWhereUniqueInput
    create: XOR<YearGroupCreateWithoutScheduleItemsInput, YearGroupUncheckedCreateWithoutScheduleItemsInput>
  }

  export type SchoolCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutScheduleItemsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutScheduleItemsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
  }

  export type ClassUpsertWithoutScheduleItemsInput = {
    update: XOR<ClassUpdateWithoutScheduleItemsInput, ClassUncheckedUpdateWithoutScheduleItemsInput>
    create: XOR<ClassCreateWithoutScheduleItemsInput, ClassUncheckedCreateWithoutScheduleItemsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutScheduleItemsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutScheduleItemsInput, ClassUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type ClassUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type YearGroupUpsertWithoutScheduleItemsInput = {
    update: XOR<YearGroupUpdateWithoutScheduleItemsInput, YearGroupUncheckedUpdateWithoutScheduleItemsInput>
    create: XOR<YearGroupCreateWithoutScheduleItemsInput, YearGroupUncheckedCreateWithoutScheduleItemsInput>
    where?: YearGroupWhereInput
  }

  export type YearGroupUpdateToOneWithWhereWithoutScheduleItemsInput = {
    where?: YearGroupWhereInput
    data: XOR<YearGroupUpdateWithoutScheduleItemsInput, YearGroupUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type YearGroupUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutYearGroupsNestedInput
    classes?: ClassUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUpdateManyWithoutYearGroupNestedInput
    events?: EventUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupUncheckedUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutYearGroupNestedInput
    events?: EventUncheckedUpdateManyWithoutYearGroupNestedInput
  }

  export type SchoolUpsertWithoutScheduleItemsInput = {
    update: XOR<SchoolUpdateWithoutScheduleItemsInput, SchoolUncheckedUpdateWithoutScheduleItemsInput>
    create: XOR<SchoolCreateWithoutScheduleItemsInput, SchoolUncheckedCreateWithoutScheduleItemsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutScheduleItemsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutScheduleItemsInput, SchoolUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type SchoolUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutWeeklyMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutWeeklyMessagesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutWeeklyMessagesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
  }

  export type WeeklyMessageHeartCreateWithoutMessageInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWeeklyHeartsInput
  }

  export type WeeklyMessageHeartUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartCreateOrConnectWithoutMessageInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    create: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput>
  }

  export type WeeklyMessageHeartCreateManyMessageInputEnvelope = {
    data: WeeklyMessageHeartCreateManyMessageInput | WeeklyMessageHeartCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutWeeklyMessagesInput = {
    update: XOR<SchoolUpdateWithoutWeeklyMessagesInput, SchoolUncheckedUpdateWithoutWeeklyMessagesInput>
    create: XOR<SchoolCreateWithoutWeeklyMessagesInput, SchoolUncheckedCreateWithoutWeeklyMessagesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutWeeklyMessagesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutWeeklyMessagesInput, SchoolUncheckedUpdateWithoutWeeklyMessagesInput>
  }

  export type SchoolUpdateWithoutWeeklyMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutWeeklyMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type WeeklyMessageHeartUpsertWithWhereUniqueWithoutMessageInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    update: XOR<WeeklyMessageHeartUpdateWithoutMessageInput, WeeklyMessageHeartUncheckedUpdateWithoutMessageInput>
    create: XOR<WeeklyMessageHeartCreateWithoutMessageInput, WeeklyMessageHeartUncheckedCreateWithoutMessageInput>
  }

  export type WeeklyMessageHeartUpdateWithWhereUniqueWithoutMessageInput = {
    where: WeeklyMessageHeartWhereUniqueInput
    data: XOR<WeeklyMessageHeartUpdateWithoutMessageInput, WeeklyMessageHeartUncheckedUpdateWithoutMessageInput>
  }

  export type WeeklyMessageHeartUpdateManyWithWhereWithoutMessageInput = {
    where: WeeklyMessageHeartScalarWhereInput
    data: XOR<WeeklyMessageHeartUpdateManyMutationInput, WeeklyMessageHeartUncheckedUpdateManyWithoutMessageInput>
  }

  export type WeeklyMessageCreateWithoutHeartsInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutWeeklyMessagesInput
  }

  export type WeeklyMessageUncheckedCreateWithoutHeartsInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageCreateOrConnectWithoutHeartsInput = {
    where: WeeklyMessageWhereUniqueInput
    create: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
  }

  export type UserCreateWithoutWeeklyHeartsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutWeeklyHeartsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutWeeklyHeartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
  }

  export type WeeklyMessageUpsertWithoutHeartsInput = {
    update: XOR<WeeklyMessageUpdateWithoutHeartsInput, WeeklyMessageUncheckedUpdateWithoutHeartsInput>
    create: XOR<WeeklyMessageCreateWithoutHeartsInput, WeeklyMessageUncheckedCreateWithoutHeartsInput>
    where?: WeeklyMessageWhereInput
  }

  export type WeeklyMessageUpdateToOneWithWhereWithoutHeartsInput = {
    where?: WeeklyMessageWhereInput
    data: XOR<WeeklyMessageUpdateWithoutHeartsInput, WeeklyMessageUncheckedUpdateWithoutHeartsInput>
  }

  export type WeeklyMessageUpdateWithoutHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutWeeklyMessagesNestedInput
  }

  export type WeeklyMessageUncheckedUpdateWithoutHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutWeeklyHeartsInput = {
    update: XOR<UserUpdateWithoutWeeklyHeartsInput, UserUncheckedUpdateWithoutWeeklyHeartsInput>
    create: XOR<UserCreateWithoutWeeklyHeartsInput, UserUncheckedCreateWithoutWeeklyHeartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWeeklyHeartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWeeklyHeartsInput, UserUncheckedUpdateWithoutWeeklyHeartsInput>
  }

  export type UserUpdateWithoutWeeklyHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWeeklyHeartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type SchoolCreateWithoutKnowledgeCategoriesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutKnowledgeCategoriesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutKnowledgeCategoriesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
  }

  export type KnowledgeArticleCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleCreateOrConnectWithoutCategoryInput = {
    where: KnowledgeArticleWhereUniqueInput
    create: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput>
  }

  export type KnowledgeArticleCreateManyCategoryInputEnvelope = {
    data: KnowledgeArticleCreateManyCategoryInput | KnowledgeArticleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutKnowledgeCategoriesInput = {
    update: XOR<SchoolUpdateWithoutKnowledgeCategoriesInput, SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput>
    create: XOR<SchoolCreateWithoutKnowledgeCategoriesInput, SchoolUncheckedCreateWithoutKnowledgeCategoriesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutKnowledgeCategoriesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutKnowledgeCategoriesInput, SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput>
  }

  export type SchoolUpdateWithoutKnowledgeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutKnowledgeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type KnowledgeArticleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: KnowledgeArticleWhereUniqueInput
    update: XOR<KnowledgeArticleUpdateWithoutCategoryInput, KnowledgeArticleUncheckedUpdateWithoutCategoryInput>
    create: XOR<KnowledgeArticleCreateWithoutCategoryInput, KnowledgeArticleUncheckedCreateWithoutCategoryInput>
  }

  export type KnowledgeArticleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: KnowledgeArticleWhereUniqueInput
    data: XOR<KnowledgeArticleUpdateWithoutCategoryInput, KnowledgeArticleUncheckedUpdateWithoutCategoryInput>
  }

  export type KnowledgeArticleUpdateManyWithWhereWithoutCategoryInput = {
    where: KnowledgeArticleScalarWhereInput
    data: XOR<KnowledgeArticleUpdateManyMutationInput, KnowledgeArticleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type KnowledgeArticleScalarWhereInput = {
    AND?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
    OR?: KnowledgeArticleScalarWhereInput[]
    NOT?: KnowledgeArticleScalarWhereInput | KnowledgeArticleScalarWhereInput[]
    id?: StringFilter<"KnowledgeArticle"> | string
    title?: StringFilter<"KnowledgeArticle"> | string
    content?: StringFilter<"KnowledgeArticle"> | string
    categoryId?: StringFilter<"KnowledgeArticle"> | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
  }

  export type KnowledgeCategoryCreateWithoutArticlesInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    school: SchoolCreateNestedOneWithoutKnowledgeCategoriesInput
  }

  export type KnowledgeCategoryUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
    schoolId: string
  }

  export type KnowledgeCategoryCreateOrConnectWithoutArticlesInput = {
    where: KnowledgeCategoryWhereUniqueInput
    create: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
  }

  export type KnowledgeCategoryUpsertWithoutArticlesInput = {
    update: XOR<KnowledgeCategoryUpdateWithoutArticlesInput, KnowledgeCategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<KnowledgeCategoryCreateWithoutArticlesInput, KnowledgeCategoryUncheckedCreateWithoutArticlesInput>
    where?: KnowledgeCategoryWhereInput
  }

  export type KnowledgeCategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: KnowledgeCategoryWhereInput
    data: XOR<KnowledgeCategoryUpdateWithoutArticlesInput, KnowledgeCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type KnowledgeCategoryUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    school?: SchoolUpdateOneRequiredWithoutKnowledgeCategoriesNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolCreateWithoutPulseSurveysInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutPulseSurveysInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutPulseSurveysInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
  }

  export type PulseResponseCreateWithoutPulseInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPulseResponsesInput
  }

  export type PulseResponseUncheckedCreateWithoutPulseInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseCreateOrConnectWithoutPulseInput = {
    where: PulseResponseWhereUniqueInput
    create: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput>
  }

  export type PulseResponseCreateManyPulseInputEnvelope = {
    data: PulseResponseCreateManyPulseInput | PulseResponseCreateManyPulseInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutPulseSurveysInput = {
    update: XOR<SchoolUpdateWithoutPulseSurveysInput, SchoolUncheckedUpdateWithoutPulseSurveysInput>
    create: XOR<SchoolCreateWithoutPulseSurveysInput, SchoolUncheckedCreateWithoutPulseSurveysInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutPulseSurveysInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutPulseSurveysInput, SchoolUncheckedUpdateWithoutPulseSurveysInput>
  }

  export type SchoolUpdateWithoutPulseSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutPulseSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type PulseResponseUpsertWithWhereUniqueWithoutPulseInput = {
    where: PulseResponseWhereUniqueInput
    update: XOR<PulseResponseUpdateWithoutPulseInput, PulseResponseUncheckedUpdateWithoutPulseInput>
    create: XOR<PulseResponseCreateWithoutPulseInput, PulseResponseUncheckedCreateWithoutPulseInput>
  }

  export type PulseResponseUpdateWithWhereUniqueWithoutPulseInput = {
    where: PulseResponseWhereUniqueInput
    data: XOR<PulseResponseUpdateWithoutPulseInput, PulseResponseUncheckedUpdateWithoutPulseInput>
  }

  export type PulseResponseUpdateManyWithWhereWithoutPulseInput = {
    where: PulseResponseScalarWhereInput
    data: XOR<PulseResponseUpdateManyMutationInput, PulseResponseUncheckedUpdateManyWithoutPulseInput>
  }

  export type PulseSurveyCreateWithoutResponsesInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutPulseSurveysInput
  }

  export type PulseSurveyUncheckedCreateWithoutResponsesInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    schoolId: string
    createdAt?: Date | string
  }

  export type PulseSurveyCreateOrConnectWithoutResponsesInput = {
    where: PulseSurveyWhereUniqueInput
    create: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutPulseResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutPulseResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutPulseResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
  }

  export type PulseSurveyUpsertWithoutResponsesInput = {
    update: XOR<PulseSurveyUpdateWithoutResponsesInput, PulseSurveyUncheckedUpdateWithoutResponsesInput>
    create: XOR<PulseSurveyCreateWithoutResponsesInput, PulseSurveyUncheckedCreateWithoutResponsesInput>
    where?: PulseSurveyWhereInput
  }

  export type PulseSurveyUpdateToOneWithWhereWithoutResponsesInput = {
    where?: PulseSurveyWhereInput
    data: XOR<PulseSurveyUpdateWithoutResponsesInput, PulseSurveyUncheckedUpdateWithoutResponsesInput>
  }

  export type PulseSurveyUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPulseSurveysNestedInput
  }

  export type PulseSurveyUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPulseResponsesInput = {
    update: XOR<UserUpdateWithoutPulseResponsesInput, UserUncheckedUpdateWithoutPulseResponsesInput>
    create: XOR<UserCreateWithoutPulseResponsesInput, UserUncheckedCreateWithoutPulseResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPulseResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPulseResponsesInput, UserUncheckedUpdateWithoutPulseResponsesInput>
  }

  export type UserUpdateWithoutPulseResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPulseResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type SchoolCreateWithoutPoliciesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutPoliciesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutPoliciesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
  }

  export type SchoolUpsertWithoutPoliciesInput = {
    update: XOR<SchoolUpdateWithoutPoliciesInput, SchoolUncheckedUpdateWithoutPoliciesInput>
    create: XOR<SchoolCreateWithoutPoliciesInput, SchoolUncheckedCreateWithoutPoliciesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutPoliciesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutPoliciesInput, SchoolUncheckedUpdateWithoutPoliciesInput>
  }

  export type SchoolUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type FileFolderCreateWithoutChildrenInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    school: SchoolCreateNestedOneWithoutFoldersInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderCreateOrConnectWithoutChildrenInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
  }

  export type FileFolderCreateWithoutParentInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    children?: FileFolderCreateNestedManyWithoutParentInput
    school: SchoolCreateNestedOneWithoutFoldersInput
    files?: SchoolFileCreateNestedManyWithoutFolderInput
  }

  export type FileFolderUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FileFolderCreateOrConnectWithoutParentInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput>
  }

  export type FileFolderCreateManyParentInputEnvelope = {
    data: FileFolderCreateManyParentInput | FileFolderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutFoldersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFoldersInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFoldersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
  }

  export type SchoolFileCreateWithoutFolderInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFilesInput
  }

  export type SchoolFileUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolFileCreateOrConnectWithoutFolderInput = {
    where: SchoolFileWhereUniqueInput
    create: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput>
  }

  export type SchoolFileCreateManyFolderInputEnvelope = {
    data: SchoolFileCreateManyFolderInput | SchoolFileCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type FileFolderUpsertWithoutChildrenInput = {
    update: XOR<FileFolderUpdateWithoutChildrenInput, FileFolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<FileFolderCreateWithoutChildrenInput, FileFolderUncheckedCreateWithoutChildrenInput>
    where?: FileFolderWhereInput
  }

  export type FileFolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FileFolderWhereInput
    data: XOR<FileFolderUpdateWithoutChildrenInput, FileFolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FileFolderUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUpsertWithWhereUniqueWithoutParentInput = {
    where: FileFolderWhereUniqueInput
    update: XOR<FileFolderUpdateWithoutParentInput, FileFolderUncheckedUpdateWithoutParentInput>
    create: XOR<FileFolderCreateWithoutParentInput, FileFolderUncheckedCreateWithoutParentInput>
  }

  export type FileFolderUpdateWithWhereUniqueWithoutParentInput = {
    where: FileFolderWhereUniqueInput
    data: XOR<FileFolderUpdateWithoutParentInput, FileFolderUncheckedUpdateWithoutParentInput>
  }

  export type FileFolderUpdateManyWithWhereWithoutParentInput = {
    where: FileFolderScalarWhereInput
    data: XOR<FileFolderUpdateManyMutationInput, FileFolderUncheckedUpdateManyWithoutParentInput>
  }

  export type SchoolUpsertWithoutFoldersInput = {
    update: XOR<SchoolUpdateWithoutFoldersInput, SchoolUncheckedUpdateWithoutFoldersInput>
    create: XOR<SchoolCreateWithoutFoldersInput, SchoolUncheckedCreateWithoutFoldersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFoldersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFoldersInput, SchoolUncheckedUpdateWithoutFoldersInput>
  }

  export type SchoolUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolFileUpsertWithWhereUniqueWithoutFolderInput = {
    where: SchoolFileWhereUniqueInput
    update: XOR<SchoolFileUpdateWithoutFolderInput, SchoolFileUncheckedUpdateWithoutFolderInput>
    create: XOR<SchoolFileCreateWithoutFolderInput, SchoolFileUncheckedCreateWithoutFolderInput>
  }

  export type SchoolFileUpdateWithWhereUniqueWithoutFolderInput = {
    where: SchoolFileWhereUniqueInput
    data: XOR<SchoolFileUpdateWithoutFolderInput, SchoolFileUncheckedUpdateWithoutFolderInput>
  }

  export type SchoolFileUpdateManyWithWhereWithoutFolderInput = {
    where: SchoolFileScalarWhereInput
    data: XOR<SchoolFileUpdateManyMutationInput, SchoolFileUncheckedUpdateManyWithoutFolderInput>
  }

  export type FileFolderCreateWithoutFilesInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    parent?: FileFolderCreateNestedOneWithoutChildrenInput
    children?: FileFolderCreateNestedManyWithoutParentInput
    school: SchoolCreateNestedOneWithoutFoldersInput
  }

  export type FileFolderUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
    children?: FileFolderUncheckedCreateNestedManyWithoutParentInput
  }

  export type FileFolderCreateOrConnectWithoutFilesInput = {
    where: FileFolderWhereUniqueInput
    create: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
  }

  export type SchoolCreateWithoutFilesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFilesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
  }

  export type FileFolderUpsertWithoutFilesInput = {
    update: XOR<FileFolderUpdateWithoutFilesInput, FileFolderUncheckedUpdateWithoutFilesInput>
    create: XOR<FileFolderCreateWithoutFilesInput, FileFolderUncheckedCreateWithoutFilesInput>
    where?: FileFolderWhereInput
  }

  export type FileFolderUpdateToOneWithWhereWithoutFilesInput = {
    where?: FileFolderWhereInput
    data: XOR<FileFolderUpdateWithoutFilesInput, FileFolderUncheckedUpdateWithoutFilesInput>
  }

  export type FileFolderUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    children?: FileFolderUpdateManyWithoutParentNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
  }

  export type SchoolUpsertWithoutFilesInput = {
    update: XOR<SchoolUpdateWithoutFilesInput, SchoolUncheckedUpdateWithoutFilesInput>
    create: XOR<SchoolCreateWithoutFilesInput, SchoolUncheckedCreateWithoutFilesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFilesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFilesInput, SchoolUncheckedUpdateWithoutFilesInput>
  }

  export type SchoolUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutFormsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFormsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFormsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFormsInput, SchoolUncheckedCreateWithoutFormsInput>
  }

  export type MessageCreateWithoutFormInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutMessagesInput
    yearGroup?: YearGroupCreateNestedOneWithoutMessagesInput
    school: SchoolCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    acknowledgments?: MessageAcknowledgmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutFormInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutFormInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutFormInput, MessageUncheckedCreateWithoutFormInput>
  }

  export type FormResponseCreateWithoutFormInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFormResponsesInput
  }

  export type FormResponseUncheckedCreateWithoutFormInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormResponseCreateOrConnectWithoutFormInput = {
    where: FormResponseWhereUniqueInput
    create: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput>
  }

  export type FormResponseCreateManyFormInputEnvelope = {
    data: FormResponseCreateManyFormInput | FormResponseCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutFormsInput = {
    update: XOR<SchoolUpdateWithoutFormsInput, SchoolUncheckedUpdateWithoutFormsInput>
    create: XOR<SchoolCreateWithoutFormsInput, SchoolUncheckedCreateWithoutFormsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFormsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFormsInput, SchoolUncheckedUpdateWithoutFormsInput>
  }

  export type SchoolUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type MessageUpsertWithoutFormInput = {
    update: XOR<MessageUpdateWithoutFormInput, MessageUncheckedUpdateWithoutFormInput>
    create: XOR<MessageCreateWithoutFormInput, MessageUncheckedCreateWithoutFormInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutFormInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutFormInput, MessageUncheckedUpdateWithoutFormInput>
  }

  export type MessageUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type FormResponseUpsertWithWhereUniqueWithoutFormInput = {
    where: FormResponseWhereUniqueInput
    update: XOR<FormResponseUpdateWithoutFormInput, FormResponseUncheckedUpdateWithoutFormInput>
    create: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput>
  }

  export type FormResponseUpdateWithWhereUniqueWithoutFormInput = {
    where: FormResponseWhereUniqueInput
    data: XOR<FormResponseUpdateWithoutFormInput, FormResponseUncheckedUpdateWithoutFormInput>
  }

  export type FormResponseUpdateManyWithWhereWithoutFormInput = {
    where: FormResponseScalarWhereInput
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyWithoutFormInput>
  }

  export type FormCreateWithoutResponsesInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutFormsInput
    message?: MessageCreateNestedOneWithoutFormInput
  }

  export type FormUncheckedCreateWithoutResponsesInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: MessageUncheckedCreateNestedOneWithoutFormInput
  }

  export type FormCreateOrConnectWithoutResponsesInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutFormResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutFormResponsesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutFormResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFormResponsesInput, UserUncheckedCreateWithoutFormResponsesInput>
  }

  export type FormUpsertWithoutResponsesInput = {
    update: XOR<FormUpdateWithoutResponsesInput, FormUncheckedUpdateWithoutResponsesInput>
    create: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutResponsesInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutResponsesInput, FormUncheckedUpdateWithoutResponsesInput>
  }

  export type FormUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFormsNestedInput
    message?: MessageUpdateOneWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUncheckedUpdateOneWithoutFormNestedInput
  }

  export type UserUpsertWithoutFormResponsesInput = {
    update: XOR<UserUpdateWithoutFormResponsesInput, UserUncheckedUpdateWithoutFormResponsesInput>
    create: XOR<UserCreateWithoutFormResponsesInput, UserUncheckedCreateWithoutFormResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFormResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFormResponsesInput, UserUncheckedUpdateWithoutFormResponsesInput>
  }

  export type UserUpdateWithoutFormResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFormResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type SchoolCreateWithoutInvitationsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutInvitationsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutInvitationsInput, SchoolUncheckedCreateWithoutInvitationsInput>
  }

  export type ChildInvitationLinkCreateWithoutInvitationInput = {
    id?: string
    childName: string
    class: ClassCreateNestedOneWithoutChildInvitationLinksInput
  }

  export type ChildInvitationLinkUncheckedCreateWithoutInvitationInput = {
    id?: string
    childName: string
    classId: string
  }

  export type ChildInvitationLinkCreateOrConnectWithoutInvitationInput = {
    where: ChildInvitationLinkWhereUniqueInput
    create: XOR<ChildInvitationLinkCreateWithoutInvitationInput, ChildInvitationLinkUncheckedCreateWithoutInvitationInput>
  }

  export type ChildInvitationLinkCreateManyInvitationInputEnvelope = {
    data: ChildInvitationLinkCreateManyInvitationInput | ChildInvitationLinkCreateManyInvitationInput[]
    skipDuplicates?: boolean
  }

  export type StudentInvitationLinkCreateWithoutInvitationInput = {
    id?: string
    student: StudentCreateNestedOneWithoutInvitationLinksInput
  }

  export type StudentInvitationLinkUncheckedCreateWithoutInvitationInput = {
    id?: string
    studentId: string
  }

  export type StudentInvitationLinkCreateOrConnectWithoutInvitationInput = {
    where: StudentInvitationLinkWhereUniqueInput
    create: XOR<StudentInvitationLinkCreateWithoutInvitationInput, StudentInvitationLinkUncheckedCreateWithoutInvitationInput>
  }

  export type StudentInvitationLinkCreateManyInvitationInputEnvelope = {
    data: StudentInvitationLinkCreateManyInvitationInput | StudentInvitationLinkCreateManyInvitationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRedeemedInvitationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutRedeemedInvitationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutRedeemedInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRedeemedInvitationsInput, UserUncheckedCreateWithoutRedeemedInvitationsInput>
  }

  export type UserCreateWithoutCreatedInvitationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedInvitationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedInvitationsInput, UserUncheckedCreateWithoutCreatedInvitationsInput>
  }

  export type SchoolUpsertWithoutInvitationsInput = {
    update: XOR<SchoolUpdateWithoutInvitationsInput, SchoolUncheckedUpdateWithoutInvitationsInput>
    create: XOR<SchoolCreateWithoutInvitationsInput, SchoolUncheckedCreateWithoutInvitationsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutInvitationsInput, SchoolUncheckedUpdateWithoutInvitationsInput>
  }

  export type SchoolUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ChildInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput = {
    where: ChildInvitationLinkWhereUniqueInput
    update: XOR<ChildInvitationLinkUpdateWithoutInvitationInput, ChildInvitationLinkUncheckedUpdateWithoutInvitationInput>
    create: XOR<ChildInvitationLinkCreateWithoutInvitationInput, ChildInvitationLinkUncheckedCreateWithoutInvitationInput>
  }

  export type ChildInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput = {
    where: ChildInvitationLinkWhereUniqueInput
    data: XOR<ChildInvitationLinkUpdateWithoutInvitationInput, ChildInvitationLinkUncheckedUpdateWithoutInvitationInput>
  }

  export type ChildInvitationLinkUpdateManyWithWhereWithoutInvitationInput = {
    where: ChildInvitationLinkScalarWhereInput
    data: XOR<ChildInvitationLinkUpdateManyMutationInput, ChildInvitationLinkUncheckedUpdateManyWithoutInvitationInput>
  }

  export type StudentInvitationLinkUpsertWithWhereUniqueWithoutInvitationInput = {
    where: StudentInvitationLinkWhereUniqueInput
    update: XOR<StudentInvitationLinkUpdateWithoutInvitationInput, StudentInvitationLinkUncheckedUpdateWithoutInvitationInput>
    create: XOR<StudentInvitationLinkCreateWithoutInvitationInput, StudentInvitationLinkUncheckedCreateWithoutInvitationInput>
  }

  export type StudentInvitationLinkUpdateWithWhereUniqueWithoutInvitationInput = {
    where: StudentInvitationLinkWhereUniqueInput
    data: XOR<StudentInvitationLinkUpdateWithoutInvitationInput, StudentInvitationLinkUncheckedUpdateWithoutInvitationInput>
  }

  export type StudentInvitationLinkUpdateManyWithWhereWithoutInvitationInput = {
    where: StudentInvitationLinkScalarWhereInput
    data: XOR<StudentInvitationLinkUpdateManyMutationInput, StudentInvitationLinkUncheckedUpdateManyWithoutInvitationInput>
  }

  export type UserUpsertWithoutRedeemedInvitationsInput = {
    update: XOR<UserUpdateWithoutRedeemedInvitationsInput, UserUncheckedUpdateWithoutRedeemedInvitationsInput>
    create: XOR<UserCreateWithoutRedeemedInvitationsInput, UserUncheckedCreateWithoutRedeemedInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRedeemedInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRedeemedInvitationsInput, UserUncheckedUpdateWithoutRedeemedInvitationsInput>
  }

  export type UserUpdateWithoutRedeemedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRedeemedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUpsertWithoutCreatedInvitationsInput = {
    update: XOR<UserUpdateWithoutCreatedInvitationsInput, UserUncheckedUpdateWithoutCreatedInvitationsInput>
    create: XOR<UserCreateWithoutCreatedInvitationsInput, UserUncheckedCreateWithoutCreatedInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedInvitationsInput, UserUncheckedUpdateWithoutCreatedInvitationsInput>
  }

  export type UserUpdateWithoutCreatedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type ParentInvitationCreateWithoutChildLinksInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdAt?: Date | string
    school: SchoolCreateNestedOneWithoutInvitationsInput
    studentLinks?: StudentInvitationLinkCreateNestedManyWithoutInvitationInput
    redeemedByUser?: UserCreateNestedOneWithoutRedeemedInvitationsInput
    createdBy: UserCreateNestedOneWithoutCreatedInvitationsInput
  }

  export type ParentInvitationUncheckedCreateWithoutChildLinksInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdById: string
    createdAt?: Date | string
    studentLinks?: StudentInvitationLinkUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type ParentInvitationCreateOrConnectWithoutChildLinksInput = {
    where: ParentInvitationWhereUniqueInput
    create: XOR<ParentInvitationCreateWithoutChildLinksInput, ParentInvitationUncheckedCreateWithoutChildLinksInput>
  }

  export type ClassCreateWithoutChildInvitationLinksInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    school: SchoolCreateNestedOneWithoutClassesInput
    yearGroup?: YearGroupCreateNestedOneWithoutClassesInput
    children?: ChildCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    messages?: MessageCreateNestedManyWithoutClassInput
    events?: EventCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutChildInvitationLinksInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
    yearGroupId?: string | null
    children?: ChildUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    messages?: MessageUncheckedCreateNestedManyWithoutClassInput
    events?: EventUncheckedCreateNestedManyWithoutClassInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutClassInput
    assignedStaff?: StaffClassAssignmentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutChildInvitationLinksInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutChildInvitationLinksInput, ClassUncheckedCreateWithoutChildInvitationLinksInput>
  }

  export type ParentInvitationUpsertWithoutChildLinksInput = {
    update: XOR<ParentInvitationUpdateWithoutChildLinksInput, ParentInvitationUncheckedUpdateWithoutChildLinksInput>
    create: XOR<ParentInvitationCreateWithoutChildLinksInput, ParentInvitationUncheckedCreateWithoutChildLinksInput>
    where?: ParentInvitationWhereInput
  }

  export type ParentInvitationUpdateToOneWithWhereWithoutChildLinksInput = {
    where?: ParentInvitationWhereInput
    data: XOR<ParentInvitationUpdateWithoutChildLinksInput, ParentInvitationUncheckedUpdateWithoutChildLinksInput>
  }

  export type ParentInvitationUpdateWithoutChildLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvitationsNestedInput
    studentLinks?: StudentInvitationLinkUpdateManyWithoutInvitationNestedInput
    redeemedByUser?: UserUpdateOneWithoutRedeemedInvitationsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvitationsNestedInput
  }

  export type ParentInvitationUncheckedUpdateWithoutChildLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type ClassUpsertWithoutChildInvitationLinksInput = {
    update: XOR<ClassUpdateWithoutChildInvitationLinksInput, ClassUncheckedUpdateWithoutChildInvitationLinksInput>
    create: XOR<ClassCreateWithoutChildInvitationLinksInput, ClassUncheckedCreateWithoutChildInvitationLinksInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutChildInvitationLinksInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutChildInvitationLinksInput, ClassUncheckedUpdateWithoutChildInvitationLinksInput>
  }

  export type ClassUpdateWithoutChildInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutChildInvitationLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type SchoolCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    notifications?: NotificationCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAuditLogsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAuditLogsInput, SchoolUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type SchoolUpsertWithoutAuditLogsInput = {
    update: XOR<SchoolUpdateWithoutAuditLogsInput, SchoolUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<SchoolCreateWithoutAuditLogsInput, SchoolUncheckedCreateWithoutAuditLogsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAuditLogsInput, SchoolUncheckedUpdateWithoutAuditLogsInput>
  }

  export type SchoolUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type SchoolCreateWithoutNotificationsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    students?: StudentCreateNestedManyWithoutSchoolInput
    messages?: MessageCreateNestedManyWithoutSchoolInput
    forms?: FormCreateNestedManyWithoutSchoolInput
    events?: EventCreateNestedManyWithoutSchoolInput
    termDates?: TermDateCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyCreateNestedManyWithoutSchoolInput
    policies?: PolicyCreateNestedManyWithoutSchoolInput
    folders?: FileFolderCreateNestedManyWithoutSchoolInput
    files?: SchoolFileCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    shortName: string
    city: string
    academicYear?: string
    brandColor?: string
    accentColor?: string
    tagline?: string | null
    logoUrl?: string | null
    logoIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    yearGroups?: YearGroupUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    messages?: MessageUncheckedCreateNestedManyWithoutSchoolInput
    forms?: FormUncheckedCreateNestedManyWithoutSchoolInput
    events?: EventUncheckedCreateNestedManyWithoutSchoolInput
    termDates?: TermDateUncheckedCreateNestedManyWithoutSchoolInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutSchoolInput
    weeklyMessages?: WeeklyMessageUncheckedCreateNestedManyWithoutSchoolInput
    knowledgeCategories?: KnowledgeCategoryUncheckedCreateNestedManyWithoutSchoolInput
    pulseSurveys?: PulseSurveyUncheckedCreateNestedManyWithoutSchoolInput
    policies?: PolicyUncheckedCreateNestedManyWithoutSchoolInput
    folders?: FileFolderUncheckedCreateNestedManyWithoutSchoolInput
    files?: SchoolFileUncheckedCreateNestedManyWithoutSchoolInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutSchoolInput
    invitations?: ParentInvitationUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutNotificationsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutNotificationsInput, SchoolUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type SchoolUpsertWithoutNotificationsInput = {
    update: XOR<SchoolUpdateWithoutNotificationsInput, SchoolUncheckedUpdateWithoutNotificationsInput>
    create: XOR<SchoolCreateWithoutNotificationsInput, SchoolUncheckedCreateWithoutNotificationsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutNotificationsInput, SchoolUncheckedUpdateWithoutNotificationsInput>
  }

  export type SchoolUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    students?: StudentUpdateManyWithoutSchoolNestedInput
    messages?: MessageUpdateManyWithoutSchoolNestedInput
    forms?: FormUpdateManyWithoutSchoolNestedInput
    events?: EventUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    brandColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    logoIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    yearGroups?: YearGroupUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSchoolNestedInput
    forms?: FormUncheckedUpdateManyWithoutSchoolNestedInput
    events?: EventUncheckedUpdateManyWithoutSchoolNestedInput
    termDates?: TermDateUncheckedUpdateManyWithoutSchoolNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutSchoolNestedInput
    weeklyMessages?: WeeklyMessageUncheckedUpdateManyWithoutSchoolNestedInput
    knowledgeCategories?: KnowledgeCategoryUncheckedUpdateManyWithoutSchoolNestedInput
    pulseSurveys?: PulseSurveyUncheckedUpdateManyWithoutSchoolNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutSchoolNestedInput
    folders?: FileFolderUncheckedUpdateManyWithoutSchoolNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutSchoolNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutSchoolNestedInput
    invitations?: ParentInvitationUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserCreateWithoutDeviceTokensInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutUsersInput
    children?: ChildCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentCreateNestedManyWithoutUserInput
    formResponses?: FormResponseCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserUncheckedCreateWithoutDeviceTokensInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    schoolId: string
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ChildUncheckedCreateNestedManyWithoutParentInput
    studentLinks?: ParentStudentLinkUncheckedCreateNestedManyWithoutUserInput
    assignedClasses?: StaffClassAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageAcks?: MessageAcknowledgmentUncheckedCreateNestedManyWithoutUserInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutUserInput
    eventRsvps?: EventRsvpUncheckedCreateNestedManyWithoutUserInput
    pulseResponses?: PulseResponseUncheckedCreateNestedManyWithoutUserInput
    weeklyHearts?: WeeklyMessageHeartUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutCreatedByInput
    redeemedInvitations?: ParentInvitationUncheckedCreateNestedManyWithoutRedeemedByUserInput
  }

  export type UserCreateOrConnectWithoutDeviceTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
  }

  export type UserUpsertWithoutDeviceTokensInput = {
    update: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutUsersNestedInput
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    schoolId?: StringFieldUpdateOperationsInput | string
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserCreateManySchoolInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.Role
    googleId?: string | null
    microsoftId?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YearGroupCreateManySchoolInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManySchoolInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    yearGroupId?: string | null
  }

  export type StudentCreateManySchoolInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    classId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySchoolInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormCreateManySchoolInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    fields: JsonNullValueInput | InputJsonValue
    targetClass: string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManySchoolInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermDateCreateManySchoolInput = {
    id?: string
    term: number
    termName: string
    label: string
    sublabel?: string | null
    date: Date | string
    endDate?: Date | string | null
    type: string
    color: string
  }

  export type ScheduleItemCreateManySchoolInput = {
    id?: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type WeeklyMessageCreateManySchoolInput = {
    id?: string
    title: string
    content: string
    weekOf: Date | string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type KnowledgeCategoryCreateManySchoolInput = {
    id?: string
    name: string
    icon: string
    color: string
    order?: number
  }

  export type PulseSurveyCreateManySchoolInput = {
    id?: string
    halfTermName: string
    status: string
    opensAt: Date | string
    closesAt: Date | string
    additionalQuestionKey?: string | null
    createdAt?: Date | string
  }

  export type PolicyCreateManySchoolInput = {
    id?: string
    name: string
    description?: string | null
    fileUrl: string
    fileSize?: number | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type FileFolderCreateManySchoolInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    parentId?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type SchoolFileCreateManySchoolInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    folderId?: string | null
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManySchoolInput = {
    id?: string
    userId: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManySchoolInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type ParentInvitationCreateManySchoolInput = {
    id?: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChildUncheckedUpdateManyWithoutParentNestedInput
    studentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutUserNestedInput
    assignedClasses?: StaffClassAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageAcks?: MessageAcknowledgmentUncheckedUpdateManyWithoutUserNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutUserNestedInput
    eventRsvps?: EventRsvpUncheckedUpdateManyWithoutUserNestedInput
    pulseResponses?: PulseResponseUncheckedUpdateManyWithoutUserNestedInput
    weeklyHearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    createdInvitations?: ParentInvitationUncheckedUpdateManyWithoutCreatedByNestedInput
    redeemedInvitations?: ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearGroupUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUpdateManyWithoutYearGroupNestedInput
    events?: EventUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutYearGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutYearGroupNestedInput
    events?: EventUncheckedUpdateManyWithoutYearGroupNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutYearGroupNestedInput
  }

  export type YearGroupUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    yearGroup?: YearGroupUpdateOneWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    parentLinks?: ParentStudentLinkUpdateManyWithoutStudentNestedInput
    invitationLinks?: StudentInvitationLinkUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutStudentNestedInput
    invitationLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    form?: FormUpdateOneWithoutMessageNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneWithoutFormNestedInput
    responses?: FormResponseUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUncheckedUpdateOneWithoutFormNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    targetClass?: StringFieldUpdateOperationsInput | string
    classIds?: JsonNullValueInput | InputJsonValue
    yearGroupIds?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutEventsNestedInput
    yearGroup?: YearGroupUpdateOneWithoutEventsNestedInput
    rsvps?: EventRsvpUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: EventRsvpUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermDateUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TermDateUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: IntFieldUpdateOperationsInput | number
    termName?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sublabel?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleItemUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutScheduleItemsNestedInput
    yearGroup?: YearGroupUpdateOneWithoutScheduleItemsNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: WeeklyMessageHeartUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hearts?: WeeklyMessageHeartUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type WeeklyMessageUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    weekOf?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCategoryUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    articles?: KnowledgeArticleUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    articles?: KnowledgeArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeCategoryUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PulseSurveyUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PulseResponseUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PulseResponseUncheckedUpdateManyWithoutPulseNestedInput
  }

  export type PulseSurveyUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    halfTermName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    opensAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalQuestionKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FileFolderUpdateOneWithoutChildrenNestedInput
    children?: FileFolderUpdateManyWithoutParentNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FileFolderUpdateOneWithoutFilesNestedInput
  }

  export type SchoolFileUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInvitationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLinks?: ChildInvitationLinkUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUpdateManyWithoutInvitationNestedInput
    redeemedByUser?: UserUpdateOneWithoutRedeemedInvitationsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvitationsNestedInput
  }

  export type ParentInvitationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type ParentInvitationUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateManyParentInput = {
    id?: string
    name: string
    classId: string
  }

  export type ParentStudentLinkCreateManyUserInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
  }

  export type StaffClassAssignmentCreateManyUserInput = {
    id?: string
    classId: string
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    yearGroupId?: string | null
    schoolId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageAcknowledgmentCreateManyUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type FormResponseCreateManyUserInput = {
    id?: string
    formId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventRsvpCreateManyUserInput = {
    id?: string
    eventId: string
    status: string
    createdAt?: Date | string
  }

  export type PulseResponseCreateManyUserInput = {
    id?: string
    pulseId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartCreateManyUserInput = {
    id?: string
    messageId: string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    userName: string
    action: $Enums.AuditAction
    resourceType: $Enums.AuditResourceType
    resourceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId: string
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    body: string
    resourceType?: string | null
    resourceId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    schoolId: string
    createdAt?: Date | string
  }

  export type DeviceTokenCreateManyUserInput = {
    id?: string
    token: string
    platform: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentInvitationCreateManyCreatedByInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    redeemedByUserId?: string | null
    createdAt?: Date | string
  }

  export type ParentInvitationCreateManyRedeemedByUserInput = {
    id?: string
    schoolId: string
    accessCode: string
    magicToken?: string | null
    parentEmail?: string | null
    parentName?: string | null
    status?: string
    expiresAt?: Date | string | null
    redeemedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
  }

  export type ChildUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ParentStudentLinkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutParentLinksNestedInput
  }

  export type ParentStudentLinkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentLinkUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffClassAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAssignedStaffNestedInput
  }

  export type StaffClassAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffClassAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    yearGroup?: YearGroupUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    form?: FormUpdateOneWithoutMessageNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAcknowledgmentsNestedInput
  }

  export type MessageAcknowledgmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRsvpsNestedInput
  }

  export type EventRsvpUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pulse?: PulseSurveyUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type PulseResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pulseId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: WeeklyMessageUpdateOneRequiredWithoutHeartsNestedInput
  }

  export type WeeklyMessageHeartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    resourceType?: EnumAuditResourceTypeFieldUpdateOperationsInput | $Enums.AuditResourceType
    resourceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schoolId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInvitationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvitationsNestedInput
    childLinks?: ChildInvitationLinkUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUpdateManyWithoutInvitationNestedInput
    redeemedByUser?: UserUpdateOneWithoutRedeemedInvitationsNestedInput
  }

  export type ParentInvitationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type ParentInvitationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInvitationUpdateWithoutRedeemedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutInvitationsNestedInput
    childLinks?: ChildInvitationLinkUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUpdateManyWithoutInvitationNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvitationsNestedInput
  }

  export type ParentInvitationUncheckedUpdateWithoutRedeemedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
    studentLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type ParentInvitationUncheckedUpdateManyWithoutRedeemedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    accessCode?: StringFieldUpdateOperationsInput | string
    magicToken?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentLinkCreateManyStudentInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type StudentInvitationLinkCreateManyStudentInput = {
    id?: string
    invitationId: string
  }

  export type ParentStudentLinkUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentLinksNestedInput
  }

  export type ParentStudentLinkUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentStudentLinkUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentInvitationLinkUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitation?: ParentInvitationUpdateOneRequiredWithoutStudentLinksNestedInput
  }

  export type StudentInvitationLinkUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentInvitationLinkUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateManyYearGroupInput = {
    id?: string
    name: string
    colorBg?: string
    colorText?: string
    schoolId: string
  }

  export type MessageCreateManyYearGroupInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    classId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyYearGroupInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    classId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleItemCreateManyYearGroupInput = {
    id?: string
    targetClass: string
    classId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type ClassUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    children?: ChildUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    messages?: MessageUpdateManyWithoutClassNestedInput
    events?: EventUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    children?: ChildUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    messages?: MessageUncheckedUpdateManyWithoutClassNestedInput
    events?: EventUncheckedUpdateManyWithoutClassNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutClassNestedInput
    assignedStaff?: StaffClassAssignmentUncheckedUpdateManyWithoutClassNestedInput
    childInvitationLinks?: ChildInvitationLinkUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    colorBg?: StringFieldUpdateOperationsInput | string
    colorText?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    form?: FormUpdateOneWithoutMessageNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutEventsNestedInput
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: EventRsvpUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: EventRsvpUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutScheduleItemsNestedInput
    school?: SchoolUpdateOneRequiredWithoutScheduleItemsNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyWithoutYearGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateManyClassInput = {
    id?: string
    name: string
    parentId: string
  }

  export type StudentCreateManyClassInput = {
    id?: string
    firstName: string
    lastName: string
    externalId?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyClassInput = {
    id?: string
    title: string
    content: string
    targetClass: string
    yearGroupId?: string | null
    schoolId: string
    senderId: string
    senderName: string
    actionType?: string | null
    actionLabel?: string | null
    actionDueDate?: Date | string | null
    actionAmount?: string | null
    isPinned?: boolean
    isUrgent?: boolean
    expiresAt?: Date | string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyClassInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time?: string | null
    location?: string | null
    targetClass: string
    yearGroupId?: string | null
    schoolId: string
    requiresRsvp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleItemCreateManyClassInput = {
    id?: string
    targetClass: string
    yearGroupId?: string | null
    schoolId: string
    isRecurring?: boolean
    dayOfWeek?: number | null
    active?: boolean
    date?: Date | string | null
    type: string
    label: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type StaffClassAssignmentCreateManyClassInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ChildInvitationLinkCreateManyClassInput = {
    id?: string
    invitationId: string
    childName: string
  }

  export type ChildUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent?: UserUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    parentLinks?: ParentStudentLinkUpdateManyWithoutStudentNestedInput
    invitationLinks?: StudentInvitationLinkUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentLinks?: ParentStudentLinkUncheckedUpdateManyWithoutStudentNestedInput
    invitationLinks?: StudentInvitationLinkUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearGroup?: YearGroupUpdateOneWithoutMessagesNestedInput
    school?: SchoolUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    form?: FormUpdateOneWithoutMessageNestedInput
    acknowledgments?: MessageAcknowledgmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgments?: MessageAcknowledgmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    actionDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearGroup?: YearGroupUpdateOneWithoutEventsNestedInput
    school?: SchoolUpdateOneRequiredWithoutEventsNestedInput
    rsvps?: EventRsvpUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rsvps?: EventRsvpUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    targetClass?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    requiresRsvp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearGroup?: YearGroupUpdateOneWithoutScheduleItemsNestedInput
    school?: SchoolUpdateOneRequiredWithoutScheduleItemsNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetClass?: StringFieldUpdateOperationsInput | string
    yearGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffClassAssignmentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAssignedClassesNestedInput
  }

  export type StaffClassAssignmentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffClassAssignmentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildInvitationLinkUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
    invitation?: ParentInvitationUpdateOneRequiredWithoutChildLinksNestedInput
  }

  export type ChildInvitationLinkUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
  }

  export type ChildInvitationLinkUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitationId?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
  }

  export type MessageAcknowledgmentCreateManyMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageAcknowledgmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageAcksNestedInput
  }

  export type MessageAcknowledgmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAcknowledgmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpCreateManyEventInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type EventRsvpUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventRsvpsNestedInput
  }

  export type EventRsvpUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRsvpUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartCreateManyMessageInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type WeeklyMessageHeartUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWeeklyHeartsNestedInput
  }

  export type WeeklyMessageHeartUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyMessageHeartUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleCreateManyCategoryInput = {
    id?: string
    title: string
    content: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type KnowledgeArticleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseCreateManyPulseInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PulseResponseUpdateWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPulseResponsesNestedInput
  }

  export type PulseResponseUncheckedUpdateWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PulseResponseUncheckedUpdateManyWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileFolderCreateManyParentInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    schoolId: string
    order?: number
    createdAt?: Date | string
  }

  export type SchoolFileCreateManyFolderInput = {
    id?: string
    name: string
    fileName: string
    fileUrl: string
    fileType: string
    fileSize: number
    schoolId: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileFolderUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUpdateManyWithoutParentNestedInput
    school?: SchoolUpdateOneRequiredWithoutFoldersNestedInput
    files?: SchoolFileUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FileFolderUncheckedUpdateManyWithoutParentNestedInput
    files?: SchoolFileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FileFolderUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutFilesNestedInput
  }

  export type SchoolFileUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolFileUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseCreateManyFormInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormResponseUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFormResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildInvitationLinkCreateManyInvitationInput = {
    id?: string
    childName: string
    classId: string
  }

  export type StudentInvitationLinkCreateManyInvitationInput = {
    id?: string
    studentId: string
  }

  export type ChildInvitationLinkUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutChildInvitationLinksNestedInput
  }

  export type ChildInvitationLinkUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ChildInvitationLinkUncheckedUpdateManyWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    childName?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentInvitationLinkUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutInvitationLinksNestedInput
  }

  export type StudentInvitationLinkUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentInvitationLinkUncheckedUpdateManyWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use YearGroupCountOutputTypeDefaultArgs instead
     */
    export type YearGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = YearGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassCountOutputTypeDefaultArgs instead
     */
    export type ClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyMessageCountOutputTypeDefaultArgs instead
     */
    export type WeeklyMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeCategoryCountOutputTypeDefaultArgs instead
     */
    export type KnowledgeCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PulseSurveyCountOutputTypeDefaultArgs instead
     */
    export type PulseSurveyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PulseSurveyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileFolderCountOutputTypeDefaultArgs instead
     */
    export type FileFolderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileFolderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormCountOutputTypeDefaultArgs instead
     */
    export type FormCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentInvitationCountOutputTypeDefaultArgs instead
     */
    export type ParentInvitationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentInvitationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolDefaultArgs instead
     */
    export type SchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChildDefaultArgs instead
     */
    export type ChildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentStudentLinkDefaultArgs instead
     */
    export type ParentStudentLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentStudentLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentInvitationLinkDefaultArgs instead
     */
    export type StudentInvitationLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentInvitationLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use YearGroupDefaultArgs instead
     */
    export type YearGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = YearGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassDefaultArgs instead
     */
    export type ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffClassAssignmentDefaultArgs instead
     */
    export type StaffClassAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffClassAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageAcknowledgmentDefaultArgs instead
     */
    export type MessageAcknowledgmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageAcknowledgmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventRsvpDefaultArgs instead
     */
    export type EventRsvpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventRsvpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TermDateDefaultArgs instead
     */
    export type TermDateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TermDateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleItemDefaultArgs instead
     */
    export type ScheduleItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyMessageDefaultArgs instead
     */
    export type WeeklyMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyMessageHeartDefaultArgs instead
     */
    export type WeeklyMessageHeartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyMessageHeartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeCategoryDefaultArgs instead
     */
    export type KnowledgeCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeArticleDefaultArgs instead
     */
    export type KnowledgeArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PulseSurveyDefaultArgs instead
     */
    export type PulseSurveyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PulseSurveyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PulseResponseDefaultArgs instead
     */
    export type PulseResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PulseResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyDefaultArgs instead
     */
    export type PolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileFolderDefaultArgs instead
     */
    export type FileFolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileFolderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolFileDefaultArgs instead
     */
    export type SchoolFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormDefaultArgs instead
     */
    export type FormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormResponseDefaultArgs instead
     */
    export type FormResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentInvitationDefaultArgs instead
     */
    export type ParentInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChildInvitationLinkDefaultArgs instead
     */
    export type ChildInvitationLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChildInvitationLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceTokenDefaultArgs instead
     */
    export type DeviceTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MagicLinkTokenDefaultArgs instead
     */
    export type MagicLinkTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MagicLinkTokenDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}